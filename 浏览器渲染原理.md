# æµè§ˆå™¨æ¸²æŸ“åŸç†ï¼šä»URLè¾“å…¥åˆ°é¡µé¢å±•ç¤ºçš„å®Œæ•´æµç¨‹

> æœ¬æ–‡æ¡£è¯¦ç»†è§£ææµè§ˆå™¨ä»æ¥æ”¶URLåˆ°æœ€ç»ˆå±•ç¤ºé¡µé¢å†…å®¹çš„å®Œæ•´è¿‡ç¨‹ï¼Œæ¶µç›–ç½‘ç»œé€šä¿¡ã€èµ„æºè§£æã€DOMæ„å»ºã€æ ·å¼è®¡ç®—ã€å¸ƒå±€ç»˜åˆ¶ç­‰å…³é”®ç¯èŠ‚ã€‚

## ğŸ“‹ ç›®å½•

1. [æ¦‚è¿°](#æ¦‚è¿°)
2. [URLè§£æé˜¶æ®µ](#urlè§£æé˜¶æ®µ)
3. [DNSåŸŸåè§£æ](#dnsåŸŸåè§£æ)
4. [å»ºç«‹ç½‘ç»œè¿æ¥](#å»ºç«‹ç½‘ç»œè¿æ¥)
5. [HTTPè¯·æ±‚ä¸å“åº”](#httpè¯·æ±‚ä¸å“åº”)
6. [èµ„æºè§£æå¤„ç†](#èµ„æºè§£æå¤„ç†)
7. [DOMæ ‘æ„å»º](#domæ ‘æ„å»º)
8. [CSSè§£æä¸CSSOM](#cssè§£æä¸cssom)
9. [å¸ƒå±€è®¡ç®—Layout](#å¸ƒå±€è®¡ç®—layout)
10. [ç»˜åˆ¶é˜¶æ®µPaint](#ç»˜åˆ¶é˜¶æ®µpaint)
11. [åˆæˆé˜¶æ®µComposite](#åˆæˆé˜¶æ®µcomposite)
12. [JavaScriptæ‰§è¡Œ](#javascriptæ‰§è¡Œ)
13. [æ€§èƒ½ä¼˜åŒ–ç­–ç•¥](#æ€§èƒ½ä¼˜åŒ–ç­–ç•¥)
14. [æ—¶é—´çº¿åˆ†æ](#æ—¶é—´çº¿åˆ†æ)

---

## æ¦‚è¿°

å½“ç”¨æˆ·åœ¨æµè§ˆå™¨åœ°å€æ è¾“å…¥URLå¹¶æŒ‰ä¸‹å›è½¦é”®æ—¶ï¼Œæµè§ˆå™¨ä¼šå¯åŠ¨ä¸€ä¸ªå¤æ‚çš„å¤„ç†æµç¨‹ï¼Œæ¶‰åŠç½‘ç»œé€šä¿¡ã€èµ„æºè§£æã€é¡µé¢æ¸²æŸ“ç­‰å¤šä¸ªé˜¶æ®µã€‚æ•´ä¸ªè¿‡ç¨‹å¯ä»¥åˆ†ä¸ºä»¥ä¸‹ä¸»è¦æ­¥éª¤ï¼š

```
ç”¨æˆ·è¾“å…¥URL â†’ URLè§£æ â†’ DNSè§£æ â†’ å»ºç«‹è¿æ¥ â†’ å‘é€è¯·æ±‚ â†’ æ¥æ”¶å“åº” 
â†’ è§£æHTML â†’ æ„å»ºDOM â†’ è§£æCSS â†’ æ ·å¼è®¡ç®— â†’ å¸ƒå±€è®¡ç®— â†’ ç»˜åˆ¶ â†’ åˆæˆ â†’ æ˜¾ç¤ºé¡µé¢
```

---

## URLè§£æé˜¶æ®µ

### 1.1 URLæ ¼å¼è§£æ

æµè§ˆå™¨é¦–å…ˆéœ€è¦è§£æç”¨æˆ·è¾“å…¥çš„URLï¼Œæå–å„ä¸ªç»„æˆéƒ¨åˆ†ï¼š

```javascript
// URLè§£æç¤ºä¾‹
const inputUrl = "https://www.example.com:443/path/page?query=value#fragment";

// æµè§ˆå™¨è§£æç»“æœ
const parsedUrl = {
  protocol: "https:",           // åè®®ç±»å‹
  hostname: "www.example.com",  // ä¸»æœºå
  port: "443",                 // ç«¯å£å·ï¼ˆHTTPSé»˜è®¤443ï¼ŒHTTPé»˜è®¤80ï¼‰
  pathname: "/path/page",       // è·¯å¾„
  search: "?query=value",       // æŸ¥è¯¢å‚æ•°
  hash: "#fragment"            // é”šç‚¹/ç‰‡æ®µæ ‡è¯†ç¬¦
};
```

### 1.2 URLè¡¥å…¨ä¸éªŒè¯

```javascript
// æµè§ˆå™¨è‡ªåŠ¨è¡¥å…¨é€»è¾‘
const urlCompletion = {
  // è¡¥å…¨åè®®
  addProtocol: (url) => {
    if (!url.startsWith('http://') && !url.startsWith('https://')) {
      return 'https://' + url; // ç°ä»£æµè§ˆå™¨é»˜è®¤ä½¿ç”¨HTTPS
    }
    return url;
  },
  
  // è¡¥å…¨ç«¯å£
  addDefaultPort: (protocol) => {
    return {
      'http:': '80',
      'https:': '443',
      'ftp:': '21'
    }[protocol];
  },
  
  // éªŒè¯URLæœ‰æ•ˆæ€§
  validate: (url) => {
    try {
      new URL(url);
      return true;
    } catch (error) {
      return false;
    }
  }
};
```

---

## DNSåŸŸåè§£æ

### 2.1 DNSæŸ¥è¯¢æµç¨‹

DNSè§£ææ˜¯å°†åŸŸåè½¬æ¢ä¸ºIPåœ°å€çš„è¿‡ç¨‹ï¼Œé‡‡ç”¨åˆ†å±‚æŸ¥è¯¢æœºåˆ¶ï¼š

```mermaid
graph TD
    A[ç”¨æˆ·è¾“å…¥åŸŸå] --> B[æµè§ˆå™¨DNSç¼“å­˜]
    B --> C{ç¼“å­˜å‘½ä¸­?}
    C -->|æ˜¯| M[ä½¿ç”¨ç¼“å­˜IP]
    C -->|å¦| D[æ“ä½œç³»ç»ŸDNSç¼“å­˜]
    D --> E{ç¼“å­˜å‘½ä¸­?}
    E -->|æ˜¯| M
    E -->|å¦| F[è·¯ç”±å™¨DNSç¼“å­˜]
    F --> G{ç¼“å­˜å‘½ä¸­?}
    G -->|æ˜¯| M
    G -->|å¦| H[ISP DNSæœåŠ¡å™¨]
    H --> I[æ ¹åŸŸåæœåŠ¡å™¨]
    I --> J[é¡¶çº§åŸŸåæœåŠ¡å™¨]
    J --> K[æƒå¨åŸŸåæœåŠ¡å™¨]
    K --> L[è¿”å›IPåœ°å€]
    L --> M
```

### 2.2 DNSè§£æå®ç°ç»†èŠ‚

```javascript
// DNSè§£æè¿‡ç¨‹æ¨¡æ‹Ÿ
const dnsResolver = {
  // 1. æ£€æŸ¥æµè§ˆå™¨ç¼“å­˜
  checkBrowserCache: (domain) => {
    const cache = browser.dnsCache.get(domain);
    if (cache && !cache.isExpired()) {
      return cache.ip;
    }
    return null;
  },
  
  // 2. æ£€æŸ¥æ“ä½œç³»ç»Ÿç¼“å­˜
  checkOSCache: (domain) => {
    // æ£€æŸ¥ /etc/hosts æ–‡ä»¶ï¼ˆLinux/Macï¼‰æˆ– hosts æ–‡ä»¶ï¼ˆWindowsï¼‰
    const hostsFile = os.readHostsFile();
    return hostsFile[domain] || null;
  },
  
  // 3. é€’å½’DNSæŸ¥è¯¢
  recursiveQuery: async (domain) => {
    // æ ¹æœåŠ¡å™¨æŸ¥è¯¢
    const rootServers = ['198.41.0.4', '199.9.14.201']; // æ ¹æœåŠ¡å™¨IP
    
    // æŸ¥è¯¢é¡¶çº§åŸŸåæœåŠ¡å™¨
    const tldResult = await queryDNS(rootServers, domain);
    
    // æŸ¥è¯¢æƒå¨åŸŸåæœåŠ¡å™¨
    const authResult = await queryDNS(tldResult.nameservers, domain);
    
    return authResult.ip;
  },
  
  // DNSæŸ¥è¯¢ä¼˜åŒ–
  optimizations: {
    // DNSé¢„è§£æ
    prefetch: (domains) => {
      domains.forEach(domain => {
        // <link rel="dns-prefetch" href="//example.com">
        dnsResolver.resolve(domain);
      });
    },
    
    // DNSç¼“å­˜ç­–ç•¥
    cacheStrategy: {
      browserCache: '1åˆ†é’Ÿ',
      osCache: '5åˆ†é’Ÿ',
      routerCache: '30åˆ†é’Ÿ'
    }
  }
};
```

### 2.3 DNSä¼˜åŒ–æŠ€æœ¯

```html
<!-- DNSä¼˜åŒ–ç¤ºä¾‹ -->
<!DOCTYPE html>
<html>
<head>
  <!-- DNSé¢„è§£æ - æå‰è§£æç¬¬ä¸‰æ–¹åŸŸå -->
  <link rel="dns-prefetch" href="//fonts.googleapis.com">
  <link rel="dns-prefetch" href="//api.example.com">
  <link rel="dns-prefetch" href="//cdn.jsdelivr.net">
  
  <!-- é¢„è¿æ¥ - ä¸ä»…è§£æDNSï¼Œè¿˜å»ºç«‹TCPè¿æ¥ -->
  <link rel="preconnect" href="//fonts.gstatic.com" crossorigin>
</head>
</html>
```

---

## å»ºç«‹ç½‘ç»œè¿æ¥

### 3.1 TCPä¸‰æ¬¡æ¡æ‰‹

å»ºç«‹å¯é çš„TCPè¿æ¥éœ€è¦ä¸‰æ¬¡æ¡æ‰‹è¿‡ç¨‹ï¼š

```javascript
// TCPè¿æ¥å»ºç«‹è¿‡ç¨‹
const tcpConnection = {
  // ç¬¬ä¸€æ¬¡æ¡æ‰‹ï¼šå®¢æˆ·ç«¯å‘é€SYN
  step1: {
    from: 'å®¢æˆ·ç«¯',
    to: 'æœåŠ¡å™¨',
    packet: 'SYN',
    description: 'è¯·æ±‚å»ºç«‹è¿æ¥',
    sequenceNumber: 'x'
  },
  
  // ç¬¬äºŒæ¬¡æ¡æ‰‹ï¼šæœåŠ¡å™¨å›åº”SYN+ACK
  step2: {
    from: 'æœåŠ¡å™¨',
    to: 'å®¢æˆ·ç«¯',
    packet: 'SYN+ACK',
    description: 'ç¡®è®¤è¿æ¥è¯·æ±‚å¹¶è¯·æ±‚å®¢æˆ·ç«¯ç¡®è®¤',
    sequenceNumber: 'y',
    acknowledgmentNumber: 'x+1'
  },
  
  // ç¬¬ä¸‰æ¬¡æ¡æ‰‹ï¼šå®¢æˆ·ç«¯å‘é€ACK
  step3: {
    from: 'å®¢æˆ·ç«¯',
    to: 'æœåŠ¡å™¨',
    packet: 'ACK',
    description: 'ç¡®è®¤è¿æ¥å»ºç«‹',
    acknowledgmentNumber: 'y+1'
  }
};

// è¿æ¥çŠ¶æ€ç®¡ç†
const connectionState = {
  CLOSED: 'è¿æ¥å…³é—­',
  LISTEN: 'æœåŠ¡å™¨ç›‘å¬',
  SYN_SENT: 'å®¢æˆ·ç«¯å‘é€SYN',
  SYN_RCVD: 'æœåŠ¡å™¨æ¥æ”¶SYN',
  ESTABLISHED: 'è¿æ¥å»ºç«‹'
};
```

### 3.2 HTTPSçš„TLSæ¡æ‰‹

å¯¹äºHTTPSè¿æ¥ï¼Œè¿˜éœ€è¦è¿›è¡ŒTLSæ¡æ‰‹æ¥å»ºç«‹åŠ å¯†é€šé“ï¼š

```javascript
// TLSæ¡æ‰‹è¿‡ç¨‹
const tlsHandshake = {
  // 1. Client Hello
  clientHello: {
    tlsVersion: 'TLS 1.3',
    cipherSuites: [
      'TLS_AES_256_GCM_SHA384',
      'TLS_CHACHA20_POLY1305_SHA256',
      'TLS_AES_128_GCM_SHA256'
    ],
    randomBytes: 'client_random_32_bytes',
    sessionId: 'optional_session_id'
  },
  
  // 2. Server Hello + Certificate
  serverHello: {
    selectedCipher: 'TLS_AES_256_GCM_SHA384',
    certificate: {
      domain: 'www.example.com',
      issuer: 'Let\'s Encrypt Authority',
      publicKey: 'server_public_key',
      signature: 'ca_signature'
    },
    randomBytes: 'server_random_32_bytes'
  },
  
  // 3. è¯ä¹¦éªŒè¯
  certificateVerification: {
    checkDomain: (cert, hostname) => cert.domain === hostname,
    checkIssuer: (cert) => trustedCAs.includes(cert.issuer),
    checkExpiry: (cert) => new Date() < cert.expiryDate,
    checkRevocation: (cert) => !isRevoked(cert.serialNumber)
  },
  
  // 4. å¯†é’¥äº¤æ¢
  keyExchange: {
    preSharedKey: 'generated_from_random_values',
    masterSecret: 'derived_from_psk_and_handshake_messages',
    sessionKeys: {
      clientWriteKey: 'client_encryption_key',
      serverWriteKey: 'server_encryption_key',
      clientMac: 'client_mac_key',
      serverMac: 'server_mac_key'
    }
  }
};
```

### 3.3 è¿æ¥ä¼˜åŒ–ç­–ç•¥

```javascript
// è¿æ¥ä¼˜åŒ–æŠ€æœ¯
const connectionOptimizations = {
  // HTTP/2 è¿æ¥å¤ç”¨
  http2Multiplexing: {
    description: 'å•ä¸ªè¿æ¥æ”¯æŒå¤šä¸ªå¹¶è¡Œè¯·æ±‚',
    benefits: ['å‡å°‘è¿æ¥å¼€é”€', 'é¿å…é˜Ÿå¤´é˜»å¡', 'æœåŠ¡å™¨æ¨é€'],
    implementation: 'ALPNåå•†å‡çº§åˆ°HTTP/2'
  },
  
  // Keep-Alive è¿æ¥ä¿æŒ
  keepAlive: {
    headers: {
      'Connection': 'keep-alive',
      'Keep-Alive': 'timeout=5, max=1000'
    },
    benefits: 'é¿å…é‡å¤å»ºç«‹TCPè¿æ¥'
  },
  
  // è¿æ¥é¢„çƒ­
  preconnect: {
    html: '<link rel="preconnect" href="//api.example.com">',
    description: 'æå‰å»ºç«‹åˆ°å…³é”®åŸŸåçš„è¿æ¥'
  }
};
```

---

## HTTPè¯·æ±‚ä¸å“åº”

### 4.1 æ„é€ HTTPè¯·æ±‚

æµè§ˆå™¨æ ¹æ®è§£æçš„URLä¿¡æ¯æ„é€ HTTPè¯·æ±‚ï¼š

```http
GET /api/users?page=1&limit=10 HTTP/1.1
Host: api.example.com
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
Accept-Language: zh-CN,zh;q=0.9,en;q=0.8
Accept-Encoding: gzip, deflate, br
Connection: keep-alive
Cache-Control: no-cache
Pragma: no-cache
Upgrade-Insecure-Requests: 1
Sec-Fetch-Dest: document
Sec-Fetch-Mode: navigate
Sec-Fetch-Site: none
```

### 4.2 HTTPè¯·æ±‚å¤´è¯¦è§£

```javascript
// å…³é”®è¯·æ±‚å¤´è§£æ
const httpHeaders = {
  // å¿…éœ€å¤´éƒ¨
  required: {
    'Host': 'api.example.com',  // ç›®æ ‡ä¸»æœºï¼ŒHTTP/1.1å¿…éœ€
    'User-Agent': 'browser_identification_string'  // æµè§ˆå™¨æ ‡è¯†
  },
  
  // å†…å®¹åå•†
  contentNegotiation: {
    'Accept': 'text/html,application/xml;q=0.9,*/*;q=0.8',  // æ¥å—çš„å†…å®¹ç±»å‹
    'Accept-Language': 'zh-CN,zh;q=0.9,en;q=0.8',  // æ¥å—çš„è¯­è¨€
    'Accept-Encoding': 'gzip, deflate, br',  // æ¥å—çš„ç¼–ç æ–¹å¼
    'Accept-Charset': 'utf-8, iso-8859-1;q=0.8'  // æ¥å—çš„å­—ç¬¦é›†
  },
  
  // ç¼“å­˜æ§åˆ¶
  caching: {
    'Cache-Control': 'no-cache, max-age=0',  // ç¼“å­˜ç­–ç•¥
    'If-Modified-Since': 'Wed, 21 Oct 2023 07:28:00 GMT',  // æ¡ä»¶è¯·æ±‚
    'If-None-Match': '"686897696a7c876b7e"',  // ETagæ¡ä»¶è¯·æ±‚
    'Pragma': 'no-cache'  // HTTP/1.0å…¼å®¹
  },
  
  // å®‰å…¨ç›¸å…³
  security: {
    'Sec-Fetch-Dest': 'document',  // è¯·æ±‚ç›®æ ‡ç±»å‹
    'Sec-Fetch-Mode': 'navigate',  // è¯·æ±‚æ¨¡å¼
    'Sec-Fetch-Site': 'cross-site',  // è¯·æ±‚æ¥æº
    'Upgrade-Insecure-Requests': '1'  // å‡çº§åˆ°HTTPS
  }
};
```

### 4.3 æœåŠ¡å™¨å¤„ç†ä¸å“åº”

```javascript
// æœåŠ¡å™¨ç«¯å¤„ç†æµç¨‹
const serverProcessing = {
  // 1. è¯·æ±‚è§£æ
  parseRequest: (rawRequest) => {
    const lines = rawRequest.split('\r\n');
    const [method, path, version] = lines[0].split(' ');
    
    const headers = {};
    let bodyStart = 1;
    
    for (let i = 1; i < lines.length; i++) {
      if (lines[i] === '') {
        bodyStart = i + 1;
        break;
      }
      const [key, value] = lines[i].split(': ');
      headers[key.toLowerCase()] = value;
    }
    
    return { method, path, version, headers, body: lines.slice(bodyStart) };
  },
  
  // 2. è·¯ç”±åŒ¹é…
  routeMatching: (path) => {
    const routes = {
      '/': 'indexHandler',
      '/api/users': 'usersHandler',
      '/static/*': 'staticHandler'
    };
    
    return routes[path] || routes['/static/*'] || 'notFoundHandler';
  },
  
  // 3. ä¸­é—´ä»¶å¤„ç†
  middleware: [
    'authenticationMiddleware',
    'corsMiddleware', 
    'rateLimitMiddleware',
    'loggingMiddleware'
  ],
  
  // 4. ä¸šåŠ¡é€»è¾‘å¤„ç†
  businessLogic: async (request) => {
    // æ•°æ®åº“æŸ¥è¯¢ã€ä¸šåŠ¡è®¡ç®—ã€ç¬¬ä¸‰æ–¹APIè°ƒç”¨ç­‰
    const data = await database.query(request.params);
    return processBusinessRules(data);
  },
  
  // 5. å“åº”ç”Ÿæˆ
  generateResponse: (data) => {
    return {
      status: 200,
      headers: {
        'Content-Type': 'text/html; charset=utf-8',
        'Content-Length': data.length.toString(),
        'Cache-Control': 'public, max-age=3600',
        'Last-Modified': new Date().toUTCString(),
        'ETag': generateETag(data)
      },
      body: data
    };
  }
};
```

### 4.4 HTTPå“åº”è§£æ

```http
HTTP/1.1 200 OK
Date: Thu, 14 Dec 2023 12:00:00 GMT
Server: nginx/1.20.1
Content-Type: text/html; charset=utf-8
Content-Length: 15423
Content-Encoding: gzip
Cache-Control: public, max-age=3600
Last-Modified: Wed, 13 Dec 2023 10:30:00 GMT
ETag: "686897696a7c876b7e"
Vary: Accept-Encoding
X-Frame-Options: SAMEORIGIN
X-Content-Type-Options: nosniff
X-XSS-Protection: 1; mode=block

<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç¤ºä¾‹é¡µé¢</title>
    <link rel="stylesheet" href="/css/styles.css">
</head>
<body>
    <header>
        <h1>æ¬¢è¿è®¿é—®ç¤ºä¾‹ç½‘ç«™</h1>
    </header>
    <main>
        <p>è¿™æ˜¯é¡µé¢çš„ä¸»è¦å†…å®¹ã€‚</p>
    </main>
    <script src="/js/app.js"></script>
</body>
</html>
```

---

## èµ„æºè§£æå¤„ç†

### 5.1 å“åº”æ•°æ®å¤„ç†

```javascript
// å“åº”æ•°æ®å¤„ç†æµç¨‹
const responseProcessor = {
  // 1. çŠ¶æ€ç å¤„ç†
  handleStatusCode: (statusCode) => {
    const handlers = {
      200: 'processSuccess',
      301: 'handleRedirect',
      304: 'useCache',
      404: 'showNotFound',
      500: 'showServerError'
    };
    return handlers[statusCode] || 'handleUnknownStatus';
  },
  
  // 2. å†…å®¹è§£ç 
  decodeContent: (response) => {
    const encoding = response.headers['content-encoding'];
    
    switch (encoding) {
      case 'gzip':
        return gzip.decompress(response.body);
      case 'deflate':
        return deflate.decompress(response.body);
      case 'br':
        return brotli.decompress(response.body);
      default:
        return response.body;
    }
  },
  
  // 3. å­—ç¬¦é›†è½¬æ¢
  decodeCharset: (content, contentType) => {
    const charset = contentType.match(/charset=([^;]+)/)?.[1] || 'utf-8';
    
    if (charset.toLowerCase() !== 'utf-8') {
      return iconv.decode(content, charset);
    }
    return content;
  },
  
  // 4. MIMEç±»å‹å¤„ç†
  processMimeType: (contentType, content) => {
    const mimeHandlers = {
      'text/html': 'parseHTML',
      'text/css': 'parseCSS',
      'application/javascript': 'parseJavaScript',
      'application/json': 'parseJSON',
      'image/jpeg': 'decodeImage',
      'image/png': 'decodeImage'
    };
    
    const handler = mimeHandlers[contentType.split(';')[0]];
    return handler ? this[handler](content) : content;
  }
};
```

### 5.2 ç¼“å­˜æœºåˆ¶

```javascript
// æµè§ˆå™¨ç¼“å­˜ç­–ç•¥
const cacheStrategy = {
  // å¼ºç¼“å­˜æ£€æŸ¥
  checkStrongCache: (url) => {
    const cached = browser.cache.get(url);
    
    if (!cached) return null;
    
    // æ£€æŸ¥ Cache-Control
    const cacheControl = cached.headers['cache-control'];
    if (cacheControl) {
      const maxAge = cacheControl.match(/max-age=(\d+)/)?.[1];
      if (maxAge) {
        const age = (Date.now() - cached.timestamp) / 1000;
        if (age < parseInt(maxAge)) {
          return cached; // å‘½ä¸­å¼ºç¼“å­˜
        }
      }
    }
    
    // æ£€æŸ¥ Expires
    const expires = cached.headers['expires'];
    if (expires && new Date(expires) > new Date()) {
      return cached; // å‘½ä¸­å¼ºç¼“å­˜
    }
    
    return null;
  },
  
  // åå•†ç¼“å­˜
  negotiateCache: (url, cached) => {
    const headers = {};
    
    // Last-Modified åå•†
    if (cached.headers['last-modified']) {
      headers['If-Modified-Since'] = cached.headers['last-modified'];
    }
    
    // ETag åå•†
    if (cached.headers['etag']) {
      headers['If-None-Match'] = cached.headers['etag'];
    }
    
    return headers;
  },
  
  // ç¼“å­˜å­˜å‚¨ç­–ç•¥
  storageStrategy: {
    memory: {
      description: 'å†…å­˜ç¼“å­˜ï¼Œæœ€å¿«ä½†å®¹é‡æœ‰é™',
      size: '100MB',
      duration: 'ä¼šè¯æœŸé—´'
    },
    disk: {
      description: 'ç£ç›˜ç¼“å­˜ï¼Œå®¹é‡å¤§ä½†é€Ÿåº¦è¾ƒæ…¢',
      size: '1GB',
      duration: 'æŒä¹…åŒ–å­˜å‚¨'
    },
    serviceWorker: {
      description: 'Service Workerç¼“å­˜ï¼Œå¯ç¼–ç¨‹æ§åˆ¶',
      size: 'å¯é…ç½®',
      duration: 'å¯ç¼–ç¨‹æ§åˆ¶'
    }
  }
};
```

---

## DOMæ ‘æ„å»º

### 6.1 HTMLè¯æ³•åˆ†æ

```javascript
// HTML tokenizer - è¯æ³•åˆ†æå™¨
const htmlTokenizer = {
  // Tokenç±»å‹å®šä¹‰
  TokenType: {
    START_TAG: 'StartTag',      // <div>
    END_TAG: 'EndTag',          // </div>
    TEXT: 'Text',               // æ–‡æœ¬å†…å®¹
    COMMENT: 'Comment',         // <!-- æ³¨é‡Š -->
    DOCTYPE: 'DOCTYPE',         // <!DOCTYPE html>
    ATTRIBUTE: 'Attribute'      // class="container"
  },
  
  // åˆ†è¯è¿‡ç¨‹
  tokenize: (html) => {
    const tokens = [];
    let position = 0;
    
    while (position < html.length) {
      const char = html[position];
      
      if (char === '<') {
        // å¤„ç†æ ‡ç­¾
        if (html[position + 1] === '/') {
          tokens.push(this.parseEndTag(html, position));
        } else if (html.substr(position, 4) === '<!--') {
          tokens.push(this.parseComment(html, position));
        } else if (html.substr(position, 9) === '<!DOCTYPE') {
          tokens.push(this.parseDoctype(html, position));
        } else {
          tokens.push(this.parseStartTag(html, position));
        }
      } else {
        // å¤„ç†æ–‡æœ¬å†…å®¹
        tokens.push(this.parseText(html, position));
      }
    }
    
    return tokens;
  },
  
  // è§£æå¼€å§‹æ ‡ç­¾
  parseStartTag: (html, start) => {
    const match = html.substr(start).match(/^<(\w+)([^>]*)>/);
    if (!match) return null;
    
    const [fullMatch, tagName, attributesStr] = match;
    
    return {
      type: 'StartTag',
      tagName: tagName.toLowerCase(),
      attributes: this.parseAttributes(attributesStr),
      selfClosing: attributesStr.includes('/'),
      position: start,
      length: fullMatch.length
    };
  },
  
  // è§£æå±æ€§
  parseAttributes: (attributesStr) => {
    const attributes = {};
    const attrRegex = /(\w+)(?:\s*=\s*["']([^"']*)["'])?/g;
    let match;
    
    while ((match = attrRegex.exec(attributesStr)) !== null) {
      const [, name, value] = match;
      attributes[name.toLowerCase()] = value || '';
    }
    
    return attributes;
  }
};
```

### 6.2 DOMæ ‘æ„å»ºç®—æ³•

```javascript
// DOMæ ‘æ„å»ºå™¨
const domBuilder = {
  // æ„å»ºDOMæ ‘
  buildTree: (tokens) => {
    const root = {
      nodeType: 'Document',
      children: []
    };
    
    const stack = [root];
    
    for (const token of tokens) {
      switch (token.type) {
        case 'StartTag':
          this.handleStartTag(token, stack);
          break;
        case 'EndTag':
          this.handleEndTag(token, stack);
          break;
        case 'Text':
          this.handleText(token, stack);
          break;
        case 'Comment':
          this.handleComment(token, stack);
          break;
      }
    }
    
    return root;
  },
  
  // å¤„ç†å¼€å§‹æ ‡ç­¾
  handleStartTag: (token, stack) => {
    const element = {
      nodeType: 'Element',
      tagName: token.tagName,
      attributes: token.attributes,
      children: [],
      parent: stack[stack.length - 1]
    };
    
    // æ·»åŠ åˆ°çˆ¶å…ƒç´ 
    stack[stack.length - 1].children.push(element);
    
    // éè‡ªé—­åˆæ ‡ç­¾å…¥æ ˆ
    if (!token.selfClosing && !this.isVoidElement(token.tagName)) {
      stack.push(element);
    }
  },
  
  // å¤„ç†ç»“æŸæ ‡ç­¾
  handleEndTag: (token, stack) => {
    // æ‰¾åˆ°åŒ¹é…çš„å¼€å§‹æ ‡ç­¾å¹¶å‡ºæ ˆ
    for (let i = stack.length - 1; i >= 0; i--) {
      if (stack[i].tagName === token.tagName) {
        stack.splice(i);
        break;
      }
    }
  },
  
  // å¤„ç†æ–‡æœ¬èŠ‚ç‚¹
  handleText: (token, stack) => {
    const textNode = {
      nodeType: 'Text',
      textContent: token.content,
      parent: stack[stack.length - 1]
    };
    
    stack[stack.length - 1].children.push(textNode);
  },
  
  // ç©ºå…ƒç´ åˆ—è¡¨ï¼ˆè‡ªé—­åˆï¼‰
  voidElements: new Set([
    'area', 'base', 'br', 'col', 'embed', 'hr', 'img', 
    'input', 'keygen', 'link', 'meta', 'param', 'source', 
    'track', 'wbr'
  ]),
  
  isVoidElement: (tagName) => {
    return this.voidElements.has(tagName);
  }
};
```

### 6.3 ç‰¹æ®Šå…ƒç´ å¤„ç†

```javascript
// ç‰¹æ®Šå…ƒç´ å¤„ç†é€»è¾‘
const specialElementHandler = {
  // Scriptæ ‡ç­¾å¤„ç†
  handleScript: (element) => {
    if (element.tagName === 'script') {
      // æ£€æŸ¥æ˜¯å¦ä¸ºå¤–éƒ¨è„šæœ¬
      if (element.attributes.src) {
        // æš‚åœHTMLè§£æï¼ŒåŠ è½½å¤–éƒ¨è„šæœ¬
        this.pauseHTMLParsing();
        this.loadExternalScript(element.attributes.src)
          .then(() => {
            this.resumeHTMLParsing();
          });
      } else {
        // å†…è”è„šæœ¬ç«‹å³æ‰§è¡Œ
        this.executeInlineScript(element.textContent);
      }
    }
  },
  
  // Styleæ ‡ç­¾å¤„ç†
  handleStyle: (element) => {
    if (element.tagName === 'style') {
      // è§£æå†…è”CSS
      const cssRules = cssParser.parse(element.textContent);
      cssom.addRules(cssRules);
    }
  },
  
  // Linkæ ‡ç­¾å¤„ç†
  handleLink: (element) => {
    if (element.tagName === 'link') {
      const rel = element.attributes.rel;
      
      switch (rel) {
        case 'stylesheet':
          // åŠ è½½å¤–éƒ¨CSS
          this.loadExternalStylesheet(element.attributes.href);
          break;
        case 'dns-prefetch':
          // DNSé¢„è§£æ
          this.prefetchDNS(element.attributes.href);
          break;
        case 'preload':
          // èµ„æºé¢„åŠ è½½
          this.preloadResource(element.attributes.href, element.attributes.as);
          break;
      }
    }
  },
  
  // Metaæ ‡ç­¾å¤„ç†
  handleMeta: (element) => {
    if (element.tagName === 'meta') {
      const name = element.attributes.name;
      const content = element.attributes.content;
      
      if (name === 'viewport') {
        // è®¾ç½®è§†å£
        this.setViewport(content);
      } else if (element.attributes.charset) {
        // è®¾ç½®å­—ç¬¦ç¼–ç 
        this.setCharset(element.attributes.charset);
      }
    }
  }
};
```

---

## CSSè§£æä¸CSSOM

### 7.1 CSSè¯æ³•åˆ†æ

```javascript
// CSS tokenizer
const cssTokenizer = {
  // CSS Tokenç±»å‹
  TokenType: {
    SELECTOR: 'Selector',
    PROPERTY: 'Property',
    VALUE: 'Value',
    AT_RULE: 'AtRule',
    COMMENT: 'Comment'
  },
  
  // CSSåˆ†è¯
  tokenize: (css) => {
    const tokens = [];
    let position = 0;
    
    // å»é™¤æ³¨é‡Š
    css = this.removeComments(css);
    
    while (position < css.length) {
      const char = css[position];
      
      if (char === '@') {
        // å¤„ç†@è§„åˆ™
        tokens.push(this.parseAtRule(css, position));
      } else if (char === '{') {
        // å¼€å§‹å±æ€§å—
        tokens.push({ type: 'BlockStart', position });
      } else if (char === '}') {
        // ç»“æŸå±æ€§å—
        tokens.push({ type: 'BlockEnd', position });
      } else if (!this.isWhitespace(char)) {
        // è§£æé€‰æ‹©å™¨æˆ–å±æ€§
        tokens.push(this.parseSelector(css, position));
      }
      
      position++;
    }
    
    return tokens;
  },
  
  // è§£æé€‰æ‹©å™¨
  parseSelector: (css, start) => {
    const match = css.substr(start).match(/^([^{]+)/);
    if (!match) return null;
    
    return {
      type: 'Selector',
      value: match[1].trim(),
      position: start,
      length: match[1].length
    };
  },
  
  // å»é™¤æ³¨é‡Š
  removeComments: (css) => {
    return css.replace(/\/\*[\s\S]*?\*\//g, '');
  }
};
```

### 7.2 CSSOMæ„å»º

```javascript
// CSSOMæ„å»ºå™¨
const cssomBuilder = {
  // æ„å»ºCSSOMæ ‘
  buildCSSOM: (cssText) => {
    const rules = this.parseRules(cssText);
    
    const cssom = {
      rules: [],
      styleSheets: []
    };
    
    rules.forEach(rule => {
      if (rule.type === 'style') {
        cssom.rules.push(this.createStyleRule(rule));
      } else if (rule.type === 'media') {
        cssom.rules.push(this.createMediaRule(rule));
      } else if (rule.type === 'keyframes') {
        cssom.rules.push(this.createKeyframesRule(rule));
      }
    });
    
    return cssom;
  },
  
  // åˆ›å»ºæ ·å¼è§„åˆ™
  createStyleRule: (rule) => {
    return {
      type: 'CSSStyleRule',
      selectorText: rule.selector,
      style: this.parseDeclarations(rule.declarations),
      specificity: this.calculateSpecificity(rule.selector)
    };
  },
  
  // è§£æCSSå£°æ˜
  parseDeclarations: (declarationsText) => {
    const declarations = {};
    const declRegex = /([^:]+):\s*([^;]+)/g;
    let match;
    
    while ((match = declRegex.exec(declarationsText)) !== null) {
      const [, property, value] = match;
      declarations[property.trim()] = value.trim();
    }
    
    return declarations;
  },
  
  // è®¡ç®—é€‰æ‹©å™¨ç‰¹å¼‚æ€§
  calculateSpecificity: (selector) => {
    let a = 0; // å†…è”æ ·å¼
    let b = 0; // IDé€‰æ‹©å™¨
    let c = 0; // ç±»é€‰æ‹©å™¨ã€å±æ€§é€‰æ‹©å™¨ã€ä¼ªç±»
    let d = 0; // å…ƒç´ é€‰æ‹©å™¨ã€ä¼ªå…ƒç´ 
    
    // IDé€‰æ‹©å™¨
    const ids = selector.match(/#[\w-]+/g);
    if (ids) b += ids.length;
    
    // ç±»é€‰æ‹©å™¨
    const classes = selector.match(/\.[\w-]+/g);
    if (classes) c += classes.length;
    
    // å±æ€§é€‰æ‹©å™¨
    const attributes = selector.match(/\[[^\]]+\]/g);
    if (attributes) c += attributes.length;
    
    // ä¼ªç±»
    const pseudoClasses = selector.match(/:[\w-]+(?:\([^)]*\))?/g);
    if (pseudoClasses) c += pseudoClasses.length;
    
    // å…ƒç´ é€‰æ‹©å™¨
    const elements = selector.match(/\b[a-z][\w-]*/g);
    if (elements) d += elements.length;
    
    return { a, b, c, d, value: a * 1000 + b * 100 + c * 10 + d };
  }
};
```

### 7.3 æ ·å¼è®¡ç®—

```javascript
// æ ·å¼è®¡ç®—å¼•æ“
const styleEngine = {
  // è®¡ç®—å…ƒç´ çš„æœ€ç»ˆæ ·å¼
  computeStyles: (element, cssom) => {
    const matchedRules = this.matchRules(element, cssom.rules);
    const computedStyle = this.cascadeAndInherit(element, matchedRules);
    
    return computedStyle;
  },
  
  // åŒ¹é…CSSè§„åˆ™
  matchRules: (element, rules) => {
    const matched = [];
    
    rules.forEach(rule => {
      if (this.selectorMatches(element, rule.selectorText)) {
        matched.push({
          rule: rule,
          specificity: rule.specificity
        });
      }
    });
    
    // æŒ‰ç‰¹å¼‚æ€§æ’åº
    matched.sort((a, b) => b.specificity.value - a.specificity.value);
    
    return matched;
  },
  
  // é€‰æ‹©å™¨åŒ¹é…
  selectorMatches: (element, selector) => {
    // ç®€åŒ–çš„é€‰æ‹©å™¨åŒ¹é…ç®—æ³•
    if (selector.startsWith('#')) {
      // IDé€‰æ‹©å™¨
      return element.attributes.id === selector.slice(1);
    } else if (selector.startsWith('.')) {
      // ç±»é€‰æ‹©å™¨
      const className = selector.slice(1);
      const elementClasses = (element.attributes.class || '').split(' ');
      return elementClasses.includes(className);
    } else {
      // æ ‡ç­¾é€‰æ‹©å™¨
      return element.tagName === selector;
    }
  },
  
  // å±‚å å’Œç»§æ‰¿
  cascadeAndInherit: (element, matchedRules) => {
    const computedStyle = {};
    
    // 1. æµè§ˆå™¨é»˜è®¤æ ·å¼
    Object.assign(computedStyle, this.getDefaultStyles(element.tagName));
    
    // 2. ç»§æ‰¿çš„æ ·å¼
    if (element.parent) {
      Object.assign(computedStyle, this.getInheritedStyles(element.parent.computedStyle));
    }
    
    // 3. åº”ç”¨åŒ¹é…çš„CSSè§„åˆ™
    matchedRules.forEach(({ rule }) => {
      Object.assign(computedStyle, rule.style);
    });
    
    // 4. å†…è”æ ·å¼ï¼ˆæœ€é«˜ä¼˜å…ˆçº§ï¼‰
    if (element.attributes.style) {
      const inlineStyles = this.parseInlineStyles(element.attributes.style);
      Object.assign(computedStyle, inlineStyles);
    }
    
    return computedStyle;
  },
  
  // å¯ç»§æ‰¿çš„CSSå±æ€§
  inheritableProperties: new Set([
    'color', 'font-family', 'font-size', 'font-weight', 'line-height',
    'text-align', 'text-indent', 'letter-spacing', 'word-spacing',
    'white-space', 'direction', 'visibility'
  ]),
  
  // è·å–ç»§æ‰¿çš„æ ·å¼
  getInheritedStyles: (parentStyle) => {
    const inherited = {};
    
    for (const [property, value] of Object.entries(parentStyle)) {
      if (this.inheritableProperties.has(property)) {
        inherited[property] = value;
      }
    }
    
    return inherited;
  }
};
```

---

## å¸ƒå±€è®¡ç®—Layout

### 8.1 å¸ƒå±€æ ‘æ„å»º

```javascript
// å¸ƒå±€æ ‘æ„å»ºå™¨
const layoutTreeBuilder = {
  // æ„å»ºå¸ƒå±€æ ‘
  buildLayoutTree: (domTree, cssom) => {
    const layoutTree = [];
    
    this.traverseDOM(domTree, (element) => {
      const computedStyle = styleEngine.computeStyles(element, cssom);
      element.computedStyle = computedStyle;
      
      // è·³è¿‡ä¸æ¸²æŸ“çš„å…ƒç´ 
      if (computedStyle.display === 'none') {
        return;
      }
      
      const layoutObject = this.createLayoutObject(element, computedStyle);
      layoutTree.push(layoutObject);
    });
    
    return layoutTree;
  },
  
  // åˆ›å»ºå¸ƒå±€å¯¹è±¡
  createLayoutObject: (element, computedStyle) => {
    return {
      element: element,
      style: computedStyle,
      geometry: {
        x: 0,
        y: 0,
        width: 0,
        height: 0,
        marginTop: 0,
        marginRight: 0,
        marginBottom: 0,
        marginLeft: 0,
        paddingTop: 0,
        paddingRight: 0,
        paddingBottom: 0,
        paddingLeft: 0,
        borderTopWidth: 0,
        borderRightWidth: 0,
        borderBottomWidth: 0,
        borderLeftWidth: 0
      },
      children: []
    };
  },
  
  // éå†DOMæ ‘
  traverseDOM: (node, callback) => {
    if (node.nodeType === 'Element') {
      callback(node);
    }
    
    if (node.children) {
      node.children.forEach(child => {
        this.traverseDOM(child, callback);
      });
    }
  }
};
```

### 8.2 å¸ƒå±€è®¡ç®—ç®—æ³•

```javascript
// å¸ƒå±€è®¡ç®—å¼•æ“
const layoutEngine = {
  // æ‰§è¡Œå¸ƒå±€è®¡ç®—
  calculateLayout: (layoutTree, viewport) => {
    // å»ºç«‹åŒ…å«å—é“¾
    this.establishContainingBlocks(layoutTree);
    
    // è®¡ç®—æ¯ä¸ªå…ƒç´ çš„å‡ ä½•ä¿¡æ¯
    layoutTree.forEach(layoutObject => {
      this.calculateGeometry(layoutObject, viewport);
    });
  },
  
  // è®¡ç®—å…ƒç´ å‡ ä½•ä¿¡æ¯
  calculateGeometry: (layoutObject, containingBlock) => {
    const style = layoutObject.style;
    const geometry = layoutObject.geometry;
    
    // 1. è®¡ç®—ç›’æ¨¡å‹å°ºå¯¸
    this.calculateBoxModel(layoutObject, containingBlock);
    
    // 2. æ ¹æ®displayç±»å‹è®¡ç®—å¸ƒå±€
    switch (style.display) {
      case 'block':
        this.calculateBlockLayout(layoutObject, containingBlock);
        break;
      case 'inline':
        this.calculateInlineLayout(layoutObject, containingBlock);
        break;
      case 'flex':
        this.calculateFlexLayout(layoutObject, containingBlock);
        break;
      case 'grid':
        this.calculateGridLayout(layoutObject, containingBlock);
        break;
    }
  },
  
  // è®¡ç®—ç›’æ¨¡å‹
  calculateBoxModel: (layoutObject, containingBlock) => {
    const style = layoutObject.style;
    const geometry = layoutObject.geometry;
    
    // è§£æè¾¹è·
    geometry.marginTop = this.parseLength(style.marginTop, containingBlock.height);
    geometry.marginRight = this.parseLength(style.marginRight, containingBlock.width);
    geometry.marginBottom = this.parseLength(style.marginBottom, containingBlock.height);
    geometry.marginLeft = this.parseLength(style.marginLeft, containingBlock.width);
    
    // è§£æå†…è¾¹è·
    geometry.paddingTop = this.parseLength(style.paddingTop, containingBlock.height);
    geometry.paddingRight = this.parseLength(style.paddingRight, containingBlock.width);
    geometry.paddingBottom = this.parseLength(style.paddingBottom, containingBlock.height);
    geometry.paddingLeft = this.parseLength(style.paddingLeft, containingBlock.width);
    
    // è§£æè¾¹æ¡†
    geometry.borderTopWidth = this.parseLength(style.borderTopWidth, 0);
    geometry.borderRightWidth = this.parseLength(style.borderRightWidth, 0);
    geometry.borderBottomWidth = this.parseLength(style.borderBottomWidth, 0);
    geometry.borderLeftWidth = this.parseLength(style.borderLeftWidth, 0);
  },
  
  // å—çº§å¸ƒå±€
  calculateBlockLayout: (layoutObject, containingBlock) => {
    const style = layoutObject.style;
    const geometry = layoutObject.geometry;
    
    // å®½åº¦è®¡ç®—
    if (style.width === 'auto') {
      geometry.width = containingBlock.width - 
        geometry.marginLeft - geometry.marginRight -
        geometry.paddingLeft - geometry.paddingRight -
        geometry.borderLeftWidth - geometry.borderRightWidth;
    } else {
      geometry.width = this.parseLength(style.width, containingBlock.width);
    }
    
    // é«˜åº¦è®¡ç®—
    if (style.height === 'auto') {
      geometry.height = this.calculateContentHeight(layoutObject);
    } else {
      geometry.height = this.parseLength(style.height, containingBlock.height);
    }
    
    // ä½ç½®è®¡ç®—
    geometry.x = containingBlock.x + geometry.marginLeft;
    geometry.y = this.calculateVerticalPosition(layoutObject, containingBlock);
  },
  
  // Flexboxå¸ƒå±€
  calculateFlexLayout: (layoutObject, containingBlock) => {
    const style = layoutObject.style;
    const children = layoutObject.children;
    
    // ç¡®å®šä¸»è½´å’Œäº¤å‰è½´
    const isRowDirection = style.flexDirection === 'row' || style.flexDirection === 'row-reverse';
    const mainAxis = isRowDirection ? 'width' : 'height';
    const crossAxis = isRowDirection ? 'height' : 'width';
    
    // è®¡ç®—ä¸»è½´å¯ç”¨ç©ºé—´
    const mainAxisSize = isRowDirection ? containingBlock.width : containingBlock.height;
    let usedMainAxisSpace = 0;
    
    // ç¬¬ä¸€è½®ï¼šè®¡ç®—å›ºå®šå°ºå¯¸çš„é¡¹ç›®
    children.forEach(child => {
      if (child.style[mainAxis] !== 'auto') {
        child.geometry[mainAxis] = this.parseLength(child.style[mainAxis], mainAxisSize);
        usedMainAxisSpace += child.geometry[mainAxis];
      }
    });
    
    // ç¬¬äºŒè½®ï¼šåˆ†é…å‰©ä½™ç©ºé—´ç»™flexé¡¹ç›®
    const remainingSpace = mainAxisSize - usedMainAxisSpace;
    const flexGrowSum = children.reduce((sum, child) => sum + (parseFloat(child.style.flexGrow) || 0), 0);
    
    if (flexGrowSum > 0) {
      children.forEach(child => {
        const flexGrow = parseFloat(child.style.flexGrow) || 0;
        if (flexGrow > 0) {
          child.geometry[mainAxis] += (remainingSpace * flexGrow) / flexGrowSum;
        }
      });
    }
    
    // ç¬¬ä¸‰è½®ï¼šå®šä½flexé¡¹ç›®
    let currentPosition = 0;
    children.forEach(child => {
      if (isRowDirection) {
        child.geometry.x = containingBlock.x + currentPosition;
        child.geometry.y = containingBlock.y;
        currentPosition += child.geometry.width;
      } else {
        child.geometry.x = containingBlock.x;
        child.geometry.y = containingBlock.y + currentPosition;
        currentPosition += child.geometry.height;
      }
    });
  },
  
  // è§£æé•¿åº¦å€¼
  parseLength: (value, referenceValue) => {
    if (typeof value === 'number') return value;
    if (typeof value !== 'string') return 0;
    
    if (value.endsWith('px')) {
      return parseFloat(value);
    } else if (value.endsWith('%')) {
      return (parseFloat(value) / 100) * referenceValue;
    } else if (value.endsWith('em')) {
      return parseFloat(value) * 16; // ç®€åŒ–å¤„ç†ï¼Œå‡è®¾1em=16px
    } else if (value.endsWith('rem')) {
      return parseFloat(value) * 16; // ç®€åŒ–å¤„ç†ï¼Œå‡è®¾1rem=16px
    } else if (value === 'auto') {
      return 'auto';
    }
    
    return 0;
  }
};
```

### 8.3 å¸ƒå±€ä¼˜åŒ–

```javascript
// å¸ƒå±€ä¼˜åŒ–ç­–ç•¥
const layoutOptimizations = {
  // å¢é‡å¸ƒå±€
  incrementalLayout: {
    description: 'åªé‡æ–°è®¡ç®—å—å½±å“çš„å…ƒç´ ',
    implementation: (changedElements) => {
      const affectedElements = this.findAffectedElements(changedElements);
      affectedElements.forEach(element => {
        layoutEngine.calculateGeometry(element);
      });
    }
  },
  
  // å¸ƒå±€ç¼“å­˜
  layoutCache: {
    cache: new Map(),
    
    get: (element, containingBlock) => {
      const key = this.generateCacheKey(element, containingBlock);
      return this.cache.get(key);
    },
    
    set: (element, containingBlock, geometry) => {
      const key = this.generateCacheKey(element, containingBlock);
      this.cache.set(key, geometry);
    },
    
    generateCacheKey: (element, containingBlock) => {
      return `${element.id}_${containingBlock.width}_${containingBlock.height}`;
    }
  },
  
  // å»¶è¿Ÿå¸ƒå±€
  deferredLayout: {
    scheduledElements: new Set(),
    
    schedule: (element) => {
      this.scheduledElements.add(element);
      requestAnimationFrame(() => {
        this.flush();
      });
    },
    
    flush: () => {
      this.scheduledElements.forEach(element => {
        layoutEngine.calculateGeometry(element);
      });
      this.scheduledElements.clear();
    }
  }
};
```

---

## ç»˜åˆ¶é˜¶æ®µPaint

### 9.1 ç»˜åˆ¶åˆ—è¡¨ç”Ÿæˆ

```javascript
// ç»˜åˆ¶åˆ—è¡¨ç”Ÿæˆå™¨
const paintListGenerator = {
  // ç”Ÿæˆç»˜åˆ¶æŒ‡ä»¤åˆ—è¡¨
  generatePaintList: (layoutTree) => {
    const paintList = [];
    
    // æŒ‰ç…§ç»˜åˆ¶é¡ºåºéå†å…ƒç´ 
    this.traverseInPaintOrder(layoutTree, (layoutObject) => {
      const instructions = this.generatePaintInstructions(layoutObject);
      paintList.push(...instructions);
    });
    
    return paintList;
  },
  
  // æŒ‰ç»˜åˆ¶é¡ºåºéå†
  traverseInPaintOrder: (layoutTree, callback) => {
    // æ ¹æ®z-indexå’Œæ–‡æ¡£é¡ºåºæ’åº
    const sortedElements = this.sortByPaintOrder(layoutTree);
    
    sortedElements.forEach(element => {
      callback(element);
    });
  },
  
  // ç”Ÿæˆå•ä¸ªå…ƒç´ çš„ç»˜åˆ¶æŒ‡ä»¤
  generatePaintInstructions: (layoutObject) => {
    const instructions = [];
    const style = layoutObject.style;
    const geometry = layoutObject.geometry;
    
    // 1. ç»˜åˆ¶èƒŒæ™¯
    if (style.backgroundColor && style.backgroundColor !== 'transparent') {
      instructions.push({
        type: 'fillRect',
        x: geometry.x,
        y: geometry.y,
        width: geometry.width,
        height: geometry.height,
        color: style.backgroundColor
      });
    }
    
    // 2. ç»˜åˆ¶èƒŒæ™¯å›¾ç‰‡
    if (style.backgroundImage && style.backgroundImage !== 'none') {
      instructions.push({
        type: 'drawImage',
        src: this.extractImageUrl(style.backgroundImage),
        x: geometry.x,
        y: geometry.y,
        width: geometry.width,
        height: geometry.height,
        repeat: style.backgroundRepeat,
        position: style.backgroundPosition
      });
    }
    
    // 3. ç»˜åˆ¶è¾¹æ¡†
    if (this.hasBorder(style)) {
      instructions.push(...this.generateBorderInstructions(geometry, style));
    }
    
    // 4. ç»˜åˆ¶æ–‡æœ¬å†…å®¹
    if (layoutObject.element.nodeType === 'Text') {
      instructions.push({
        type: 'fillText',
        text: layoutObject.element.textContent,
        x: geometry.x,
        y: geometry.y + geometry.height, // åŸºçº¿ä½ç½®
        font: this.buildFontString(style),
        color: style.color
      });
    }
    
    // 5. ç»˜åˆ¶è½®å»“
    if (style.outline && style.outline !== 'none') {
      instructions.push(...this.generateOutlineInstructions(geometry, style));
    }
    
    return instructions;
  },
  
  // ç”Ÿæˆè¾¹æ¡†ç»˜åˆ¶æŒ‡ä»¤
  generateBorderInstructions: (geometry, style) => {
    const instructions = [];
    
    // ä¸Šè¾¹æ¡†
    if (geometry.borderTopWidth > 0) {
      instructions.push({
        type: 'fillRect',
        x: geometry.x,
        y: geometry.y,
        width: geometry.width,
        height: geometry.borderTopWidth,
        color: style.borderTopColor
      });
    }
    
    // å³è¾¹æ¡†
    if (geometry.borderRightWidth > 0) {
      instructions.push({
        type: 'fillRect',
        x: geometry.x + geometry.width - geometry.borderRightWidth,
        y: geometry.y,
        width: geometry.borderRightWidth,
        height: geometry.height,
        color: style.borderRightColor
      });
    }
    
    // ä¸‹è¾¹æ¡†
    if (geometry.borderBottomWidth > 0) {
      instructions.push({
        type: 'fillRect',
        x: geometry.x,
        y: geometry.y + geometry.height - geometry.borderBottomWidth,
        width: geometry.width,
        height: geometry.borderBottomWidth,
        color: style.borderBottomColor
      });
    }
    
    // å·¦è¾¹æ¡†
    if (geometry.borderLeftWidth > 0) {
      instructions.push({
        type: 'fillRect',
        x: geometry.x,
        y: geometry.y,
        width: geometry.borderLeftWidth,
        height: geometry.height,
        color: style.borderLeftColor
      });
    }
    
    return instructions;
  },
  
  // æŒ‰ç»˜åˆ¶é¡ºåºæ’åº
  sortByPaintOrder: (elements) => {
    return elements.sort((a, b) => {
      // 1. æ¯”è¾ƒz-index
      const aZIndex = parseInt(a.style.zIndex) || 0;
      const bZIndex = parseInt(b.style.zIndex) || 0;
      
      if (aZIndex !== bZIndex) {
        return aZIndex - bZIndex;
      }
      
      // 2. æ¯”è¾ƒæ–‡æ¡£é¡ºåº
      return a.documentOrder - b.documentOrder;
    });
  }
};
```

### 9.2 æ …æ ¼åŒ–å¤„ç†

```javascript
// æ …æ ¼åŒ–å¼•æ“
const rasterizer = {
  // æ …æ ¼åŒ–ç»˜åˆ¶æŒ‡ä»¤
  rasterize: (paintList, viewport) => {
    // åˆ›å»ºç”»å¸ƒ
    const canvas = this.createCanvas(viewport.width, viewport.height);
    const context = canvas.getContext('2d');
    
    // æ‰§è¡Œç»˜åˆ¶æŒ‡ä»¤
    paintList.forEach(instruction => {
      this.executeInstruction(context, instruction);
    });
    
    return canvas;
  },
  
  // æ‰§è¡Œå•ä¸ªç»˜åˆ¶æŒ‡ä»¤
  executeInstruction: (context, instruction) => {
    switch (instruction.type) {
      case 'fillRect':
        this.drawFillRect(context, instruction);
        break;
      case 'drawImage':
        this.drawImage(context, instruction);
        break;
      case 'fillText':
        this.drawText(context, instruction);
        break;
      case 'strokeRect':
        this.drawStrokeRect(context, instruction);
        break;
    }
  },
  
  // ç»˜åˆ¶å¡«å……çŸ©å½¢
  drawFillRect: (context, instruction) => {
    context.fillStyle = instruction.color;
    context.fillRect(
      instruction.x,
      instruction.y,
      instruction.width,
      instruction.height
    );
  },
  
  // ç»˜åˆ¶å›¾ç‰‡
  drawImage: (context, instruction) => {
    const image = this.loadImage(instruction.src);
    
    if (image.complete) {
      context.drawImage(
        image,
        instruction.x,
        instruction.y,
        instruction.width,
        instruction.height
      );
    } else {
      // å›¾ç‰‡æœªåŠ è½½å®Œæˆï¼ŒåŠ è½½å®Œæˆåé‡æ–°ç»˜åˆ¶
      image.onload = () => {
        this.scheduleRepaint();
      };
    }
  },
  
  // ç»˜åˆ¶æ–‡æœ¬
  drawText: (context, instruction) => {
    context.font = instruction.font;
    context.fillStyle = instruction.color;
    context.fillText(
      instruction.text,
      instruction.x,
      instruction.y
    );
  },
  
  // åˆ†å—æ …æ ¼åŒ–ä¼˜åŒ–
  tileBasedRasterization: {
    tileSize: 256,
    
    rasterizeTiles: (paintList, viewport) => {
      const tiles = this.divideTiles(viewport);
      const rasterizedTiles = [];
      
      tiles.forEach(tile => {
        const tilePaintList = this.filterPaintListForTile(paintList, tile);
        const rasterizedTile = rasterizer.rasterize(tilePaintList, tile);
        rasterizedTiles.push({
          tile: tile,
          canvas: rasterizedTile
        });
      });
      
      return rasterizedTiles;
    },
    
    divideTiles: (viewport) => {
      const tiles = [];
      const { width, height } = viewport;
      
      for (let y = 0; y < height; y += this.tileSize) {
        for (let x = 0; x < width; x += this.tileSize) {
          tiles.push({
            x: x,
            y: y,
            width: Math.min(this.tileSize, width - x),
            height: Math.min(this.tileSize, height - y)
          });
        }
      }
      
      return tiles;
    }
  }
};
```

### 9.3 ç»˜åˆ¶ä¼˜åŒ–

```javascript
// ç»˜åˆ¶ä¼˜åŒ–ç­–ç•¥
const paintOptimizations = {
  // è„çŸ©å½¢æ£€æµ‹
  dirtyRectTracking: {
    dirtyRects: [],
    
    addDirtyRect: (rect) => {
      this.dirtyRects.push(rect);
    },
    
    getDirtyRegion: () => {
      if (this.dirtyRects.length === 0) return null;
      
      // åˆå¹¶è„çŸ©å½¢
      let minX = Infinity, minY = Infinity;
      let maxX = -Infinity, maxY = -Infinity;
      
      this.dirtyRects.forEach(rect => {
        minX = Math.min(minX, rect.x);
        minY = Math.min(minY, rect.y);
        maxX = Math.max(maxX, rect.x + rect.width);
        maxY = Math.max(maxY, rect.y + rect.height);
      });
      
      return {
        x: minX,
        y: minY,
        width: maxX - minX,
        height: maxY - minY
      };
    },
    
    clearDirtyRects: () => {
      this.dirtyRects = [];
    }
  },
  
  // ç»˜åˆ¶è°ƒç”¨åˆå¹¶
  drawCallBatching: {
    batchedCalls: [],
    
    addDrawCall: (call) => {
      this.batchedCalls.push(call);
    },
    
    flush: (context) => {
      // æŒ‰ç±»å‹åˆ†ç»„ç»˜åˆ¶è°ƒç”¨
      const groupedCalls = this.groupByType(this.batchedCalls);
      
      // æ‰¹é‡æ‰§è¡Œç›¸åŒç±»å‹çš„ç»˜åˆ¶
      Object.entries(groupedCalls).forEach(([type, calls]) => {
        this.executeBatch(context, type, calls);
      });
      
      this.batchedCalls = [];
    }
  },
  
  // ç¦»å±æ¸²æŸ“
  offscreenRendering: {
    cache: new Map(),
    
    renderToOffscreen: (element) => {
      const cacheKey = this.generateCacheKey(element);
      
      if (this.cache.has(cacheKey)) {
        return this.cache.get(cacheKey);
      }
      
      const offscreenCanvas = this.createOffscreenCanvas(
        element.geometry.width,
        element.geometry.height
      );
      
      const context = offscreenCanvas.getContext('2d');
      this.renderElement(context, element);
      
      this.cache.set(cacheKey, offscreenCanvas);
      return offscreenCanvas;
    }
  }
};
```

---

## åˆæˆé˜¶æ®µComposite

### 10.1 å›¾å±‚åˆ›å»º

```javascript
// åˆæˆå±‚ç®¡ç†å™¨
const compositeLayerManager = {
  // åˆ›å»ºåˆæˆå±‚
  createLayers: (layoutTree) => {
    const layers = [];
    
    layoutTree.forEach(layoutObject => {
      if (this.needsCompositeLayer(layoutObject)) {
        const layer = this.createCompositeLayer(layoutObject);
        layers.push(layer);
      }
    });
    
    return layers;
  },
  
  // åˆ¤æ–­æ˜¯å¦éœ€è¦åˆ›å»ºåˆæˆå±‚
  needsCompositeLayer: (layoutObject) => {
    const style = layoutObject.style;
    
    // æ ¹å…ƒç´ 
    if (layoutObject.isRoot) return true;
    
    // 3D transform
    if (this.has3DTransform(style)) return true;
    
    // opacity
    if (style.opacity && parseFloat(style.opacity) < 1) return true;
    
    // position: fixed
    if (style.position === 'fixed') return true;
    
    // transform
    if (style.transform && style.transform !== 'none') return true;
    
    // filter
    if (style.filter && style.filter !== 'none') return true;
    
    // will-change
    if (style.willChange && style.willChange !== 'auto') return true;
    
    // video å…ƒç´ 
    if (layoutObject.element.tagName === 'video') return true;
    
    // canvas å…ƒç´ 
    if (layoutObject.element.tagName === 'canvas') return true;
    
    // è¦†ç›–å…¶ä»–åˆæˆå±‚çš„å…ƒç´ 
    if (this.overlapsCompositeLayer(layoutObject)) return true;
    
    return false;
  },
  
  // åˆ›å»ºåˆæˆå±‚å¯¹è±¡
  createCompositeLayer: (layoutObject) => {
    return {
      id: this.generateLayerId(),
      element: layoutObject.element,
      geometry: layoutObject.geometry,
      style: layoutObject.style,
      paintedContent: null,
      transform: this.parseTransform(layoutObject.style.transform),
      opacity: parseFloat(layoutObject.style.opacity) || 1,
      blendMode: layoutObject.style.mixBlendMode || 'normal',
      filters: this.parseFilters(layoutObject.style.filter)
    };
  },
  
  // è§£ætransformå±æ€§
  parseTransform: (transformString) => {
    if (!transformString || transformString === 'none') {
      return { matrix: [1, 0, 0, 1, 0, 0] }; // å•ä½çŸ©é˜µ
    }
    
    // ç®€åŒ–çš„transformè§£æ
    const transforms = {
      translateX: 0,
      translateY: 0,
      translateZ: 0,
      scaleX: 1,
      scaleY: 1,
      scaleZ: 1,
      rotateX: 0,
      rotateY: 0,
      rotateZ: 0
    };
    
    // è§£ætranslate
    const translateMatch = transformString.match(/translate\(([^)]+)\)/);
    if (translateMatch) {
      const values = translateMatch[1].split(',').map(v => parseFloat(v.trim()));
      transforms.translateX = values[0] || 0;
      transforms.translateY = values[1] || 0;
    }
    
    // è§£æscale
    const scaleMatch = transformString.match(/scale\(([^)]+)\)/);
    if (scaleMatch) {
      const values = scaleMatch[1].split(',').map(v => parseFloat(v.trim()));
      transforms.scaleX = values[0] || 1;
      transforms.scaleY = values[1] || transforms.scaleX;
    }
    
    // è§£ærotate
    const rotateMatch = transformString.match(/rotate\(([^)]+)\)/);
    if (rotateMatch) {
      transforms.rotateZ = parseFloat(rotateMatch[1]);
    }
    
    return transforms;
  },
  
  // æ£€æµ‹3D transform
  has3DTransform: (style) => {
    const transform = style.transform;
    if (!transform) return false;
    
    return /translate3d|translateZ|rotateX|rotateY|perspective|transform-style:\s*preserve-3d/.test(transform);
  }
};
```

### 10.2 å±‚åˆæˆå¤„ç†

```javascript
// åˆæˆå¤„ç†å™¨
const compositor = {
  // åˆæˆæ‰€æœ‰å›¾å±‚
  composite: (layers, viewport) => {
    // åˆ›å»ºæœ€ç»ˆçš„åˆæˆç”»å¸ƒ
    const finalCanvas = this.createCanvas(viewport.width, viewport.height);
    const context = finalCanvas.getContext('2d');
    
    // æŒ‰z-orderæ’åºå›¾å±‚
    const sortedLayers = this.sortLayersByZOrder(layers);
    
    // åˆæˆæ¯ä¸ªå›¾å±‚
    sortedLayers.forEach(layer => {
      this.compositeLayer(context, layer);
    });
    
    return finalCanvas;
  },
  
  // åˆæˆå•ä¸ªå›¾å±‚
  compositeLayer: (context, layer) => {
    // ä¿å­˜å½“å‰ä¸Šä¸‹æ–‡çŠ¶æ€
    context.save();
    
    // åº”ç”¨å˜æ¢
    this.applyTransform(context, layer.transform);
    
    // åº”ç”¨é€æ˜åº¦
    context.globalAlpha = layer.opacity;
    
    // åº”ç”¨æ··åˆæ¨¡å¼
    context.globalCompositeOperation = layer.blendMode;
    
    // åº”ç”¨æ»¤é•œ
    if (layer.filters.length > 0) {
      context.filter = this.buildFilterString(layer.filters);
    }
    
    // ç»˜åˆ¶å›¾å±‚å†…å®¹
    if (layer.paintedContent) {
      context.drawImage(
        layer.paintedContent,
        layer.geometry.x,
        layer.geometry.y
      );
    }
    
    // æ¢å¤ä¸Šä¸‹æ–‡çŠ¶æ€
    context.restore();
  },
  
  // åº”ç”¨å˜æ¢çŸ©é˜µ
  applyTransform: (context, transform) => {
    // åº”ç”¨å¹³ç§»
    context.translate(transform.translateX, transform.translateY);
    
    // åº”ç”¨ç¼©æ”¾
    context.scale(transform.scaleX, transform.scaleY);
    
    // åº”ç”¨æ—‹è½¬
    if (transform.rotateZ !== 0) {
      context.rotate(transform.rotateZ * Math.PI / 180);
    }
  },
  
  // æ„å»ºæ»¤é•œå­—ç¬¦ä¸²
  buildFilterString: (filters) => {
    return filters.map(filter => {
      switch (filter.type) {
        case 'blur':
          return `blur(${filter.value}px)`;
        case 'brightness':
          return `brightness(${filter.value})`;
        case 'contrast':
          return `contrast(${filter.value})`;
        case 'grayscale':
          return `grayscale(${filter.value})`;
        default:
          return '';
      }
    }).join(' ');
  },
  
  // æŒ‰z-orderæ’åºå›¾å±‚
  sortLayersByZOrder: (layers) => {
    return layers.sort((a, b) => {
      const aZIndex = parseInt(a.style.zIndex) || 0;
      const bZIndex = parseInt(b.style.zIndex) || 0;
      return aZIndex - bZIndex;
    });
  }
};
```

### 10.3 ç¡¬ä»¶åŠ é€Ÿ

```javascript
// ç¡¬ä»¶åŠ é€Ÿç®¡ç†
const hardwareAcceleration = {
  // GPUå±‚ç®¡ç†
  gpuLayerManager: {
    gpuLayers: new Map(),
    
    // ä¸Šä¼ åˆ°GPU
    uploadToGPU: (layer) => {
      if (this.canUseGPU(layer)) {
        const gpuLayer = this.createGPULayer(layer);
        this.gpuLayers.set(layer.id, gpuLayer);
        return gpuLayer;
      }
      return null;
    },
    
    // åˆ¤æ–­æ˜¯å¦å¯ä»¥ä½¿ç”¨GPU
    canUseGPU: (layer) => {
      // WebGLæ”¯æŒæ£€æŸ¥
      const canvas = document.createElement('canvas');
      const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
      
      if (!gl) return false;
      
      // æ£€æŸ¥å±‚æ˜¯å¦é€‚åˆGPUå¤„ç†
      return layer.style.transform || 
             layer.style.opacity < 1 ||
             layer.filters.length > 0;
    },
    
    // åˆ›å»ºGPUå±‚
    createGPULayer: (layer) => {
      const canvas = document.createElement('canvas');
      const gl = canvas.getContext('webgl');
      
      // åˆ›å»ºçº¹ç†
      const texture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, texture);
      
      // ä¸Šä¼ å›¾å±‚æ•°æ®åˆ°çº¹ç†
      gl.texImage2D(
        gl.TEXTURE_2D, 0, gl.RGBA,
        layer.geometry.width,
        layer.geometry.height,
        0, gl.RGBA, gl.UNSIGNED_BYTE,
        layer.paintedContent
      );
      
      return {
        texture: texture,
        vertexBuffer: this.createVertexBuffer(gl, layer.geometry),
        shader: this.createShader(gl, layer)
      };
    }
  },
  
  // åˆæˆä¼˜åŒ–
  compositeOptimizations: {
    // åªåˆæˆå˜åŒ–çš„å›¾å±‚
    incrementalComposite: (changedLayers, previousResult) => {
      // æ‰¾å‡ºå½±å“çš„åŒºåŸŸ
      const affectedRegion = this.calculateAffectedRegion(changedLayers);
      
      // åªé‡æ–°åˆæˆå—å½±å“çš„åŒºåŸŸ
      return this.compositeRegion(affectedRegion, previousResult);
    },
    
    // å¹¶è¡Œåˆæˆ
    parallelComposite: (layers) => {
      // å°†å›¾å±‚åˆ†ç»„è¿›è¡Œå¹¶è¡Œå¤„ç†
      const layerGroups = this.groupLayers(layers);
      
      const promises = layerGroups.map(group => {
        return new Promise((resolve) => {
          // åœ¨Web Workerä¸­è¿›è¡Œåˆæˆ
          const worker = new Worker('compositor-worker.js');
          worker.postMessage({ layers: group });
          worker.onmessage = (e) => {
            resolve(e.data.result);
          };
        });
      });
      
      return Promise.all(promises);
    }
  }
};
```

---

## JavaScriptæ‰§è¡Œ

### 11.1 JavaScriptæ‰§è¡Œæ—¶æœº

```javascript
// JavaScriptæ‰§è¡Œç®¡ç†å™¨
const jsExecutionManager = {
  // è„šæœ¬æ‰§è¡Œé˜Ÿåˆ—
  executionQueue: [],
  
  // æ·»åŠ è„šæœ¬åˆ°æ‰§è¡Œé˜Ÿåˆ—
  addScript: (script) => {
    const scriptInfo = {
      type: script.type || 'text/javascript',
      src: script.src,
      content: script.textContent,
      async: script.hasAttribute('async'),
      defer: script.hasAttribute('defer'),
      module: script.type === 'module',
      crossorigin: script.crossOrigin,
      integrity: script.integrity
    };
    
    if (scriptInfo.async) {
      // å¼‚æ­¥è„šæœ¬ï¼šå¹¶è¡Œä¸‹è½½ï¼Œä¸‹è½½å®Œæˆåç«‹å³æ‰§è¡Œ
      this.executeAsyncScript(scriptInfo);
    } else if (scriptInfo.defer) {
      // å»¶è¿Ÿè„šæœ¬ï¼šå¹¶è¡Œä¸‹è½½ï¼ŒDOMè§£æå®ŒæˆåæŒ‰é¡ºåºæ‰§è¡Œ
      this.deferScript(scriptInfo);
    } else {
      // åŒæ­¥è„šæœ¬ï¼šé˜»å¡HTMLè§£æï¼Œç«‹å³ä¸‹è½½å¹¶æ‰§è¡Œ
      this.executeSyncScript(scriptInfo);
    }
  },
  
  // æ‰§è¡ŒåŒæ­¥è„šæœ¬
  executeSyncScript: (scriptInfo) => {
    // æš‚åœHTMLè§£æ
    htmlParser.pauseParsing();
    
    if (scriptInfo.src) {
      // å¤–éƒ¨è„šæœ¬
      this.loadExternalScript(scriptInfo.src)
        .then(code => {
          this.executeCode(code, scriptInfo);
          htmlParser.resumeParsing();
        })
        .catch(error => {
          console.error('è„šæœ¬åŠ è½½å¤±è´¥:', error);
          htmlParser.resumeParsing();
        });
    } else {
      // å†…è”è„šæœ¬
      this.executeCode(scriptInfo.content, scriptInfo);
      htmlParser.resumeParsing();
    }
  },
  
  // æ‰§è¡Œå¼‚æ­¥è„šæœ¬
  executeAsyncScript: (scriptInfo) => {
    if (scriptInfo.src) {
      this.loadExternalScript(scriptInfo.src)
        .then(code => {
          this.executeCode(code, scriptInfo);
        });
    } else {
      this.executeCode(scriptInfo.content, scriptInfo);
    }
  },
  
  // å»¶è¿Ÿè„šæœ¬å¤„ç†
  deferScript: (scriptInfo) => {
    this.deferredScripts = this.deferredScripts || [];
    this.deferredScripts.push(scriptInfo);
  },
  
  // DOMè§£æå®Œæˆåæ‰§è¡Œå»¶è¿Ÿè„šæœ¬
  executeDeferredScripts: () => {
    if (this.deferredScripts) {
      this.deferredScripts.forEach(scriptInfo => {
        if (scriptInfo.src) {
          this.loadExternalScript(scriptInfo.src)
            .then(code => {
              this.executeCode(code, scriptInfo);
            });
        } else {
          this.executeCode(scriptInfo.content, scriptInfo);
        }
      });
    }
  },
  
  // æ‰§è¡ŒJavaScriptä»£ç 
  executeCode: (code, scriptInfo) => {
    try {
      // åˆ›å»ºæ‰§è¡Œä¸Šä¸‹æ–‡
      const executionContext = this.createExecutionContext(scriptInfo);
      
      // æ‰§è¡Œä»£ç 
      if (scriptInfo.module) {
        this.executeModule(code, executionContext);
      } else {
        this.executeScript(code, executionContext);
      }
    } catch (error) {
      console.error('JavaScriptæ‰§è¡Œé”™è¯¯:', error);
      this.handleScriptError(error, scriptInfo);
    }
  }
};
```

### 11.2 DOMäº‹ä»¶å¤„ç†

```javascript
// DOMäº‹ä»¶ç³»ç»Ÿ
const domEventSystem = {
  // äº‹ä»¶ç›‘å¬å™¨ç®¡ç†
  eventListeners: new Map(),
  
  // æ·»åŠ äº‹ä»¶ç›‘å¬å™¨
  addEventListener: (element, type, listener, options) => {
    const listenerId = this.generateListenerId();
    const listenerInfo = {
      id: listenerId,
      element: element,
      type: type,
      listener: listener,
      options: options || {},
      useCapture: options?.capture || false,
      passive: options?.passive || false,
      once: options?.once || false
    };
    
    if (!this.eventListeners.has(element)) {
      this.eventListeners.set(element, new Map());
    }
    
    const elementListeners = this.eventListeners.get(element);
    if (!elementListeners.has(type)) {
      elementListeners.set(type, []);
    }
    
    elementListeners.get(type).push(listenerInfo);
    
    return listenerId;
  },
  
  // è§¦å‘äº‹ä»¶
  dispatchEvent: (target, event) => {
    // 1. æ•è·é˜¶æ®µ
    const capturingPath = this.buildEventPath(target, true);
    this.executeEventPhase(capturingPath, event, 'capturing');
    
    // 2. ç›®æ ‡é˜¶æ®µ
    if (!event.stopPropagation) {
      this.executeEventPhase([target], event, 'target');
    }
    
    // 3. å†’æ³¡é˜¶æ®µ
    if (!event.stopPropagation && event.bubbles) {
      const bubblingPath = this.buildEventPath(target, false);
      this.executeEventPhase(bubblingPath, event, 'bubbling');
    }
  },
  
  // æ„å»ºäº‹ä»¶è·¯å¾„
  buildEventPath: (target, capturing) => {
    const path = [];
    let current = target;
    
    while (current) {
      path.push(current);
      current = current.parentElement;
    }
    
    return capturing ? path.reverse() : path.slice(1);
  },
  
  // æ‰§è¡Œäº‹ä»¶é˜¶æ®µ
  executeEventPhase: (path, event, phase) => {
    path.forEach(element => {
      const elementListeners = this.eventListeners.get(element);
      if (!elementListeners) return;
      
      const listeners = elementListeners.get(event.type);
      if (!listeners) return;
      
      listeners.forEach(listenerInfo => {
        if (this.shouldExecuteListener(listenerInfo, phase)) {
          try {
            // è®¾ç½®äº‹ä»¶ä¸Šä¸‹æ–‡
            event.currentTarget = element;
            event.eventPhase = this.getEventPhaseConstant(phase);
            
            // æ‰§è¡Œç›‘å¬å™¨
            listenerInfo.listener.call(element, event);
            
            // å¤„ç†onceé€‰é¡¹
            if (listenerInfo.once) {
              this.removeEventListener(element, event.type, listenerInfo.listener);
            }
          } catch (error) {
            console.error('äº‹ä»¶ç›‘å¬å™¨æ‰§è¡Œé”™è¯¯:', error);
          }
        }
      });
    });
  },
  
  // åˆ¤æ–­æ˜¯å¦åº”è¯¥æ‰§è¡Œç›‘å¬å™¨
  shouldExecuteListener: (listenerInfo, phase) => {
    if (phase === 'capturing') {
      return listenerInfo.useCapture;
    } else if (phase === 'bubbling') {
      return !listenerInfo.useCapture;
    } else { // target phase
      return true;
    }
  }
};
```

### 11.3 é¡µé¢ç”Ÿå‘½å‘¨æœŸäº‹ä»¶

```javascript
// é¡µé¢ç”Ÿå‘½å‘¨æœŸç®¡ç†
const pageLifecycleManager = {
  // ç”Ÿå‘½å‘¨æœŸçŠ¶æ€
  lifecycleState: 'loading',
  
  // ç”Ÿå‘½å‘¨æœŸäº‹ä»¶è§¦å‘
  triggerLifecycleEvents: () => {
    // DOMContentLoadedäº‹ä»¶
    this.triggerDOMContentLoaded();
    
    // loadäº‹ä»¶
    this.triggerLoad();
    
    // beforeunloadäº‹ä»¶
    this.setupBeforeUnload();
  },
  
  // è§¦å‘DOMContentLoaded
  triggerDOMContentLoaded: () => {
    if (this.isDOMReady()) {
      const event = new Event('DOMContentLoaded', {
        bubbles: true,
        cancelable: false
      });
      
      document.dispatchEvent(event);
      this.lifecycleState = 'interactive';
      
      // æ‰§è¡Œå»¶è¿Ÿè„šæœ¬
      jsExecutionManager.executeDeferredScripts();
    }
  },
  
  // è§¦å‘loadäº‹ä»¶
  triggerLoad: () => {
    // ç­‰å¾…æ‰€æœ‰èµ„æºåŠ è½½å®Œæˆ
    this.waitForAllResources().then(() => {
      const event = new Event('load', {
        bubbles: false,
        cancelable: false
      });
      
      window.dispatchEvent(event);
      this.lifecycleState = 'complete';
    });
  },
  
  // æ£€æŸ¥DOMæ˜¯å¦å°±ç»ª
  isDOMReady: () => {
    return htmlParser.isParsingComplete() && 
           !htmlParser.hasPendingSyncScripts();
  },
  
  // ç­‰å¾…æ‰€æœ‰èµ„æº
  waitForAllResources: () => {
    const pendingResources = [
      ...resourceLoader.getPendingImages(),
      ...resourceLoader.getPendingStylesheets(),
      ...resourceLoader.getPendingScripts()
    ];
    
    return Promise.all(pendingResources);
  },
  
  // æ€§èƒ½æŒ‡æ ‡æ”¶é›†
  performanceMetrics: {
    // First Paint (FP)
    measureFirstPaint: () => {
      const fpEntry = performance.getEntriesByName('first-paint')[0];
      return fpEntry ? fpEntry.startTime : null;
    },
    
    // First Contentful Paint (FCP)
    measureFirstContentfulPaint: () => {
      const fcpEntry = performance.getEntriesByName('first-contentful-paint')[0];
      return fcpEntry ? fcpEntry.startTime : null;
    },
    
    // Largest Contentful Paint (LCP)
    measureLargestContentfulPaint: () => {
      return new Promise((resolve) => {
        const observer = new PerformanceObserver((list) => {
          const entries = list.getEntries();
          const lastEntry = entries[entries.length - 1];
          resolve(lastEntry.startTime);
        });
        
        observer.observe({ entryTypes: ['largest-contentful-paint'] });
      });
    },
    
    // Time to Interactive (TTI)
    measureTimeToInteractive: () => {
      // ç®€åŒ–çš„TTIè®¡ç®—
      return new Promise((resolve) => {
        const checkInteractive = () => {
          if (this.isPageInteractive()) {
            resolve(performance.now());
          } else {
            setTimeout(checkInteractive, 100);
          }
        };
        checkInteractive();
      });
    },
    
    isPageInteractive: () => {
      return this.lifecycleState === 'complete' &&
             this.getMainThreadIdleTime() > 50;
    }
  }
};
```

---

## æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### 12.1 èµ„æºåŠ è½½ä¼˜åŒ–

```html
<!-- èµ„æºé¢„åŠ è½½ä¼˜åŒ–ç¤ºä¾‹ -->
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <!-- DNSé¢„è§£æ -->
  <link rel="dns-prefetch" href="//fonts.googleapis.com">
  <link rel="dns-prefetch" href="//api.example.com">
  <link rel="dns-prefetch" href="//cdn.jsdelivr.net">
  
  <!-- é¢„è¿æ¥ -->
  <link rel="preconnect" href="//fonts.gstatic.com" crossorigin>
  
  <!-- å…³é”®èµ„æºé¢„åŠ è½½ -->
  <link rel="preload" href="/css/critical.css" as="style">
  <link rel="preload" href="/fonts/main.woff2" as="font" type="font/woff2" crossorigin>
  <link rel="preload" href="/js/app.js" as="script">
  
  <!-- éå…³é”®èµ„æºé¢„è·å– -->
  <link rel="prefetch" href="/css/non-critical.css">
  <link rel="prefetch" href="/js/analytics.js">
  
  <!-- å…³é”®CSSå†…è” -->
  <style>
    /* é¦–å±å…³é”®æ ·å¼ */
    body { font-family: sans-serif; margin: 0; }
    .header { background: #333; color: white; padding: 1rem; }
  </style>
  
  <!-- éå…³é”®CSSå¼‚æ­¥åŠ è½½ -->
  <link rel="preload" href="/css/main.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
  <noscript><link rel="stylesheet" href="/css/main.css"></noscript>
</head>
</html>
```

### 12.2 æ¸²æŸ“æ€§èƒ½ä¼˜åŒ–

```javascript
// æ¸²æŸ“æ€§èƒ½ä¼˜åŒ–ç­–ç•¥
const renderingOptimizations = {
  // é¿å…å¸ƒå±€æŠ–åŠ¨
  preventLayoutThrashing: {
    // æ‰¹é‡DOMæ“ä½œ
    batchDOMOperations: (operations) => {
      // ä½¿ç”¨DocumentFragmentå‡å°‘é‡æ’
      const fragment = document.createDocumentFragment();
      
      operations.forEach(operation => {
        const element = operation.createElement();
        fragment.appendChild(element);
      });
      
      // ä¸€æ¬¡æ€§æ’å…¥åˆ°DOM
      document.body.appendChild(fragment);
    },
    
    // ä½¿ç”¨transformä»£æ›¿left/top
    useTransformForAnimation: () => {
      // âŒ è§¦å‘å¸ƒå±€
      element.style.left = '100px';
      element.style.top = '100px';
      
      // âœ… åªè§¦å‘åˆæˆ
      element.style.transform = 'translate(100px, 100px)';
    },
    
    // è¯»å†™åˆ†ç¦»
    separateReadsAndWrites: () => {
      // âŒ å¼ºåˆ¶åŒæ­¥å¸ƒå±€
      element1.style.width = '100px';
      const width1 = element1.offsetWidth; // å¼ºåˆ¶å¸ƒå±€
      element2.style.width = '200px';
      const width2 = element2.offsetWidth; // å†æ¬¡å¼ºåˆ¶å¸ƒå±€
      
      // âœ… æ‰¹é‡è¯»å–å’Œå†™å…¥
      const width1 = element1.offsetWidth;
      const width2 = element2.offsetWidth;
      element1.style.width = '100px';
      element2.style.width = '200px';
    }
  },
  
  // ä½¿ç”¨CSS containment
  cssContainment: {
    layoutContainment: {
      css: 'contain: layout;',
      description: 'éš”ç¦»å…ƒç´ çš„å¸ƒå±€å½±å“'
    },
    paintContainment: {
      css: 'contain: paint;',
      description: 'éš”ç¦»å…ƒç´ çš„ç»˜åˆ¶å½±å“'
    },
    styleContainment: {
      css: 'contain: style;',
      description: 'éš”ç¦»æ ·å¼è®¡ç®—å½±å“'
    },
    strictContainment: {
      css: 'contain: strict;',
      description: 'æœ€ä¸¥æ ¼çš„éš”ç¦»'
    }
  },
  
  // è™šæ‹Ÿæ»šåŠ¨å®ç°
  virtualScrolling: {
    implement: (container, items, itemHeight) => {
      const visibleCount = Math.ceil(container.clientHeight / itemHeight);
      const totalHeight = items.length * itemHeight;
      
      let startIndex = 0;
      let endIndex = visibleCount;
      
      const render = () => {
        // æ¸…ç©ºå®¹å™¨
        container.innerHTML = '';
        
        // åˆ›å»ºå ä½å…ƒç´ ç»´æŒæ€»é«˜åº¦
        const spacerTop = document.createElement('div');
        spacerTop.style.height = `${startIndex * itemHeight}px`;
        container.appendChild(spacerTop);
        
        // æ¸²æŸ“å¯è§é¡¹ç›®
        for (let i = startIndex; i < endIndex && i < items.length; i++) {
          const item = this.createItemElement(items[i]);
          container.appendChild(item);
        }
        
        // åº•éƒ¨å ä½å…ƒç´ 
        const spacerBottom = document.createElement('div');
        spacerBottom.style.height = `${(items.length - endIndex) * itemHeight}px`;
        container.appendChild(spacerBottom);
      };
      
      // æ»šåŠ¨äº‹ä»¶å¤„ç†
      container.addEventListener('scroll', () => {
        const scrollTop = container.scrollTop;
        startIndex = Math.floor(scrollTop / itemHeight);
        endIndex = startIndex + visibleCount + 1; // å¤šæ¸²æŸ“ä¸€é¡¹
        
        requestAnimationFrame(render);
      });
      
      render();
    }
  },
  
  // å›¾ç‰‡æ‡’åŠ è½½
  lazyLoading: {
    implement: () => {
      const imageObserver = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            const img = entry.target;
            img.src = img.dataset.src;
            img.onload = () => img.classList.add('loaded');
            imageObserver.unobserve(img);
          }
        });
      });
      
      document.querySelectorAll('img[data-src]').forEach(img => {
        imageObserver.observe(img);
      });
    }
  }
};
```

### 12.3 ç½‘ç»œä¼˜åŒ–

```javascript
// ç½‘ç»œæ€§èƒ½ä¼˜åŒ–
const networkOptimizations = {
  // HTTP/2æœåŠ¡å™¨æ¨é€
  http2ServerPush: {
    configuration: `
      # Apacheé…ç½®
      <Location />
        Header add Link "</css/critical.css>; rel=preload; as=style"
        Header add Link "</js/app.js>; rel=preload; as=script"
      </Location>
      
      # Nginxé…ç½®
      location / {
        http2_push /css/critical.css;
        http2_push /js/app.js;
      }
    `
  },
  
  // èµ„æºå‹ç¼©
  resourceCompression: {
    gzip: {
      description: 'é€šç”¨å‹ç¼©ç®—æ³•ï¼Œå‹ç¼©ç‡çº¦60-70%',
      config: 'Content-Encoding: gzip'
    },
    brotli: {
      description: 'æ›´é«˜æ•ˆçš„å‹ç¼©ç®—æ³•ï¼Œå‹ç¼©ç‡çº¦20%ä¼˜äºgzip',
      config: 'Content-Encoding: br'
    },
    implementation: `
      # Nginx Brotlié…ç½®
      brotli on;
      brotli_comp_level 6;
      brotli_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;
    `
  },
  
  // CDNä¼˜åŒ–
  cdnOptimization: {
    strategies: [
      'å°±è¿‘è®¿é—® - é€‰æ‹©åœ°ç†ä½ç½®æœ€è¿‘çš„CDNèŠ‚ç‚¹',
      'ç¼“å­˜ç­–ç•¥ - è®¾ç½®åˆé€‚çš„ç¼“å­˜æ—¶é—´',
      'èµ„æºåˆ†åŸŸ - çªç ´æµè§ˆå™¨å¹¶å‘é™åˆ¶',
      'èµ„æºåˆå¹¶ - å‡å°‘HTTPè¯·æ±‚æ•°é‡'
    ],
    
    implementation: {
      multiDomain: [
        'static1.example.com',
        'static2.example.com',
        'static3.example.com'
      ],
      cacheControl: {
        'text/html': 'Cache-Control: no-cache',
        'text/css': 'Cache-Control: public, max-age=31536000',
        'application/javascript': 'Cache-Control: public, max-age=31536000',
        'image/*': 'Cache-Control: public, max-age=2592000'
      }
    }
  },
  
  // Service Workerç¼“å­˜
  serviceWorkerCaching: {
    implementation: `
      // sw.js
      const CACHE_NAME = 'app-v1.0.0';
      const urlsToCache = [
        '/',
        '/css/app.css',
        '/js/app.js',
        '/images/logo.png'
      ];
      
      // å®‰è£…äº‹ä»¶ - ç¼“å­˜å…³é”®èµ„æº
      self.addEventListener('install', event => {
        event.waitUntil(
          caches.open(CACHE_NAME)
            .then(cache => cache.addAll(urlsToCache))
        );
      });
      
      // è·å–äº‹ä»¶ - ç¼“å­˜ç­–ç•¥
      self.addEventListener('fetch', event => {
        event.respondWith(
          caches.match(event.request)
            .then(response => {
              // ç¼“å­˜å‘½ä¸­ï¼Œè¿”å›ç¼“å­˜å†…å®¹
              if (response) {
                return response;
              }
              
              // ç½‘ç»œè¯·æ±‚
              return fetch(event.request)
                .then(response => {
                  // æ£€æŸ¥å“åº”æœ‰æ•ˆæ€§
                  if (!response || response.status !== 200 || response.type !== 'basic') {
                    return response;
                  }
                  
                  // ç¼“å­˜æ–°èµ„æº
                  const responseToCache = response.clone();
                  caches.open(CACHE_NAME)
                    .then(cache => {
                      cache.put(event.request, responseToCache);
                    });
                  
                  return response;
                });
            })
        );
      });
    `
  }
};
```

---

## æ—¶é—´çº¿åˆ†æ

### 13.1 å®Œæ•´æ—¶é—´çº¿

```javascript
// æµè§ˆå™¨æ¸²æŸ“æ—¶é—´çº¿åˆ†æ
const renderingTimeline = {
  // å…¸å‹çš„é¡µé¢åŠ è½½æ—¶é—´çº¿
  timeline: [
    {
      time: '0ms',
      event: 'ç”¨æˆ·è¾“å…¥URL',
      description: 'ç”¨æˆ·åœ¨åœ°å€æ è¾“å…¥URLå¹¶æŒ‰å›è½¦',
      duration: '0ms'
    },
    {
      time: '0-10ms',
      event: 'URLè§£æ',
      description: 'æµè§ˆå™¨è§£æURLï¼Œæå–åè®®ã€åŸŸåã€è·¯å¾„ç­‰ä¿¡æ¯',
      duration: '10ms'
    },
    {
      time: '10-60ms',
      event: 'DNSè§£æ',
      description: 'åŸŸåè§£æä¸ºIPåœ°å€ï¼Œå¯èƒ½å‘½ä¸­ç¼“å­˜',
      duration: '50ms'
    },
    {
      time: '60-120ms',
      event: 'TCPè¿æ¥',
      description: 'TCPä¸‰æ¬¡æ¡æ‰‹å»ºç«‹è¿æ¥',
      duration: '60ms'
    },
    {
      time: '120-200ms',
      event: 'TLSæ¡æ‰‹',
      description: 'HTTPSç«™ç‚¹è¿›è¡ŒTLSæ¡æ‰‹å»ºç«‹å®‰å…¨è¿æ¥',
      duration: '80ms'
    },
    {
      time: '200-220ms',
      event: 'HTTPè¯·æ±‚',
      description: 'å‘é€HTTPè¯·æ±‚åˆ°æœåŠ¡å™¨',
      duration: '20ms'
    },
    {
      time: '220-320ms',
      event: 'æœåŠ¡å™¨å¤„ç†',
      description: 'æœåŠ¡å™¨å¤„ç†è¯·æ±‚å¹¶ç”Ÿæˆå“åº”',
      duration: '100ms'
    },
    {
      time: '320-350ms',
      event: 'æ¥æ”¶å“åº”',
      description: 'æµè§ˆå™¨æ¥æ”¶HTMLå“åº”',
      duration: '30ms'
    },
    {
      time: '350-450ms',
      event: 'HTMLè§£æ',
      description: 'è§£æHTMLå¹¶æ„å»ºDOMæ ‘',
      duration: '100ms'
    },
    {
      time: '400-500ms',
      event: 'CSSè§£æ',
      description: 'å¹¶è¡Œè§£æCSSå¹¶æ„å»ºCSSOM',
      duration: '100ms'
    },
    {
      time: '500-550ms',
      event: 'æ ·å¼è®¡ç®—',
      description: 'è®¡ç®—æ¯ä¸ªå…ƒç´ çš„æœ€ç»ˆæ ·å¼',
      duration: '50ms'
    },
    {
      time: '550-600ms',
      event: 'å¸ƒå±€è®¡ç®—',
      description: 'è®¡ç®—å…ƒç´ çš„å‡ ä½•ä¿¡æ¯å’Œä½ç½®',
      duration: '50ms'
    },
    {
      time: '600-650ms',
      event: 'ç»˜åˆ¶å‡†å¤‡',
      description: 'ç”Ÿæˆç»˜åˆ¶åˆ—è¡¨å’Œåˆ†å±‚',
      duration: '50ms'
    },
    {
      time: '650ms',
      event: 'First Paint (FP)',
      description: 'é¦–æ¬¡ç»˜åˆ¶ï¼Œé¡µé¢ä¸å†ç©ºç™½',
      duration: '0ms'
    },
    {
      time: '650-750ms',
      event: 'å†…å®¹ç»˜åˆ¶',
      description: 'ç»˜åˆ¶é¡µé¢å†…å®¹åˆ°å›¾å±‚',
      duration: '100ms'
    },
    {
      time: '700ms',
      event: 'First Contentful Paint (FCP)',
      description: 'é¦–æ¬¡å†…å®¹ç»˜åˆ¶ï¼Œç”¨æˆ·çœ‹åˆ°å†…å®¹',
      duration: '0ms'
    },
    {
      time: '750-800ms',
      event: 'å›¾å±‚åˆæˆ',
      description: 'åˆæˆæ‰€æœ‰å›¾å±‚ä¸ºæœ€ç»ˆç”»é¢',
      duration: '50ms'
    },
    {
      time: '800ms',
      event: 'é¡µé¢æ˜¾ç¤º',
      description: 'é¡µé¢é¦–æ¬¡å®Œæ•´æ˜¾ç¤º',
      duration: '0ms'
    },
    {
      time: '450-1000ms',
      event: 'JavaScriptæ‰§è¡Œ',
      description: 'HTMLè§£æè¿‡ç¨‹ä¸­æ‰§è¡ŒJavaScript',
      duration: '550ms'
    },
    {
      time: '1000ms',
      event: 'DOMContentLoaded',
      description: 'DOMæ„å»ºå®Œæˆäº‹ä»¶',
      duration: '0ms'
    },
    {
      time: '1000-1500ms',
      event: 'èµ„æºåŠ è½½',
      description: 'å›¾ç‰‡ã€å­—ä½“ç­‰èµ„æºç»§ç»­åŠ è½½',
      duration: '500ms'
    },
    {
      time: '1200ms',
      event: 'Largest Contentful Paint (LCP)',
      description: 'æœ€å¤§å†…å®¹ç»˜åˆ¶å®Œæˆ',
      duration: '0ms'
    },
    {
      time: '1500ms',
      event: 'Loadäº‹ä»¶',
      description: 'æ‰€æœ‰èµ„æºåŠ è½½å®Œæˆ',
      duration: '0ms'
    },
    {
      time: '2000ms',
      event: 'Time to Interactive (TTI)',
      description: 'é¡µé¢å®Œå…¨å¯äº¤äº’',
      duration: '0ms'
    }
  ],
  
  // æ€§èƒ½æŒ‡æ ‡
  performanceMetrics: {
    // Core Web Vitals
    coreWebVitals: {
      LCP: {
        name: 'Largest Contentful Paint',
        description: 'æœ€å¤§å†…å®¹ç»˜åˆ¶æ—¶é—´',
        goodThreshold: '2.5s',
        needsImprovement: '2.5s - 4.0s',
        poor: '> 4.0s'
      },
      FID: {
        name: 'First Input Delay',
        description: 'é¦–æ¬¡è¾“å…¥å»¶è¿Ÿ',
        goodThreshold: '100ms',
        needsImprovement: '100ms - 300ms',
        poor: '> 300ms'
      },
      CLS: {
        name: 'Cumulative Layout Shift',
        description: 'ç´¯ç§¯å¸ƒå±€åç§»',
        goodThreshold: '0.1',
        needsImprovement: '0.1 - 0.25',
        poor: '> 0.25'
      }
    },
    
    // å…¶ä»–é‡è¦æŒ‡æ ‡
    otherMetrics: {
      TTFB: {
        name: 'Time to First Byte',
        description: 'é¦–å­—èŠ‚æ—¶é—´',
        target: '< 200ms'
      },
      FP: {
        name: 'First Paint',
        description: 'é¦–æ¬¡ç»˜åˆ¶',
        target: '< 1s'
      },
      FCP: {
        name: 'First Contentful Paint',
        description: 'é¦–æ¬¡å†…å®¹ç»˜åˆ¶',
        target: '< 1.8s'
      },
      TTI: {
        name: 'Time to Interactive',
        description: 'å¯äº¤äº’æ—¶é—´',
        target: '< 3.8s'
      }
    }
  },
  
  // æ€§èƒ½åˆ†æå·¥å…·
  analysisTools: {
    browserDevTools: {
      performance: 'æ€§èƒ½é¢æ¿ - è¯¦ç»†çš„æ—¶é—´çº¿åˆ†æ',
      network: 'ç½‘ç»œé¢æ¿ - èµ„æºåŠ è½½åˆ†æ',
      lighthouse: 'Lighthouse - ç»¼åˆæ€§èƒ½è¯„ä¼°'
    },
    
    realUserMonitoring: {
      webVitals: 'web-vitalsåº“ - æµ‹é‡Core Web Vitals',
      performanceObserver: 'Performance Observer API - æ€§èƒ½æŒ‡æ ‡ç›‘æ§',
      navigationTiming: 'Navigation Timing API - å¯¼èˆªæ—¶é—´åˆ†æ'
    },
    
    syntheticTesting: {
      lighthouse: 'Lighthouse CI - è‡ªåŠ¨åŒ–æ€§èƒ½æµ‹è¯•',
      webPageTest: 'WebPageTest - è¯¦ç»†çš„æ€§èƒ½åˆ†æ',
      speedCurve: 'SpeedCurve - æŒç»­æ€§èƒ½ç›‘æ§'
    }
  }
};
```

### 13.2 æ€§èƒ½ç›‘æ§ä»£ç 

```javascript
// å®æ—¶æ€§èƒ½ç›‘æ§å®ç°
const performanceMonitor = {
  // æ”¶é›†æ€§èƒ½æŒ‡æ ‡
  collectMetrics: () => {
    const metrics = {};
    
    // Navigation Timing
    const navigationTiming = performance.getEntriesByType('navigation')[0];
    if (navigationTiming) {
      metrics.ttfb = navigationTiming.responseStart - navigationTiming.requestStart;
      metrics.domContentLoaded = navigationTiming.domContentLoadedEventEnd - navigationTiming.navigationStart;
      metrics.loadComplete = navigationTiming.loadEventEnd - navigationTiming.navigationStart;
    }
    
    // Paint Timing
    const paintEntries = performance.getEntriesByType('paint');
    paintEntries.forEach(entry => {
      if (entry.name === 'first-paint') {
        metrics.fp = entry.startTime;
      } else if (entry.name === 'first-contentful-paint') {
        metrics.fcp = entry.startTime;
      }
    });
    
    // Largest Contentful Paint
    new PerformanceObserver((list) => {
      const entries = list.getEntries();
      const lastEntry = entries[entries.length - 1];
      metrics.lcp = lastEntry.startTime;
    }).observe({ entryTypes: ['largest-contentful-paint'] });
    
    // First Input Delay
    new PerformanceObserver((list) => {
      const entries = list.getEntries();
      entries.forEach(entry => {
        metrics.fid = entry.processingStart - entry.startTime;
      });
    }).observe({ entryTypes: ['first-input'] });
    
    // Cumulative Layout Shift
    let clsValue = 0;
    new PerformanceObserver((list) => {
      for (const entry of list.getEntries()) {
        if (!entry.hadRecentInput) {
          clsValue += entry.value;
        }
      }
      metrics.cls = clsValue;
    }).observe({ entryTypes: ['layout-shift'] });
    
    return metrics;
  },
  
  // å‘é€ç›‘æ§æ•°æ®
  sendMetrics: (metrics) => {
    // å‘é€åˆ°åˆ†ææœåŠ¡
    fetch('/analytics/performance', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        url: location.href,
        userAgent: navigator.userAgent,
        metrics: metrics,
        timestamp: Date.now()
      })
    }).catch(error => {
      console.error('æ€§èƒ½æ•°æ®å‘é€å¤±è´¥:', error);
    });
  },
  
  // æ€§èƒ½é¢„ç®—æ£€æŸ¥
  checkPerformanceBudget: (metrics) => {
    const budget = {
      ttfb: 200,    // 200ms
      fcp: 1800,    // 1.8s
      lcp: 2500,    // 2.5s
      fid: 100,     // 100ms
      cls: 0.1      // 0.1
    };
    
    const violations = [];
    
    Object.entries(budget).forEach(([metric, threshold]) => {
      if (metrics[metric] > threshold) {
        violations.push({
          metric: metric,
          actual: metrics[metric],
          threshold: threshold,
          exceeded: metrics[metric] - threshold
        });
      }
    });
    
    if (violations.length > 0) {
      console.warn('æ€§èƒ½é¢„ç®—è¶…æ ‡:', violations);
      this.reportBudgetViolations(violations);
    }
    
    return violations;
  }
};

// é¡µé¢åŠ è½½å®Œæˆåå¯åŠ¨ç›‘æ§
window.addEventListener('load', () => {
  setTimeout(() => {
    const metrics = performanceMonitor.collectMetrics();
    const violations = performanceMonitor.checkPerformanceBudget(metrics);
    performanceMonitor.sendMetrics(metrics);
  }, 1000);
});
```

---

## æ€»ç»“

æµè§ˆå™¨ä»æ¥æ”¶URLåˆ°æœ€ç»ˆå±•ç¤ºé¡µé¢å†…å®¹æ˜¯ä¸€ä¸ªæå…¶å¤æ‚çš„è¿‡ç¨‹ï¼Œæ¶‰åŠï¼š

### ğŸ”„ **ä¸»è¦é˜¶æ®µ**
1. **ç½‘ç»œé€šä¿¡é˜¶æ®µ**: URLè§£æ â†’ DNSè§£æ â†’ TCP/TLSè¿æ¥ â†’ HTTPè¯·æ±‚å“åº”
2. **èµ„æºè§£æé˜¶æ®µ**: HTMLè§£æ â†’ CSSè§£æ â†’ JavaScriptæ‰§è¡Œ
3. **æ¸²æŸ“æ„å»ºé˜¶æ®µ**: DOMæ ‘æ„å»º â†’ CSSOMæ„å»º â†’ æ ·å¼è®¡ç®—
4. **å¸ƒå±€ç»˜åˆ¶é˜¶æ®µ**: Layoutè®¡ç®— â†’ Paintç»˜åˆ¶ â†’ Compositeåˆæˆ

### âš¡ **æ€§èƒ½å…³é”®ç‚¹**
- **ç½‘ç»œä¼˜åŒ–**: DNSé¢„è§£æã€HTTP/2ã€èµ„æºå‹ç¼©ã€CDN
- **èµ„æºä¼˜åŒ–**: å…³é”®èµ„æºä¼˜å…ˆçº§ã€æ‡’åŠ è½½ã€é¢„åŠ è½½
- **æ¸²æŸ“ä¼˜åŒ–**: é¿å…é˜»å¡ã€å‡å°‘é‡æ’é‡ç»˜ã€ç¡¬ä»¶åŠ é€Ÿ
- **JavaScriptä¼˜åŒ–**: å¼‚æ­¥åŠ è½½ã€ä»£ç åˆ†å‰²ã€æ‰§è¡Œä¼˜åŒ–

### ğŸ“Š **æ ¸å¿ƒæŒ‡æ ‡**
- **TTFB**: é¦–å­—èŠ‚æ—¶é—´ (< 200ms)
- **FCP**: é¦–æ¬¡å†…å®¹ç»˜åˆ¶ (< 1.8s) 
- **LCP**: æœ€å¤§å†…å®¹ç»˜åˆ¶ (< 2.5s)
- **FID**: é¦–æ¬¡è¾“å…¥å»¶è¿Ÿ (< 100ms)
- **CLS**: ç´¯ç§¯å¸ƒå±€åç§» (< 0.1)

ç†è§£è¿™ä¸ªå®Œæ•´æµç¨‹å¯¹äºå‰ç«¯æ€§èƒ½ä¼˜åŒ–ã€ç”¨æˆ·ä½“éªŒæå‡å’Œé—®é¢˜æ’æŸ¥éƒ½å…·æœ‰é‡è¦æ„ä¹‰ã€‚ç°ä»£æµè§ˆå™¨é€šè¿‡å„ç§ä¼˜åŒ–æŠ€æœ¯ï¼ˆå¹¶è¡Œå¤„ç†ã€ç¼“å­˜æœºåˆ¶ã€ç¡¬ä»¶åŠ é€Ÿç­‰ï¼‰ä¸æ–­æå‡è¿™ä¸ªè¿‡ç¨‹çš„æ•ˆç‡ã€‚