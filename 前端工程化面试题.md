# 前端工程化面试题

> 基于2024-2025年前端工程化最新趋势整理，涵盖构建工具、代码规范、CI/CD、性能优化等核心领域

## 📦 构建工具与打包优化

### 1. Webpack vs Vite vs Rollup vs Rspack 对比分析

**问题：** 请详细对比这四种构建工具的特点、适用场景和性能差异？

**深度解析：**

| 构建工具 | 核心特点 | 开发体验 | 生产构建 | 适用场景 |
|---------|----------|----------|----------|----------|
| **Webpack** | 成熟稳定，生态丰富 | 启动慢，HMR较慢 | 功能强大，配置复杂 | 大型项目，复杂需求 |
| **Vite** | 基于ESM，双引擎架构 | 启动极快，HMR毫秒级 | 依赖Rollup打包 | 现代项目，快速开发 |
| **Rollup** | Tree Shaking优秀 | 开发服务器简单 | 打包体积小 | 库开发，组件库 |
| **Rspack** | Rust实现，webpack兼容 | 启动快，HMR快 | 性能强劲 | webpack迁移，性能要求高 |

**实战案例：**
```javascript
// Vite配置示例 - 针对大型项目优化
// vite.config.js
import { defineConfig } from 'vite'
import { resolve } from 'path'

export default defineConfig({
  // {{ Source: context7-mcp on 'Vite Performance Optimization' }}
  build: {
    rollupOptions: {
      // 手动分包策略
      output: {
        manualChunks: {
          vendor: ['vue', 'vue-router'],
          utils: ['lodash', 'axios'],
          ui: ['element-plus']
        }
      }
    },
    // 启用gzip压缩
    chunkSizeWarningLimit: 1000
  },
  optimizeDeps: {
    // 预构建优化
    include: ['vue', 'vue-router', 'pinia']
  }
})
```

### 2. Tree Shaking 原理与最佳实践

**问题：** Tree Shaking的工作原理是什么？如何确保代码能够被有效Tree Shaking？

**核心原理：**
- **静态分析**：基于ES6模块的静态特性分析代码依赖
- **DCE（Dead Code Elimination）**：移除未使用的代码
- **副作用标记**：通过`sideEffects`字段控制模块的副作用

**实践技巧：**
```json
// package.json 副作用标记
{
  "sideEffects": false,  // 整个包无副作用
  // 或者指定有副作用的文件
  "sideEffects": ["*.css", "*.scss", "./src/polyfills.js"]
}
```

```javascript
// 编写Tree Shaking友好的代码
// ✅ 推荐：具名导出
export const formatDate = (date) => { /* ... */ }
export const parseDate = (str) => { /* ... */ }

// ❌ 避免：默认导出整个对象
export default {
  formatDate: (date) => { /* ... */ },
  parseDate: (str) => { /* ... */ }
}
```

### 3. 构建性能优化策略

**问题：** 如何优化大型项目的构建性能？请提供具体的优化策略。

**多维度优化方案：**

**① 缓存策略优化**
```javascript
// webpack.config.js
module.exports = {
  cache: {
    type: 'filesystem',
    cacheDirectory: path.resolve(__dirname, '.temp_cache'),
    buildDependencies: {
      config: [__filename]
    }
  }
}
```

**② 并行处理优化**
```javascript
// 使用thread-loader进行多线程构建
module.exports = {
  module: {
    rules: [
      {
        test: /\.js$/,
        use: [
          'thread-loader',
          'babel-loader'
        ]
      }
    ]
  }
}
```

**③ 分包策略优化**
```javascript
// 智能分包配置
optimization: {
  splitChunks: {
    chunks: 'all',
    cacheGroups: {
      // 第三方库单独打包
      vendor: {
        test: /[\\/]node_modules[\\/]/,
        name: 'vendors',
        chunks: 'all',
        priority: 10
      },
      // 公共代码提取
      common: {
        minChunks: 2,
        chunks: 'all',
        priority: 5
      }
    }
  }
}
```

## 🔧 代码质量与规范化

### 4. ESLint + Prettier + TypeScript 完整配置

**问题：** 如何搭建一套完整的代码质量控制体系？

**完整配置方案：**

```javascript
// .eslintrc.js
module.exports = {
  extends: [
    '@typescript-eslint/recommended',
    'plugin:vue/vue3-recommended',
    'prettier' // 必须放在最后
  ],
  parser: '@typescript-eslint/parser',
  plugins: ['@typescript-eslint'],
  rules: {
    // {{ AURA-X: Add - 自定义规则配置. Approval: 寸止. }}
    '@typescript-eslint/no-unused-vars': 'error',
    '@typescript-eslint/explicit-function-return-type': 'warn',
    'vue/multi-word-component-names': 'off'
  },
  overrides: [
    {
      files: ['*.vue'],
      parser: 'vue-eslint-parser',
      parserOptions: {
        parser: '@typescript-eslint/parser'
      }
    }
  ]
}
```

```json
// .prettierrc
{
  "semi": false,
  "singleQuote": true,
  "tabWidth": 2,
  "trailingComma": "es5",
  "printWidth": 100,
  "endOfLine": "lf"
}
```

### 5. Git Hooks 自动化代码检查

**问题：** 如何通过Git Hooks实现代码提交前的自动化检查？

**Husky + lint-staged 配置：**

```json
// package.json
{
  "husky": {
    "hooks": {
      "pre-commit": "lint-staged",
      "commit-msg": "commitlint -E HUSKY_GIT_PARAMS"
    }
  },
  "lint-staged": {
    "*.{js,ts,vue}": [
      "eslint --fix",
      "prettier --write"
    ],
    "*.{css,scss,less}": [
      "stylelint --fix",
      "prettier --write"
    ]
  }
}
```

**Commitlint 规范：**
```javascript
// commitlint.config.js
module.exports = {
  extends: ['@commitlint/config-conventional'],
  rules: {
    'type-enum': [2, 'always', [
      'feat', 'fix', 'docs', 'style', 'refactor',
      'perf', 'test', 'chore', 'revert'
    ]]
  }
}
```

## 🏗️ Monorepo 与微前端架构

### 6. Monorepo 架构设计与实践

**问题：** Monorepo相比Multi-repo有什么优势？如何设计一个高效的Monorepo架构？

**核心优势分析：**
- **代码共享**：公共库统一管理，避免重复开发
- **版本统一**：依赖版本统一，减少兼容性问题
- **构建优化**：增量构建，只构建变更的包
- **协作效率**：跨项目重构更容易，代码review统一

**Lerna + Yarn Workspaces 实践：**
```json
// lerna.json
{
  "version": "independent",
  "npmClient": "yarn",
  "useWorkspaces": true,
  "packages": [
    "packages/*",
    "apps/*"
  ],
  "command": {
    "version": {
      "conventionalCommits": true,
      "message": "chore(release): publish"
    }
  }
}
```

```json
// package.json root
{
  "workspaces": [
    "packages/*",
    "apps/*"
  ],
  "scripts": {
    "build": "lerna run build --stream",
    "test": "lerna run test --parallel",
    "publish": "lerna publish"
  }
}
```

### 7. 微前端解决方案对比

**问题：** 请对比Single-SPA、qiankun、Module Federation的特点和适用场景？

**详细对比分析：**

| 方案 | 技术原理 | 隔离程度 | 学习成本 | 适用场景 |
|------|----------|----------|----------|----------|
| **Single-SPA** | 路由劫持+生命周期 | JS隔离 | 中等 | 技术栈统一的大型应用 |
| **qiankun** | single-spa + 沙箱 | JS+CSS隔离 | 较低 | 企业级应用，渐进式改造 |
| **Module Federation** | Webpack5原生支持 | 运行时加载 | 较高 | 现代化项目，动态加载 |

**Module Federation 实战示例：**
```javascript
// webpack.config.js - 主应用
const ModuleFederationPlugin = require('@module-federation/webpack')

module.exports = {
  plugins: [
    new ModuleFederationPlugin({
      name: 'shell',
      remotes: {
        mf_user: 'mf_user@http://localhost:3001/remoteEntry.js',
        mf_order: 'mf_order@http://localhost:3002/remoteEntry.js'
      }
    })
  ]
}

// 动态加载微前端
const UserModule = React.lazy(() => import('mf_user/UserApp'))
```

## 🚀 CI/CD 与自动化部署

### 8. 前端CI/CD完整流程设计

**问题：** 如何设计一个完整的前端CI/CD流程？包括哪些关键环节？

**完整流程架构：**

```yaml
# .github/workflows/deploy.yml
name: Frontend CI/CD

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
          
      - name: Install dependencies
        run: npm ci
        
      - name: Run linting
        run: npm run lint
        
      - name: Run tests
        run: npm run test:coverage
        
      - name: Upload coverage
        uses: codecov/codecov-action@v3

  build:
    needs: test
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Build application
        run: |
          npm ci
          npm run build
          
      - name: Build Docker image
        run: |
          docker build -t frontend-app:${{ github.sha }} .
          
      - name: Deploy to staging
        if: github.ref == 'refs/heads/develop'
        run: |
          # 部署到测试环境
          echo "Deploy to staging"
          
      - name: Deploy to production
        if: github.ref == 'refs/heads/main'
        run: |
          # 部署到生产环境
          echo "Deploy to production"
```

### 9. Docker在前端项目中的应用

**问题：** 如何为前端项目编写高效的Dockerfile？有哪些最佳实践？

**多阶段构建Dockerfile：**
```dockerfile
# 多阶段构建 - 优化镜像大小
FROM node:18-alpine AS builder

WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production

COPY . .
RUN npm run build

# 生产环境
FROM nginx:alpine

# {{ AURA-X: Add - Nginx配置优化. Source: context7-mcp on 'Nginx SPA Config'. }}
COPY --from=builder /app/dist /usr/share/nginx/html
COPY nginx.conf /etc/nginx/conf.d/default.conf

EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
```

**Nginx SPA配置：**
```nginx
# nginx.conf
server {
    listen 80;
    server_name localhost;
    root /usr/share/nginx/html;
    index index.html;

    # SPA路由支持
    location / {
        try_files $uri $uri/ /index.html;
    }

    # 静态资源缓存
    location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2)$ {
        expires 1y;
        add_header Cache-Control "public, immutable";
    }
}
```

## 📊 性能监控与优化

### 10. 前端性能指标监控体系

**问题：** 如何建立完整的前端性能监控体系？包括哪些关键指标？

**核心性能指标（Web Vitals）：**
- **LCP (Largest Contentful Paint)**：最大内容绘制
- **FID (First Input Delay)**：首次输入延迟  
- **CLS (Cumulative Layout Shift)**：累积布局偏移
- **FCP (First Contentful Paint)**：首次内容绘制
- **TTI (Time to Interactive)**：可交互时间

**性能监控实现：**
```javascript
// 性能监控SDK
class PerformanceMonitor {
  constructor() {
    this.metrics = {}
    this.init()
  }

  init() {
    // {{ AURA-X: Add - Web Vitals监控实现. Source: context7-mcp on 'Web Vitals API'. }}
    this.observeLCP()
    this.observeFID()
    this.observeCLS()
    this.observeCustomMetrics()
  }

  observeLCP() {
    new PerformanceObserver((entryList) => {
      const entries = entryList.getEntries()
      const lastEntry = entries[entries.length - 1]
      this.metrics.lcp = lastEntry.startTime
      this.report('lcp', lastEntry.startTime)
    }).observe({ entryTypes: ['largest-contentful-paint'] })
  }

  observeFID() {
    new PerformanceObserver((entryList) => {
      const entries = entryList.getEntries()
      entries.forEach(entry => {
        this.metrics.fid = entry.processingStart - entry.startTime
        this.report('fid', this.metrics.fid)
      })
    }).observe({ entryTypes: ['first-input'] })
  }

  observeCLS() {
    let clsValue = 0
    new PerformanceObserver((entryList) => {
      for (const entry of entryList.getEntries()) {
        if (!entry.hadRecentInput) {
          clsValue += entry.value
        }
      }
      this.metrics.cls = clsValue
      this.report('cls', clsValue)
    }).observe({ entryTypes: ['layout-shift'] })
  }

  // 自定义业务指标
  observeCustomMetrics() {
    // 页面加载时间
    window.addEventListener('load', () => {
      const loadTime = performance.timing.loadEventEnd - performance.timing.navigationStart
      this.report('page_load_time', loadTime)
    })

    // 路由切换时间
    this.observeRouteChange()
  }

  report(metric, value) {
    // 上报到监控平台
    fetch('/api/performance', {
      method: 'POST',
      body: JSON.stringify({
        metric,
        value,
        url: location.href,
        userAgent: navigator.userAgent,
        timestamp: Date.now()
      })
    })
  }
}

// 初始化监控
new PerformanceMonitor()
```

### 11. 构建产物分析与优化

**问题：** 如何分析和优化前端构建产物的体积？

**Bundle分析工具使用：**
```javascript
// webpack-bundle-analyzer 配置
const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin

module.exports = {
  plugins: [
    new BundleAnalyzerPlugin({
      analyzerMode: 'static',
      openAnalyzer: false,
      reportFilename: 'bundle-report.html'
    })
  ]
}
```

**体积优化策略：**
```javascript
// 1. 动态导入优化
const LazyComponent = React.lazy(() => 
  import(/* webpackChunkName: "lazy-component" */ './LazyComponent')
)

// 2. 第三方库优化
import { debounce } from 'lodash-es' // 只导入需要的函数

// 3. 图片资源优化
const imageConfig = {
  test: /\.(png|jpe?g|gif|svg)$/,
  use: [
    {
      loader: 'url-loader',
      options: {
        limit: 8192, // 小于8kb的图片转base64
        name: 'images/[name].[hash:8].[ext]'
      }
    },
    {
      loader: 'image-webpack-loader',
      options: {
        mozjpeg: { progressive: true, quality: 80 },
        optipng: { enabled: false },
        pngquant: { quality: [0.65, 0.90], speed: 4 }
      }
    }
  ]
}
```

### 12. 运行时性能优化策略

**问题：** 除了构建优化，还有哪些运行时性能优化手段？

**多层级优化方案：**

**① 资源加载优化**
```html
<!-- 关键资源预加载 -->
<link rel="preload" href="/critical.css" as="style">
<link rel="preload" href="/app.js" as="script">

<!-- DNS预解析 -->
<link rel="dns-prefetch" href="//api.example.com">

<!-- 预连接 -->
<link rel="preconnect" href="https://fonts.googleapis.com" crossorigin>
```

**② 代码分割与懒加载**
```javascript
// React路由懒加载
const routes = [
  {
    path: '/home',
    component: React.lazy(() => import('./pages/Home'))
  },
  {
    path: '/user',
    component: React.lazy(() => import(
      /* webpackChunkName: "user" */ './pages/User'
    ))
  }
]

// Vue路由懒加载
const routes = [
  {
    path: '/home',
    component: () => import('./views/Home.vue')
  }
]
```

**③ 缓存策略优化**
```javascript
// Service Worker缓存策略
self.addEventListener('fetch', event => {
  if (event.request.url.includes('/api/')) {
    // API请求：网络优先，缓存降级
    event.respondWith(
      fetch(event.request)
        .then(response => {
          const responseClone = response.clone()
          caches.open('api-cache').then(cache => {
            cache.put(event.request, responseClone)
          })
          return response
        })
        .catch(() => caches.match(event.request))
    )
  } else {
    // 静态资源：缓存优先
    event.respondWith(
      caches.match(event.request)
        .then(response => response || fetch(event.request))
    )
  }
})
```

## 🔍 实战问题解决方案

### 13. 大型项目构建时间过长的优化方案

**问题场景：** 项目包含500+组件，构建时间超过10分钟，如何优化？

**系统性优化方案：**

```javascript
// 1. 开启持久化缓存
module.exports = {
  cache: {
    type: 'filesystem',
    buildDependencies: {
      config: [__filename]
    }
  },
  
  // 2. 优化模块解析
  resolve: {
    modules: [path.resolve(__dirname, 'src'), 'node_modules'],
    extensions: ['.js', '.ts', '.vue'],
    alias: {
      '@': path.resolve(__dirname, 'src')
    }
  },
  
  // 3. 多线程构建
  module: {
    rules: [
      {
        test: /\.js$/,
        use: [
          {
            loader: 'thread-loader',
            options: {
              workers: require('os').cpus().length - 1
            }
          },
          'babel-loader'
        ]
      }
    ]
  },
  
  // 4. DLL预构建
  plugins: [
    new webpack.DllReferencePlugin({
      context: __dirname,
      manifest: require('./dll/vendor-manifest.json')
    })
  ]
}
```

### 14. 微前端应用间通信最佳实践

**问题场景：** 多个微前端应用需要共享状态和通信，如何设计？

**通信方案设计：**

```javascript
// 全局事件总线
class MicroEventBus {
  constructor() {
    this.events = new Map()
  }

  // {{ AURA-X: Add - 微前端通信机制. Source: context7-mcp on 'Micro Frontend Communication'. }}
  subscribe(event, callback) {
    if (!this.events.has(event)) {
      this.events.set(event, [])
    }
    this.events.get(event).push(callback)
    
    return () => {
      const callbacks = this.events.get(event)
      const index = callbacks.indexOf(callback)
      if (index > -1) callbacks.splice(index, 1)
    }
  }

  publish(event, data) {
    if (this.events.has(event)) {
      this.events.get(event).forEach(callback => callback(data))
    }
  }
}

// 全局状态管理
class MicroStateManager {
  constructor() {
    this.state = new Proxy({}, {
      set: (target, key, value) => {
        target[key] = value
        this.notify(key, value)
        return true
      }
    })
    this.subscribers = new Map()
  }

  setState(key, value) {
    this.state[key] = value
  }

  getState(key) {
    return this.state[key]
  }

  subscribe(key, callback) {
    if (!this.subscribers.has(key)) {
      this.subscribers.set(key, [])
    }
    this.subscribers.get(key).push(callback)
  }

  notify(key, value) {
    if (this.subscribers.has(key)) {
      this.subscribers.get(key).forEach(callback => callback(value))
    }
  }
}

// 全局注册
window.__MICRO_APP_SHARED__ = {
  eventBus: new MicroEventBus(),
  stateManager: new MicroStateManager()
}
```

### 15. 前端错误监控与异常处理

**问题：** 如何建立完善的前端错误监控体系？

**完整错误监控方案：**

```javascript
class ErrorMonitor {
  constructor(config = {}) {
    this.config = {
      apiUrl: '/api/errors',
      maxErrors: 10,
      ...config
    }
    this.errorQueue = []
    this.init()
  }

  init() {
    // JS错误监控
    window.addEventListener('error', this.handleError.bind(this))
    
    // Promise异常监控
    window.addEventListener('unhandledrejection', this.handlePromiseError.bind(this))
    
    // 资源加载错误
    window.addEventListener('error', this.handleResourceError.bind(this), true)
    
    // Vue错误监控
    if (window.Vue) {
      this.setupVueErrorHandler()
    }
    
    // React错误边界
    this.setupReactErrorBoundary()
  }

  handleError(event) {
    const error = {
      type: 'javascript',
      message: event.message,
      filename: event.filename,
      lineno: event.lineno,
      colno: event.colno,
      stack: event.error?.stack,
      userAgent: navigator.userAgent,
      url: location.href,
      timestamp: Date.now()
    }
    
    this.reportError(error)
  }

  handlePromiseError(event) {
    const error = {
      type: 'promise',
      message: event.reason?.message || event.reason,
      stack: event.reason?.stack,
      userAgent: navigator.userAgent,
      url: location.href,
      timestamp: Date.now()
    }
    
    this.reportError(error)
  }

  setupVueErrorHandler() {
    const originalHandler = window.Vue.config.errorHandler
    window.Vue.config.errorHandler = (err, vm, info) => {
      this.reportError({
        type: 'vue',
        message: err.message,
        stack: err.stack,
        info,
        timestamp: Date.now()
      })
      
      if (originalHandler) originalHandler(err, vm, info)
    }
  }

  reportError(error) {
    // 防止重复上报
    if (this.isDuplicateError(error)) return
    
    this.errorQueue.push(error)
    
    // 批量上报
    if (this.errorQueue.length >= this.config.maxErrors) {
      this.flushErrors()
    }
  }

  flushErrors() {
    if (this.errorQueue.length === 0) return
    
    fetch(this.config.apiUrl, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ errors: this.errorQueue })
    }).finally(() => {
      this.errorQueue = []
    })
  }
}

// 初始化错误监控
new ErrorMonitor({
  apiUrl: '/api/errors',
  maxErrors: 5
})
```

## 🔧 Vue生态工程化实践

### 16. Vue项目工程化最佳实践

**问题：** 请详细介绍Vue项目的完整工程化配置，包括构建优化、代码规范等？

**Vue3 + Vite完整配置：**

```typescript
// vite.config.ts
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import { resolve } from 'path'
import Components from 'unplugin-vue-components/vite'
import { ElementPlusResolver } from 'unplugin-vue-components/resolvers'
import AutoImport from 'unplugin-auto-import/vite'

export default defineConfig({
  plugins: [
    vue(),
    // {{ AURA-X: Add - Vue自动导入配置. Source: context7-mcp on 'Vue Auto Import'. }}
    AutoImport({
      imports: ['vue', 'vue-router', 'pinia'],
      resolvers: [ElementPlusResolver()],
      dts: true // 生成类型声明文件
    }),
    Components({
      resolvers: [ElementPlusResolver()],
      dts: true
    })
  ],
  resolve: {
    alias: {
      '@': resolve(__dirname, 'src'),
      '@components': resolve(__dirname, 'src/components'),
      '@utils': resolve(__dirname, 'src/utils')
    }
  },
  build: {
    rollupOptions: {
      output: {
        manualChunks: {
          vue: ['vue', 'vue-router', 'pinia'],
          elementPlus: ['element-plus'],
          utils: ['lodash-es', 'dayjs']
        }
      }
    }
  },
  css: {
    preprocessorOptions: {
      scss: {
        additionalData: `@import "@/styles/variables.scss";`
      }
    }
  }
})
```

### 17. Vue组件库工程化实践

**问题：** 如何搭建一个可维护、可扩展的Vue组件库？

**完整组件库架构：**

```typescript
// build/build-lib.ts
import { build } from 'vite'
import vue from '@vitejs/plugin-vue'
import dts from 'vite-plugin-dts'
import { resolve } from 'path'

// 构建ESM和UMD版本
const buildFormats = ['es', 'umd'] as const

for (const format of buildFormats) {
  await build({
    plugins: [
      vue(),
      dts({
        include: ['src/**/*'],
        exclude: ['src/**/*.test.*']
      })
    ],
    build: {
      lib: {
        entry: resolve(__dirname, '../src/index.ts'),
        name: 'MyUILibrary',
        fileName: (format) => `my-ui.${format}.js`,
        formats: [format]
      },
      rollupOptions: {
        external: ['vue'],
        output: {
          globals: {
            vue: 'Vue'
          }
        }
      }
    }
  })
}
```

```typescript
// src/index.ts - 组件库入口
import type { App } from 'vue'
import Button from './components/Button/index.vue'
import Input from './components/Input/index.vue'

const components = [Button, Input]

const install = (app: App) => {
  components.forEach(component => {
    app.component(component.name, component)
  })
}

export { Button, Input }
export default { install }
```

### 18. Vue项目状态管理工程化

**问题：** 请对比Vuex和Pinia在大型项目中的应用，以及最佳实践？

**Pinia模块化状态管理：**

```typescript
// stores/user.ts
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'
import type { User } from '@/types'

export const useUserStore = defineStore('user', () => {
  // State
  const user = ref<User | null>(null)
  const permissions = ref<string[]>([])

  // Getters
  const isLoggedIn = computed(() => !!user.value)
  const hasPermission = computed(() => (permission: string) => 
    permissions.value.includes(permission)
  )

  // Actions
  async function login(credentials: LoginCredentials) {
    try {
      const response = await authApi.login(credentials)
      user.value = response.user
      permissions.value = response.permissions
      
      // {{ AURA-X: Add - 持久化存储. Confirmed via 寸止. }}
      localStorage.setItem('auth_token', response.token)
    } catch (error) {
      throw new Error('Login failed')
    }
  }

  function logout() {
    user.value = null
    permissions.value = []
    localStorage.removeItem('auth_token')
  }

  return {
    user,
    permissions,
    isLoggedIn,
    hasPermission,
    login,
    logout
  }
})
```

## ⚛️ React生态工程化实践

### 19. React项目工程化完整方案

**问题：** 请介绍React项目的现代化工程配置，包括构建工具、代码分割等？

**Vite + React完整配置：**

```typescript
// vite.config.ts
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react-swc'
import { resolve } from 'path'

export default defineConfig({
  plugins: [
    react({
      // 使用SWC替代Babel，提升构建性能
      jsxImportSource: '@emotion/react'
    })
  ],
  resolve: {
    alias: {
      '@': resolve(__dirname, './src'),
      '@components': resolve(__dirname, './src/components'),
      '@hooks': resolve(__dirname, './src/hooks'),
      '@stores': resolve(__dirname, './src/stores')
    }
  },
  build: {
    rollupOptions: {
      output: {
        manualChunks: {
          // {{ AURA-X: Add - React生态分包策略. Source: context7-mcp on 'React Bundle Splitting'. }}
          'react-vendor': ['react', 'react-dom', 'react-router-dom'],
          'ui-vendor': ['antd', '@ant-design/icons'],
          'utils-vendor': ['lodash-es', 'dayjs', 'axios']
        }
      }
    }
  },
  server: {
    proxy: {
      '/api': {
        target: 'http://localhost:3001',
        changeOrigin: true
      }
    }
  }
})
```

### 20. React组件设计模式与工程实践

**问题：** 在大型React项目中，如何设计可复用、可维护的组件架构？

**高级组件设计模式：**

```typescript
// components/DataTable/index.tsx
import React, { useMemo } from 'react'
import { Table, TableProps } from 'antd'
import { useVirtualList } from '@/hooks/useVirtualList'

interface DataTableProps<T> extends Omit<TableProps<T>, 'dataSource'> {
  data: T[]
  virtualScrolling?: boolean
  onRowClick?: (record: T, index: number) => void
}

function DataTable<T extends Record<string, any>>({
  data,
  virtualScrolling = false,
  onRowClick,
  ...tableProps
}: DataTableProps<T>) {
  // 虚拟滚动优化
  const { virtualItems, containerRef } = useVirtualList({
    items: data,
    enabled: virtualScrolling,
    itemHeight: 54
  })

  const processedData = useMemo(() => {
    return virtualScrolling ? virtualItems : data
  }, [data, virtualItems, virtualScrolling])

  const handleRow = (record: T, index: number) => ({
    onClick: () => onRowClick?.(record, index)
  })

  return (
    <div ref={containerRef}>
      <Table
        {...tableProps}
        dataSource={processedData}
        onRow={handleRow}
        pagination={virtualScrolling ? false : tableProps.pagination}
      />
    </div>
  )
}

export default DataTable
```

### 21. React状态管理最佳实践

**问题：** 请对比Redux Toolkit、Zustand、Jotai等状态管理方案？

**Zustand轻量级状态管理：**

```typescript
// stores/appStore.ts
import { create } from 'zustand'
import { devtools, persist } from 'zustand/middleware'
import { immer } from 'zustand/middleware/immer'

interface AppState {
  // State
  theme: 'light' | 'dark'
  language: string
  user: User | null
  
  // Actions
  setTheme: (theme: 'light' | 'dark') => void
  setLanguage: (language: string) => void
  setUser: (user: User | null) => void
  logout: () => void
}

export const useAppStore = create<AppState>()(
  devtools(
    persist(
      immer((set) => ({
        // Initial state
        theme: 'light',
        language: 'zh-CN',
        user: null,

        // Actions
        setTheme: (theme) => set((state) => {
          state.theme = theme
        }),

        setLanguage: (language) => set((state) => {
          state.language = language
        }),

        setUser: (user) => set((state) => {
          state.user = user
        }),

        logout: () => set((state) => {
          state.user = null
          // 清理其他相关状态
        })
      })),
      {
        name: 'app-storage',
        partialize: (state) => ({
          theme: state.theme,
          language: state.language
        })
      }
    )
  )
)
```

### 22. React性能优化工程实践

**问题：** 在React项目中，如何进行系统性的性能优化？

**React性能优化策略：**

```typescript
// hooks/useOptimizedQuery.ts
import { useQuery, UseQueryOptions } from '@tanstack/react-query'
import { useMemo } from 'react'

interface OptimizedQueryOptions<T> extends UseQueryOptions<T> {
  // 自动重试配置
  retryConfig?: {
    attempts: number
    delay: number
  }
  // 缓存配置
  cacheConfig?: {
    staleTime: number
    cacheTime: number
  }
}

export function useOptimizedQuery<T>(
  key: string[],
  queryFn: () => Promise<T>,
  options: OptimizedQueryOptions<T> = {}
) {
  const {
    retryConfig = { attempts: 3, delay: 1000 },
    cacheConfig = { staleTime: 5 * 60 * 1000, cacheTime: 10 * 60 * 1000 },
    ...queryOptions
  } = options

  return useQuery({
    queryKey: key,
    queryFn,
    retry: retryConfig.attempts,
    retryDelay: retryConfig.delay,
    staleTime: cacheConfig.staleTime,
    cacheTime: cacheConfig.cacheTime,
    ...queryOptions
  })
}

// components/OptimizedList.tsx
import React, { useMemo, useCallback } from 'react'
import { FixedSizeList as List } from 'react-window'

interface OptimizedListProps<T> {
  items: T[]
  itemHeight: number
  renderItem: (item: T, index: number) => React.ReactNode
  keyExtractor: (item: T, index: number) => string
}

function OptimizedList<T>({
  items,
  itemHeight,
  renderItem,
  keyExtractor
}: OptimizedListProps<T>) {
  // {{ AURA-X: Add - React虚拟列表优化. Source: context7-mcp on 'React Virtualization'. }}
  const ItemRenderer = useCallback(({ index, style }: any) => {
    const item = items[index]
    return (
      <div style={style} key={keyExtractor(item, index)}>
        {renderItem(item, index)}
      </div>
    )
  }, [items, renderItem, keyExtractor])

  const listHeight = useMemo(() => 
    Math.min(items.length * itemHeight, 400)
  , [items.length, itemHeight])

  return (
    <List
      height={listHeight}
      itemCount={items.length}
      itemSize={itemHeight}
      itemData={items}
    >
      {ItemRenderer}
    </List>
  )
}

export default React.memo(OptimizedList)
```

## 💡 最新技术趋势与面试重点

### 23. Rust工具链在前端的应用

**问题：** 请谈谈Rust工具链（如swc、Rspack、Biome）在前端工程化中的优势？

**Rust工具链优势分析：**
- **性能优势**：编译型语言，运行速度比Node.js快10-100倍
- **内存安全**：避免内存泄漏和悬空指针
- **并发能力**：天然支持多线程并行处理

**SWC配置示例：**
```javascript
// .swcrc
{
  "jsc": {
    "target": "es2020",
    "parser": {
      "syntax": "typescript",
      "tsx": true,
      "decorators": true
    },
    "transform": {
      "react": {
        "runtime": "automatic"
      }
    }
  },
  "module": {
    "type": "es6"
  },
  "minify": true
}
```

### 17. 新一代包管理器对比

**问题：** pnpm、yarn、npm的性能和特性对比？

**包管理器对比分析：**

| 特性 | npm | yarn | pnpm |
|------|-----|------|------|
| **安装速度** | 慢 | 快 | 最快 |
| **磁盘空间** | 大 | 大 | 最小(硬链接) |
| **lock文件** | package-lock.json | yarn.lock | pnpm-lock.yaml |
| **Monorepo** | 支持 | 优秀 | 原生支持 |
| **安全性** | 一般 | 好 | 最好(严格依赖) |

**pnpm核心优势：**
```bash
# 内容寻址存储，节省磁盘空间
pnpm install
# 相同版本的包只存储一份，通过硬链接共享

# 严格的依赖管理
# 只能访问package.json中声明的依赖
```

## 🎯 面试高频考点总结

### 关键技术要点

1. **构建工具选型**：根据项目规模、团队技术栈、性能要求选择合适工具
2. **性能优化**：从构建时和运行时两个维度进行优化
3. **代码质量**：建立完整的代码规范和自动化检查流程
4. **架构设计**：Monorepo和微前端的适用场景和实践经验
5. **DevOps实践**：CI/CD流程设计和自动化部署能力

### 面试回答策略

- **理论+实践**：不仅要知道原理，更要有实际项目经验
- **对比分析**：能够客观比较不同技术方案的优缺点
- **问题解决**：具备分析和解决实际工程问题的能力
- **技术趋势**：了解最新的技术发展和工具演进

---

> **提示：** 前端工程化是一个快速发展的领域，建议关注最新的技术动态，在实际项目中积累经验，培养工程思维和解决问题的能力。