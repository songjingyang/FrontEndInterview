# 前端算法面试题详解

## 目录
1. [时间复杂度与空间复杂度详解](#时间复杂度与空间复杂度详解)
2. [经典算法题：数组去重](#经典算法题数组去重)
3. [前端常见算法问题](#前端常见算法问题)
4. [实际应用场景](#实际应用场景)

---

## 时间复杂度与空间复杂度详解

### 什么是时间复杂度？

时间复杂度是算法执行时间随输入规模增长的变化趋势，用大O表示法描述算法在最坏情况下的执行效率。

#### 常见时间复杂度（从优到劣）：

1. **O(1) - 常数时间复杂度**
   ```javascript
   // 访问数组元素
   function getFirst(arr) {
     return arr[0]; // 无论数组多大，执行时间都相同
   }
   ```

2. **O(log n) - 对数时间复杂度**
   ```javascript
   // 二分查找
   function binarySearch(arr, target) {
     let left = 0, right = arr.length - 1;
     while (left <= right) {
       const mid = Math.floor((left + right) / 2);
       if (arr[mid] === target) return mid;
       else if (arr[mid] < target) left = mid + 1;
       else right = mid - 1;
     }
     return -1;
   }
   ```

3. **O(n) - 线性时间复杂度**
   ```javascript
   // 遍历数组
   function findMax(arr) {
     let max = arr[0];
     for (let i = 1; i < arr.length; i++) { // 需要遍历每个元素
       if (arr[i] > max) max = arr[i];
     }
     return max;
   }
   ```

4. **O(n log n) - 线性对数时间复杂度**
   ```javascript
   // 归并排序、快速排序（平均情况）
   function mergeSort(arr) {
     if (arr.length <= 1) return arr;
     
     const mid = Math.floor(arr.length / 2);
     const left = mergeSort(arr.slice(0, mid));   // 递归分解 log n 层
     const right = mergeSort(arr.slice(mid));     // 每层合并需要 O(n)
     
     return merge(left, right);
   }
   ```

5. **O(n²) - 平方时间复杂度**
   ```javascript
   // 冒泡排序
   function bubbleSort(arr) {
     for (let i = 0; i < arr.length; i++) {      // 外层循环 n 次
       for (let j = 0; j < arr.length - i - 1; j++) { // 内层循环 n 次
         if (arr[j] > arr[j + 1]) {
           [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
         }
       }
     }
     return arr;
   }
   ```

### 什么是空间复杂度？

空间复杂度是算法执行过程中所需要的额外存储空间随输入规模增长的变化趋势。

#### 常见空间复杂度：

1. **O(1) - 常数空间复杂度**
   ```javascript
   // 原地排序（冒泡排序）
   function bubbleSort(arr) {
     // 只使用固定数量的变量，不依赖输入规模
     for (let i = 0; i < arr.length; i++) {
       for (let j = 0; j < arr.length - i - 1; j++) {
         if (arr[j] > arr[j + 1]) {
           [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]; // 原地交换
         }
       }
     }
     return arr;
   }
   ```

2. **O(n) - 线性空间复杂度**
   ```javascript
   // 需要额外数组存储结果
   function createCopy(arr) {
     const copy = []; // 新数组的大小与输入成正比
     for (let i = 0; i < arr.length; i++) {
       copy.push(arr[i]);
     }
     return copy;
   }
   ```

3. **O(log n) - 对数空间复杂度**
   ```javascript
   // 递归调用栈（二分查找递归版本）
   function binarySearchRecursive(arr, target, left = 0, right = arr.length - 1) {
     if (left > right) return -1;
     
     const mid = Math.floor((left + right) / 2);
     if (arr[mid] === target) return mid;
     
     // 递归调用栈深度为 log n
     return arr[mid] < target 
       ? binarySearchRecursive(arr, target, mid + 1, right)
       : binarySearchRecursive(arr, target, left, mid - 1);
   }
   ```

---

## 经典算法题：数组去重

这是前端面试中最常见的算法题之一，让我们通过多种解法来深入理解复杂度分析。

### 方法一：双重循环 - 暴力解法

```javascript
/**
 * 双重循环去重
 * 时间复杂度：O(n²) - 外层循环n次，内层最多循环n次
 * 空间复杂度：O(n) - 最坏情况下结果数组包含所有元素
 */
function removeDuplicates1(arr) {
  const result = [];
  
  for (let i = 0; i < arr.length; i++) {      // 外层循环：O(n)
    let isDuplicate = false;
    
    for (let j = 0; j < result.length; j++) { // 内层循环：最坏O(n)
      if (arr[i] === result[j]) {
        isDuplicate = true;
        break;
      }
    }
    
    if (!isDuplicate) {
      result.push(arr[i]);
    }
  }
  
  return result;
}

// 测试用例
console.log(removeDuplicates1([1, 2, 2, 3, 4, 4, 5])); // [1, 2, 3, 4, 5]
```

**复杂度分析：**
- **时间复杂度：O(n²)** - 对于每个元素，都要在结果数组中查找是否已存在
- **空间复杂度：O(n)** - 需要一个额外的结果数组

### 方法二：Set数据结构

```javascript
/**
 * 使用Set去重
 * 时间复杂度：O(n) - Set的add操作是O(1)，总共执行n次
 * 空间复杂度：O(n) - Set存储去重后的元素
 */
function removeDuplicates2(arr) {
  return [...new Set(arr)]; // Set会自动去重，扩展运算符转为数组
}

// ES6之前的写法
function removeDuplicates2Old(arr) {
  const set = new Set();
  const result = [];
  
  for (let i = 0; i < arr.length; i++) { // O(n)
    if (!set.has(arr[i])) {              // Set的has操作：O(1)
      set.add(arr[i]);                   // Set的add操作：O(1)
      result.push(arr[i]);
    }
  }
  
  return result;
}

console.log(removeDuplicates2([1, 2, 2, 3, 4, 4, 5])); // [1, 2, 3, 4, 5]
```

**复杂度分析：**
- **时间复杂度：O(n)** - Set的查找和插入都是O(1)，遍历n次
- **空间复杂度：O(n)** - Set需要存储所有不重复元素

### 方法三：Map记录出现次数

```javascript
/**
 * 使用Map记录元素出现次数
 * 时间复杂度：O(n) - 两次遍历，每次O(n)
 * 空间复杂度：O(n) - Map存储元素计数
 */
function removeDuplicates3(arr) {
  const countMap = new Map();
  const result = [];
  
  // 第一次遍历：统计每个元素出现次数
  for (let item of arr) {               // O(n)
    countMap.set(item, (countMap.get(item) || 0) + 1); // Map操作：O(1)
  }
  
  // 第二次遍历：只保留第一次出现的元素
  for (let item of arr) {               // O(n)
    if (countMap.get(item) > 0) {
      result.push(item);
      countMap.set(item, 0); // 标记为已处理
    }
  }
  
  return result;
}

console.log(removeDuplicates3([1, 2, 2, 3, 4, 4, 5])); // [1, 2, 3, 4, 5]
```

### 方法四：排序后去重

```javascript
/**
 * 先排序再去重
 * 时间复杂度：O(n log n) - 主要是排序的复杂度
 * 空间复杂度：O(1) 或 O(n) - 取决于排序算法和是否原地修改
 */
function removeDuplicates4(arr) {
  if (arr.length === 0) return [];
  
  const sorted = [...arr].sort();      // 排序：O(n log n)，复制：O(n)
  const result = [sorted[0]];
  
  for (let i = 1; i < sorted.length; i++) { // 去重：O(n)
    if (sorted[i] !== sorted[i - 1]) {
      result.push(sorted[i]);
    }
  }
  
  return result;
}

console.log(removeDuplicates4([1, 4, 2, 2, 3, 4, 5])); // [1, 2, 3, 4, 5]
```

### 方法五：indexOf查找

```javascript
/**
 * 使用indexOf查找首次出现位置
 * 时间复杂度：O(n²) - filter是O(n)，indexOf是O(n)
 * 空间复杂度：O(n) - 新数组存储结果
 */
function removeDuplicates5(arr) {
  return arr.filter((item, index) => {
    return arr.indexOf(item) === index; // indexOf：O(n)
  }); // filter遍历：O(n)
}

console.log(removeDuplicates5([1, 2, 2, 3, 4, 4, 5])); // [1, 2, 3, 4, 5]
```

### 性能对比测试

```javascript
/**
 * 性能测试函数
 */
function performanceTest() {
  const testData = [];
  // 生成包含重复元素的大数组
  for (let i = 0; i < 10000; i++) {
    testData.push(Math.floor(Math.random() * 1000));
  }
  
  const methods = [
    { name: '双重循环', fn: removeDuplicates1 },
    { name: 'Set去重', fn: removeDuplicates2 },
    { name: 'Map计数', fn: removeDuplicates3 },
    { name: '排序去重', fn: removeDuplicates4 },
    { name: 'indexOf', fn: removeDuplicates5 }
  ];
  
  methods.forEach(({ name, fn }) => {
    const start = performance.now();
    const result = fn([...testData]); // 避免修改原数组
    const end = performance.now();
    
    console.log(`${name}: ${(end - start).toFixed(2)}ms, 结果长度: ${result.length}`);
  });
}

// 运行性能测试
// performanceTest();
```

### 复杂度对比总结

| 方法 | 时间复杂度 | 空间复杂度 | 优点 | 缺点 |
|------|------------|------------|------|------|
| 双重循环 | O(n²) | O(n) | 逻辑简单，无需额外数据结构 | 效率低，不适合大数据量 |
| Set去重 | O(n) | O(n) | 效率高，代码简洁 | 需要ES6支持 |
| Map计数 | O(n) | O(n) | 效率高，可扩展功能 | 代码相对复杂 |
| 排序去重 | O(n log n) | O(n) | 结果有序 | 改变原有顺序 |
| indexOf | O(n²) | O(n) | 一行代码解决 | 效率低 |

**最佳实践建议：**
- 小数据量（< 100）：任何方法都可以
- 大数据量：优先使用Set去重
- 需要保持原始顺序：Set或Map方法
- 需要结果有序：排序去重
- 兼容性要求：双重循环（但要注意性能）

---

## 前端常见算法问题

### 1. 防抖(Debounce)实现

```javascript
/**
 * 防抖函数：在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时
 * 应用场景：搜索框输入、按钮点击防止重复提交
 * 时间复杂度：O(1)
 * 空间复杂度：O(1)
 */
function debounce(func, wait, immediate = false) {
  let timeout;
  
  return function executedFunction(...args) {
    const later = () => {
      timeout = null;
      if (!immediate) func.apply(this, args);
    };
    
    const callNow = immediate && !timeout;
    
    clearTimeout(timeout);           // 清除之前的定时器
    timeout = setTimeout(later, wait); // 设置新的定时器
    
    if (callNow) func.apply(this, args);
  };
}

// 使用示例：搜索框防抖
const searchInput = document.getElementById('search');
const debouncedSearch = debounce((e) => {
  console.log('搜索:', e.target.value);
  // 实际的搜索逻辑
}, 300);

searchInput.addEventListener('input', debouncedSearch);
```

### 2. 节流(Throttle)实现

```javascript
/**
 * 节流函数：限制函数在指定时间段内只能执行一次
 * 应用场景：滚动事件、鼠标移动事件
 * 时间复杂度：O(1)
 * 空间复杂度：O(1)
 */
function throttle(func, limit) {
  let inThrottle;
  
  return function executedFunction(...args) {
    if (!inThrottle) {
      func.apply(this, args);
      inThrottle = true;
      setTimeout(() => inThrottle = false, limit);
    }
  };
}

// 使用示例：滚动事件节流
const throttledScroll = throttle(() => {
  console.log('滚动位置:', window.scrollY);
}, 100);

window.addEventListener('scroll', throttledScroll);
```

### 3. 深拷贝实现

```javascript
/**
 * 深拷贝函数：完整复制对象的所有层级
 * 时间复杂度：O(n) - n为对象中所有属性的总数
 * 空间复杂度：O(n) - 递归调用栈 + 新对象存储
 */
function deepClone(obj, hash = new WeakMap()) {
  // 基本类型直接返回
  if (obj === null || typeof obj !== 'object') {
    return obj;
  }
  
  // 处理Date对象
  if (obj instanceof Date) {
    return new Date(obj.getTime());
  }
  
  // 处理RegExp对象
  if (obj instanceof RegExp) {
    return new RegExp(obj);
  }
  
  // 处理循环引用
  if (hash.has(obj)) {
    return hash.get(obj);
  }
  
  // 创建新对象，保持原型链
  const cloneObj = new obj.constructor();
  hash.set(obj, cloneObj);
  
  // 递归拷贝属性
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      cloneObj[key] = deepClone(obj[key], hash);
    }
  }
  
  return cloneObj;
}

// 测试深拷贝
const original = {
  name: 'Tom',
  age: 25,
  hobbies: ['reading', 'coding'],
  address: {
    city: 'Beijing',
    country: 'China'
  },
  date: new Date(),
  regex: /test/g
};

const cloned = deepClone(original);
console.log(cloned);
console.log(cloned === original); // false
console.log(cloned.address === original.address); // false
```

### 4. 函数柯里化实现

```javascript
/**
 * 柯里化：将多参数函数转换为单参数函数的序列
 * 时间复杂度：O(1) - 每次调用
 * 空间复杂度：O(n) - n为参数个数（闭包存储）
 */
function curry(fn) {
  return function curried(...args) {
    // 如果参数数量足够，直接调用原函数
    if (args.length >= fn.length) {
      return fn.apply(this, args);
    }
    
    // 否则返回新函数，等待更多参数
    return function(...nextArgs) {
      return curried.apply(this, args.concat(nextArgs));
    };
  };
}

// 使用示例
function add(a, b, c) {
  return a + b + c;
}

const curriedAdd = curry(add);
console.log(curriedAdd(1)(2)(3)); // 6
console.log(curriedAdd(1, 2)(3)); // 6
console.log(curriedAdd(1)(2, 3)); // 6
```

### 5. 二分查找在前端中的应用

```javascript
/**
 * 二分查找：在排序数组中查找目标值
 * 时间复杂度：O(log n)
 * 空间复杂度：O(1)
 */
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;
  
  while (left <= right) {
    const mid = Math.floor((left + right) / 2);
    
    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }
  
  return -1; // 未找到
}

/**
 * 前端应用场景：虚拟滚动中查找可视区域元素
 */
class VirtualList {
  constructor(items, itemHeight, containerHeight) {
    this.items = items;
    this.itemHeight = itemHeight;
    this.containerHeight = containerHeight;
    this.visibleCount = Math.ceil(containerHeight / itemHeight);
  }
  
  // 使用二分查找确定滚动位置对应的起始索引
  findStartIndex(scrollTop) {
    let left = 0;
    let right = this.items.length - 1;
    
    while (left <= right) {
      const mid = Math.floor((left + right) / 2);
      const midPosition = mid * this.itemHeight;
      
      if (midPosition === scrollTop) {
        return mid;
      } else if (midPosition < scrollTop) {
        left = mid + 1;
      } else {
        right = mid - 1;
      }
    }
    
    return Math.max(0, right);
  }
  
  getVisibleItems(scrollTop) {
    const startIndex = this.findStartIndex(scrollTop);
    const endIndex = Math.min(
      startIndex + this.visibleCount + 1, 
      this.items.length
    );
    
    return this.items.slice(startIndex, endIndex);
  }
}
```

---

## 实际应用场景

### 1. React中的性能优化

```javascript
/**
 * 使用useMemo优化昂贵计算
 * 避免在每次渲染时重复执行复杂算法
 */
import React, { useMemo } from 'react';

function ExpensiveList({ items, filter }) {
  // 使用useMemo缓存过滤和排序结果
  const processedItems = useMemo(() => {
    console.log('重新计算...'); // 只在items或filter变化时执行
    
    return items
      .filter(item => item.name.includes(filter))  // O(n)
      .sort((a, b) => a.name.localeCompare(b.name)) // O(n log n)
      .map(item => ({                               // O(n)
        ...item,
        displayName: `${item.name} (${item.category})`
      }));
  }, [items, filter]); // 依赖数组
  
  return (
    <ul>
      {processedItems.map(item => (
        <li key={item.id}>{item.displayName}</li>
      ))}
    </ul>
  );
}
```

### 2. Vue中的计算属性优化

```javascript
/**
 * Vue计算属性自动缓存，避免重复计算
 */
export default {
  data() {
    return {
      products: [/* 大量产品数据 */],
      searchQuery: '',
      sortBy: 'name'
    };
  },
  
  computed: {
    // 计算属性会缓存结果，只在依赖变化时重新计算
    filteredAndSortedProducts() {
      let result = this.products;
      
      // 过滤：O(n)
      if (this.searchQuery) {
        result = result.filter(product => 
          product.name.toLowerCase().includes(this.searchQuery.toLowerCase())
        );
      }
      
      // 排序：O(n log n)
      result = result.sort((a, b) => {
        if (this.sortBy === 'name') {
          return a.name.localeCompare(b.name);
        } else if (this.sortBy === 'price') {
          return a.price - b.price;
        }
        return 0;
      });
      
      return result;
    }
  }
};
```

### 3. Web Worker处理大数据量

```javascript
/**
 * 使用Web Worker在后台线程处理大数据算法
 * 避免阻塞主线程UI渲染
 */

// main.js - 主线程
function processLargeDataset(data) {
  return new Promise((resolve, reject) => {
    const worker = new Worker('dataProcessor.js');
    
    worker.postMessage(data);
    
    worker.onmessage = function(e) {
      resolve(e.data);
      worker.terminate();
    };
    
    worker.onerror = function(error) {
      reject(error);
      worker.terminate();
    };
  });
}

// 使用示例
const largeArray = new Array(1000000).fill(0).map(() => Math.random());

processLargeDataset(largeArray)
  .then(result => {
    console.log('处理完成:', result);
    // 更新UI，不会造成页面卡顿
  })
  .catch(error => {
    console.error('处理失败:', error);
  });

// dataProcessor.js - Worker线程
self.onmessage = function(e) {
  const data = e.data;
  
  // 执行复杂的数据处理算法
  const result = data
    .filter(x => x > 0.5)           // O(n)
    .map(x => x * 2)                // O(n)
    .sort((a, b) => a - b)          // O(n log n)
    .reduce((sum, x) => sum + x, 0); // O(n)
  
  // 发送结果回主线程
  self.postMessage(result);
};
```

### 4. 前端缓存策略优化

```javascript
/**
 * LRU (Least Recently Used) 缓存实现
 * 用于优化API请求、图片加载等场景
 * 时间复杂度：get/put都是O(1)
 * 空间复杂度：O(capacity)
 */
class LRUCache {
  constructor(capacity) {
    this.capacity = capacity;
    this.cache = new Map(); // Map保持插入顺序
  }
  
  get(key) {
    if (this.cache.has(key)) {
      const value = this.cache.get(key);
      // 重新插入到末尾（最近使用）
      this.cache.delete(key);
      this.cache.set(key, value);
      return value;
    }
    return -1;
  }
  
  put(key, value) {
    if (this.cache.has(key)) {
      // 更新已存在的key
      this.cache.delete(key);
    } else if (this.cache.size >= this.capacity) {
      // 删除最久未使用的项（第一个）
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }
    
    this.cache.set(key, value);
  }
}

// 应用示例：API请求缓存
class ApiCache {
  constructor(maxSize = 100) {
    this.cache = new LRUCache(maxSize);
  }
  
  async fetchData(url) {
    // 先检查缓存
    const cached = this.cache.get(url);
    if (cached !== -1) {
      console.log('从缓存获取:', url);
      return cached;
    }
    
    // 缓存未命中，发起请求
    try {
      console.log('发起新请求:', url);
      const response = await fetch(url);
      const data = await response.json();
      
      // 存入缓存
      this.cache.put(url, data);
      return data;
    } catch (error) {
      console.error('请求失败:', error);
      throw error;
    }
  }
}

const apiCache = new ApiCache(50);

// 使用示例
apiCache.fetchData('/api/users/1')
  .then(data => console.log(data));
```

### 算法在前端框架中的应用

#### React Fiber的调度算法
```javascript
/**
 * React Fiber使用时间切片和优先级调度
 * 核心思想：将大任务分解为小任务，避免长时间阻塞
 */

// 简化的时间切片概念实现
function workLoop(deadline) {
  let shouldYield = false;
  
  while (nextUnitOfWork && !shouldYield) {
    nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
    
    // 检查是否还有剩余时间
    shouldYield = deadline.timeRemaining() < 1;
  }
  
  if (nextUnitOfWork) {
    // 还有工作要做，下一帧继续
    requestIdleCallback(workLoop);
  }
}

requestIdleCallback(workLoop);
```

#### Vue 3响应式系统的依赖收集算法
```javascript
/**
 * Vue 3的响应式系统使用Proxy和Effect函数
 * 实现精确的依赖追踪和更新
 */

// 简化的响应式实现
let activeEffect = null;
const targetMap = new WeakMap();

function track(target, key) {
  if (!activeEffect) return;
  
  let depsMap = targetMap.get(target);
  if (!depsMap) {
    targetMap.set(target, (depsMap = new Map()));
  }
  
  let dep = depsMap.get(key);
  if (!dep) {
    depsMap.set(key, (dep = new Set()));
  }
  
  dep.add(activeEffect);
}

function trigger(target, key) {
  const depsMap = targetMap.get(target);
  if (!depsMap) return;
  
  const dep = depsMap.get(key);
  if (dep) {
    dep.forEach(effect => effect());
  }
}
```

---

## 总结

### 前端算法面试的关键点：

1. **理解复杂度概念**：能够分析和比较不同算法的时间空间复杂度
2. **掌握常见数据结构**：数组、对象、Map、Set的特性和使用场景
3. **熟悉前端特有场景**：防抖节流、深拷贝、虚拟滚动等
4. **性能优化思维**：知道何时使用缓存、Web Worker、时间切片等技术
5. **实际应用能力**：能将算法知识应用到具体的前端开发场景中

### 学习建议：

1. **从基础开始**：先理解时间空间复杂度，再学习具体算法
2. **多写多练**：亲自实现每个算法，理解其原理
3. **结合实践**：思考算法在实际项目中的应用场景
4. **性能测试**：学会使用浏览器工具测试和对比算法性能
5. **持续学习**：关注前端框架和工具中使用的新算法和优化技术

记住：算法不是为了炫技，而是为了解决实际问题和提升用户体验！