# å‰ç«¯æ€§èƒ½ä¼˜åŒ–é¢è¯•é¢˜

> **çŸ¥è¯†ä½“ç³»**: æ¶µç›–æ€§èƒ½æŒ‡æ ‡ã€æµ‹é‡å·¥å…·ã€ä¼˜åŒ–ç­–ç•¥ã€å®æˆ˜æ¡ˆä¾‹ç­‰å‰ç«¯æ€§èƒ½ä¼˜åŒ–å…¨æ–¹ä½å†…å®¹  
> **é€‚ç”¨çº§åˆ«**: ä¸­é«˜çº§å‰ç«¯å¼€å‘å·¥ç¨‹å¸ˆé¢è¯•

## ğŸ“‹ ç›®å½•

- [ä¸€ã€æ ¸å¿ƒæ€§èƒ½æŒ‡æ ‡](#ä¸€æ ¸å¿ƒæ€§èƒ½æŒ‡æ ‡)
- [äºŒã€æ€§èƒ½æµ‹é‡å·¥å…·ä¸æ–¹æ³•](#äºŒæ€§èƒ½æµ‹é‡å·¥å…·ä¸æ–¹æ³•)
- [ä¸‰ã€ç½‘ç»œå±‚é¢æ€§èƒ½ä¼˜åŒ–](#ä¸‰ç½‘ç»œå±‚é¢æ€§èƒ½ä¼˜åŒ–)
- [å››ã€æ¸²æŸ“æ€§èƒ½ä¼˜åŒ–](#å››æ¸²æŸ“æ€§èƒ½ä¼˜åŒ–)
- [äº”ã€è¿è¡Œæ—¶æ€§èƒ½ä¼˜åŒ–](#äº”è¿è¡Œæ—¶æ€§èƒ½ä¼˜åŒ–)
- [å…­ã€æ„å»ºä¸å·¥ç¨‹åŒ–ä¼˜åŒ–](#å…­æ„å»ºä¸å·¥ç¨‹åŒ–ä¼˜åŒ–)
- [ä¸ƒã€å†…å­˜æ€§èƒ½ä¼˜åŒ–](#ä¸ƒå†…å­˜æ€§èƒ½ä¼˜åŒ–)
- [å…«ã€æ€§èƒ½ç›‘æ§ä¸é¢„ç®—](#å…«æ€§èƒ½ç›‘æ§ä¸é¢„ç®—)
- [ä¹ã€å®æˆ˜æ¡ˆä¾‹åˆ†æ](#ä¹å®æˆ˜æ¡ˆä¾‹åˆ†æ)

---

## ä¸€ã€æ ¸å¿ƒæ€§èƒ½æŒ‡æ ‡

### Web Core Vitals è¯¦è§£

**1. Core Web Vitals ä¸‰å¤§æ ¸å¿ƒæŒ‡æ ‡**
```
Q: è¯¦ç»†è§£é‡Š Core Web Vitals çš„ä¸‰ä¸ªæ ¸å¿ƒæŒ‡æ ‡åŠå…¶ä¼˜åŒ–ç›®æ ‡ï¼Ÿ

A: Core Web Vitals æ ¸å¿ƒæŒ‡æ ‡ï¼š

1. **LCP (Largest Contentful Paint) - æœ€å¤§å†…å®¹ç»˜åˆ¶**
   - å®šä¹‰: è§†çª—å†…æœ€å¤§å¯è§å…ƒç´ çš„æ¸²æŸ“æ—¶é—´
   - ä¼˜åŒ–ç›®æ ‡: â‰¤ 2.5ç§’
   - å½±å“å› ç´ : æœåŠ¡å™¨å“åº”æ—¶é—´ã€èµ„æºåŠ è½½ã€æ¸²æŸ“é˜»å¡
   
2. **FID (First Input Delay) - é¦–æ¬¡è¾“å…¥å»¶è¿Ÿ**
   - å®šä¹‰: ç”¨æˆ·é¦–æ¬¡äº¤äº’åˆ°æµè§ˆå™¨å“åº”çš„æ—¶é—´
   - ä¼˜åŒ–ç›®æ ‡: â‰¤ 100æ¯«ç§’
   - å½±å“å› ç´ : JavaScript æ‰§è¡Œæ—¶é—´ã€ä¸»çº¿ç¨‹é˜»å¡
   
3. **CLS (Cumulative Layout Shift) - ç´¯ç§¯å¸ƒå±€åç§»**
   - å®šä¹‰: é¡µé¢åŠ è½½æœŸé—´æ„å¤–å¸ƒå±€åç§»çš„ç´¯ç§¯åˆ†æ•°
   - ä¼˜åŒ–ç›®æ ‡: â‰¤ 0.1
   - å½±å“å› ç´ : å›¾ç‰‡å°ºå¯¸ã€åŠ¨æ€å†…å®¹ã€å­—ä½“åŠ è½½

æµ‹é‡ä»£ç ç¤ºä¾‹ï¼š
import { getCLS, getFID, getLCP } from 'web-vitals';

getCLS(console.log); // Cumulative Layout Shift
getFID(console.log); // First Input Delay  
getLCP(console.log); // Largest Contentful Paint
```

**2. æ–°ä¸€ä»£æ€§èƒ½æŒ‡æ ‡**
```
Q: INP (Interaction to Next Paint) å¦‚ä½•æ›¿ä»£ FIDï¼Ÿæœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿ

A: INP vs FID å¯¹æ¯”ï¼š

**FID å±€é™æ€§:**
- åªæµ‹é‡é¦–æ¬¡äº¤äº’å»¶è¿Ÿ
- ä¸èƒ½åæ˜ é¡µé¢æ•´ä½“äº¤äº’æ€§èƒ½
- ä»…åœ¨æœ‰ç”¨æˆ·äº¤äº’æ—¶æ‰æœ‰æ•°æ®

**INP ä¼˜åŠ¿:**
- æµ‹é‡é¡µé¢ç”Ÿå‘½å‘¨æœŸå†…æ‰€æœ‰äº¤äº’çš„å“åº”æ€§
- é€‰æ‹©æœ€å·®çš„äº¤äº’å»¶è¿Ÿä½œä¸ºä»£è¡¨å€¼
- æ›´å…¨é¢åæ˜ ç”¨æˆ·ä½“éªŒ

INP æµ‹é‡å®ç°ï¼š
function measureINP() {
  let interactions = [];
  
  const observer = new PerformanceObserver((list) => {
    for (const entry of list.getEntries()) {
      if (entry.name === 'click' || entry.name === 'keydown') {
        interactions.push({
          startTime: entry.startTime,
          processingStart: entry.processingStart,
          processingEnd: entry.processingEnd,
          duration: entry.duration
        });
      }
    }
  });
  
  observer.observe({ type: 'event', buffered: true });
  
  // è®¡ç®— P75 äº¤äº’å»¶è¿Ÿ
  function calculateINP() {
    if (interactions.length === 0) return null;
    interactions.sort((a, b) => a.duration - b.duration);
    const p75Index = Math.floor(interactions.length * 0.75);
    return interactions[p75Index].duration;
  }
}
```

**3. å…¶ä»–å…³é”®æ€§èƒ½æŒ‡æ ‡**
```
Q: é™¤äº† Core Web Vitalsï¼Œè¿˜æœ‰å“ªäº›é‡è¦çš„æ€§èƒ½æŒ‡æ ‡ï¼Ÿ

A: é‡è¦è¡¥å……æŒ‡æ ‡ï¼š

1. **TTFB (Time to First Byte)**
   - å®šä¹‰: æœåŠ¡å™¨å“åº”ç¬¬ä¸€ä¸ªå­—èŠ‚çš„æ—¶é—´
   - ä¼˜åŒ–ç›®æ ‡: < 600ms
   - ä¼˜åŒ–ç‚¹: æœåŠ¡å™¨æ€§èƒ½ã€CDNã€æ•°æ®åº“æŸ¥è¯¢

2. **FCP (First Contentful Paint)**
   - å®šä¹‰: é¦–æ¬¡ç»˜åˆ¶ä»»ä½•å†…å®¹çš„æ—¶é—´
   - ä¼˜åŒ–ç›®æ ‡: < 1.8s
   - ä¼˜åŒ–ç‚¹: å…³é”®èµ„æºä¼˜å…ˆçº§ã€å†…è”å…³é”®CSS

3. **TTI (Time to Interactive)**
   - å®šä¹‰: é¡µé¢å˜ä¸ºå®Œå…¨å¯äº¤äº’çš„æ—¶é—´
   - ä¼˜åŒ–ç›®æ ‡: < 3.8s
   - ä¼˜åŒ–ç‚¹: JavaScript ä»£ç åˆ†å‰²ã€å»¶è¿Ÿéå…³é”®è„šæœ¬

4. **Speed Index**
   - å®šä¹‰: é¡µé¢å†…å®¹è§†è§‰å¡«å……é€Ÿåº¦
   - ä¼˜åŒ–ç›®æ ‡: < 3.4s
   - ä¼˜åŒ–ç‚¹: å…³é”®æ¸²æŸ“è·¯å¾„ä¼˜åŒ–ã€æ¸è¿›å¼åŠ è½½

æ€§èƒ½æŒ‡æ ‡ç›‘æ§å®ç°ï¼š
class PerformanceMonitor {
  constructor() {
    this.metrics = new Map();
    this.initializeObservers();
  }

  initializeObservers() {
    // Navigation Timing API
    window.addEventListener('load', () => {
      const navigation = performance.getEntriesByType('navigation')[0];
      this.metrics.set('TTFB', navigation.responseStart - navigation.requestStart);
      this.metrics.set('domLoaded', navigation.domContentLoadedEventEnd - navigation.navigationStart);
      this.metrics.set('pageLoaded', navigation.loadEventEnd - navigation.navigationStart);
    });

    // Paint Timing API
    const paintObserver = new PerformanceObserver((list) => {
      for (const entry of list.getEntries()) {
        this.metrics.set(entry.name, entry.startTime);
      }
    });
    paintObserver.observe({ entryTypes: ['paint'] });

    // Long Task API
    const longTaskObserver = new PerformanceObserver((list) => {
      for (const entry of list.getEntries()) {
        console.warn(`Long task detected: ${entry.duration}ms`);
      }
    });
    longTaskObserver.observe({ entryTypes: ['longtask'] });
  }

  getMetrics() {
    return Object.fromEntries(this.metrics);
  }
}
```

---

## äºŒã€æ€§èƒ½æµ‹é‡å·¥å…·ä¸æ–¹æ³•

### Performance API æ·±åº¦åº”ç”¨

**4. User Timing API å®æˆ˜åº”ç”¨**
```
Q: å¦‚ä½•ä½¿ç”¨ User Timing API è¿›è¡Œè‡ªå®šä¹‰æ€§èƒ½æµ‹é‡ï¼Ÿ

A: User Timing API ä½¿ç”¨æ–¹æ³•ï¼š

**åŸºç¡€æµ‹é‡:**
// æ ‡è®°æ—¶é—´ç‚¹
performance.mark('task-start');

// æ‰§è¡Œä»»åŠ¡
await expensiveOperation();

// æ ‡è®°ç»“æŸ
performance.mark('task-end');

// æµ‹é‡æ—¶é—´é—´éš”
performance.measure('task-duration', 'task-start', 'task-end');

// è·å–æµ‹é‡ç»“æœ
const measures = performance.getEntriesByName('task-duration');
console.log(`Task took: ${measures[0].duration}ms`);

**é«˜çº§æ€§èƒ½æµ‹é‡ç±»:**
class AdvancedPerformanceTimer {
  private marks: Map<string, number> = new Map();
  private measures: Map<string, number[]> = new Map();

  // å¼€å§‹æµ‹é‡
  start(name: string): void {
    const markName = `${name}-start`;
    performance.mark(markName);
    this.marks.set(name, performance.now());
  }

  // ç»“æŸæµ‹é‡
  end(name: string): number {
    const startTime = this.marks.get(name);
    if (!startTime) {
      throw new Error(`No start mark found for ${name}`);
    }

    const endTime = performance.now();
    const duration = endTime - startTime;
    
    // è®°å½•åˆ°å†å²
    if (!this.measures.has(name)) {
      this.measures.set(name, []);
    }
    this.measures.get(name)!.push(duration);

    // åˆ›å»º Performance Entry
    performance.mark(`${name}-end`);
    performance.measure(name, `${name}-start`, `${name}-end`);

    return duration;
  }

  // è·å–ç»Ÿè®¡ä¿¡æ¯
  getStats(name: string) {
    const durations = this.measures.get(name) || [];
    if (durations.length === 0) return null;

    const sorted = [...durations].sort((a, b) => a - b);
    return {
      count: durations.length,
      avg: durations.reduce((a, b) => a + b) / durations.length,
      min: sorted[0],
      max: sorted[sorted.length - 1],
      p50: sorted[Math.floor(sorted.length * 0.5)],
      p90: sorted[Math.floor(sorted.length * 0.9)],
      p99: sorted[Math.floor(sorted.length * 0.99)]
    };
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const timer = new AdvancedPerformanceTimer();

timer.start('api-call');
const response = await fetch('/api/data');
const data = await response.json();
const duration = timer.end('api-call');

console.log('APIè°ƒç”¨ç»Ÿè®¡:', timer.getStats('api-call'));
```

**5. Chrome DevTools æ€§èƒ½åˆ†æå®æˆ˜**
```
Q: å¦‚ä½•ä½¿ç”¨ Chrome DevTools è¿›è¡Œæ·±åº¦æ€§èƒ½åˆ†æï¼Ÿ

A: DevTools æ€§èƒ½åˆ†ææ­¥éª¤ï¼š

**1. Performance é¢æ¿åˆ†ææµç¨‹:**
1. æ‰“å¼€ DevTools -> Performance
2. å‹¾é€‰ Screenshotsã€Memoryã€Web Vitals
3. ç‚¹å‡»å½•åˆ¶ï¼Œæ“ä½œé¡µé¢ï¼Œåœæ­¢å½•åˆ¶
4. åˆ†æç»“æœï¼š

å…³é”®åˆ†æç‚¹ï¼š
- Main Thread: ä¸»çº¿ç¨‹æ´»åŠ¨ï¼ŒæŸ¥æ‰¾é•¿ä»»åŠ¡
- Network: ç½‘ç»œè¯·æ±‚ç€‘å¸ƒå›¾
- Frames: å¸§ç‡åˆ†æï¼ŒæŸ¥æ‰¾æ‰å¸§
- Timings: FCPã€LCPç­‰å…³é”®æ—¶é—´ç‚¹

**2. Memory é¢æ¿å†…å­˜åˆ†æ:**
// å†…å­˜å¿«ç…§åˆ†æä»£ç 
class MemoryAnalyzer {
  takeSnapshot(label: string) {
    console.log(`ğŸ“¸ Memory Snapshot: ${label}`);
    console.log(`Used: ${(performance.memory.usedJSHeapSize / 1024 / 1024).toFixed(2)}MB`);
    console.log(`Total: ${(performance.memory.totalJSHeapSize / 1024 / 1024).toFixed(2)}MB`);
    console.log(`Limit: ${(performance.memory.jsHeapSizeLimit / 1024 / 1024).toFixed(2)}MB`);
  }

  monitorMemoryLeaks() {
    let baseline = performance.memory.usedJSHeapSize;
    
    setInterval(() => {
      const current = performance.memory.usedJSHeapSize;
      const growth = ((current - baseline) / 1024 / 1024).toFixed(2);
      
      if (parseFloat(growth) > 10) { // å¢é•¿è¶…è¿‡10MB
        console.warn(`âš ï¸ Potential memory leak detected: +${growth}MB`);
      }
      
      baseline = current;
    }, 30000); // æ¯30ç§’æ£€æŸ¥ä¸€æ¬¡
  }
}

**3. Lighthouse ç¨‹åºåŒ–æ€§èƒ½å®¡è®¡:**
// ä½¿ç”¨ Lighthouse CI è¿›è¡Œè‡ªåŠ¨åŒ–æ€§èƒ½æµ‹è¯•
const lighthouse = require('lighthouse');
const chromeLauncher = require('chrome-launcher');

async function runLighthouseAudit(url) {
  const chrome = await chromeLauncher.launch({chromeFlags: ['--headless']});
  const options = {
    logLevel: 'info',
    output: 'json',
    onlyCategories: ['performance'],
    port: chrome.port
  };

  const runnerResult = await lighthouse(url, options);
  const reportJson = runnerResult.report;
  const results = JSON.parse(reportJson);

  await chrome.kill();

  // æå–å…³é”®æ€§èƒ½æŒ‡æ ‡
  const metrics = results.audits;
  return {
    lcp: metrics['largest-contentful-paint'].numericValue,
    fid: metrics['max-potential-fid'].numericValue,
    cls: metrics['cumulative-layout-shift'].numericValue,
    fcp: metrics['first-contentful-paint'].numericValue,
    speed_index: metrics['speed-index'].numericValue,
    performance_score: results.categories.performance.score * 100
  };
}
```

### æ€§èƒ½ç›‘æ§è‡ªåŠ¨åŒ–

**6. çœŸå®ç”¨æˆ·ç›‘æ§ (RUM) å®ç°**
```
Q: å¦‚ä½•å®ç°ä¸€å¥—å®Œæ•´çš„çœŸå®ç”¨æˆ·æ€§èƒ½ç›‘æ§ç³»ç»Ÿï¼Ÿ

A: RUM ç›‘æ§ç³»ç»Ÿå®ç°ï¼š

class RealUserMonitoring {
  private endpoint: string;
  private sampleRate: number;
  private sessionId: string;

  constructor(config: {endpoint: string, sampleRate?: number}) {
    this.endpoint = config.endpoint;
    this.sampleRate = config.sampleRate || 0.1; // 10% é‡‡æ ·ç‡
    this.sessionId = this.generateSessionId();
    
    if (Math.random() < this.sampleRate) {
      this.initializeMonitoring();
    }
  }

  private initializeMonitoring() {
    // ç›‘æ§é¡µé¢åŠ è½½æ€§èƒ½
    this.monitorPageLoad();
    
    // ç›‘æ§ç”¨æˆ·äº¤äº’æ€§èƒ½
    this.monitorInteractions();
    
    // ç›‘æ§èµ„æºåŠ è½½æ€§èƒ½
    this.monitorResources();
    
    // ç›‘æ§é”™è¯¯å’Œå¼‚å¸¸
    this.monitorErrors();
  }

  private monitorPageLoad() {
    window.addEventListener('load', () => {
      // ç­‰å¾… LCP ç¨³å®š
      setTimeout(() => {
        const navigation = performance.getEntriesByType('navigation')[0] as PerformanceNavigationTiming;
        const paintEntries = performance.getEntriesByType('paint');
        
        const metrics = {
          type: 'page-load',
          url: window.location.href,
          sessionId: this.sessionId,
          timestamp: Date.now(),
          metrics: {
            // å¯¼èˆªæ—¶é—´
            dns: navigation.domainLookupEnd - navigation.domainLookupStart,
            tcp: navigation.connectEnd - navigation.connectStart,
            ttfb: navigation.responseStart - navigation.requestStart,
            domLoad: navigation.domContentLoadedEventEnd - navigation.navigationStart,
            pageLoad: navigation.loadEventEnd - navigation.navigationStart,
            
            // ç»˜åˆ¶æ—¶é—´
            fp: paintEntries.find(entry => entry.name === 'first-paint')?.startTime,
            fcp: paintEntries.find(entry => entry.name === 'first-contentful-paint')?.startTime,
          },
          userAgent: navigator.userAgent,
          connection: this.getConnectionInfo()
        };

        this.sendMetrics(metrics);
      }, 3000);
    });
  }

  private monitorInteractions() {
    let interactionId = 0;
    
    const observer = new PerformanceObserver((list) => {
      for (const entry of list.getEntries()) {
        if (entry.duration > 100) { // åªè®°å½•æ…¢äº¤äº’
          this.sendMetrics({
            type: 'interaction',
            sessionId: this.sessionId,
            interactionId: ++interactionId,
            timestamp: Date.now(),
            metrics: {
              name: entry.name,
              duration: entry.duration,
              startTime: entry.startTime,
              processingStart: entry.processingStart,
              processingEnd: entry.processingEnd
            }
          });
        }
      }
    });

    observer.observe({ type: 'event', buffered: true });
  }

  private getConnectionInfo() {
    const connection = (navigator as any).connection;
    if (!connection) return null;
    
    return {
      effectiveType: connection.effectiveType,
      downlink: connection.downlink,
      rtt: connection.rtt,
      saveData: connection.saveData
    };
  }

  private async sendMetrics(data: any) {
    try {
      // ä½¿ç”¨ sendBeacon ç¡®ä¿æ•°æ®å‘é€
      if (navigator.sendBeacon) {
        navigator.sendBeacon(this.endpoint, JSON.stringify(data));
      } else {
        fetch(this.endpoint, {
          method: 'POST',
          body: JSON.stringify(data),
          headers: {'Content-Type': 'application/json'},
          keepalive: true
        });
      }
    } catch (error) {
      console.error('Failed to send metrics:', error);
    }
  }
}

// åˆå§‹åŒ–ç›‘æ§
const rum = new RealUserMonitoring({
  endpoint: '/api/metrics',
  sampleRate: 0.1
});
```

---

## ä¸‰ã€ç½‘ç»œå±‚é¢æ€§èƒ½ä¼˜åŒ–

### HTTP åè®®ä¼˜åŒ–

**7. HTTP/2 å’Œ HTTP/3 æ€§èƒ½ä¼˜åŠ¿**
```
Q: HTTP/2 å’Œ HTTP/3 ç›¸æ¯” HTTP/1.1 æœ‰å“ªäº›æ€§èƒ½ä¼˜åŠ¿ï¼Ÿå¦‚ä½•ä¼˜åŒ–ï¼Ÿ

A: HTTP ç‰ˆæœ¬æ€§èƒ½å¯¹æ¯”ï¼š

**HTTP/1.1 é™åˆ¶:**
- é˜Ÿå¤´é˜»å¡ (Head-of-Line Blocking)
- è¿æ¥æ•°é™åˆ¶ (é€šå¸¸6ä¸ªå¹¶å‘è¿æ¥)
- æ— å¤´éƒ¨å‹ç¼©
- æ— æœåŠ¡å™¨æ¨é€

**HTTP/2 ä¼˜åŠ¿:**
1. **å¤šè·¯å¤ç”¨**: å•è¿æ¥å¹¶å‘å¤„ç†å¤šä¸ªè¯·æ±‚
2. **å¤´éƒ¨å‹ç¼©**: HPACK ç®—æ³•å‡å°‘å¤´éƒ¨å¤§å°
3. **æœåŠ¡å™¨æ¨é€**: ä¸»åŠ¨æ¨é€å…³é”®èµ„æº
4. **è¯·æ±‚ä¼˜å…ˆçº§**: å…³é”®èµ„æºä¼˜å…ˆåŠ è½½

HTTP/2 ä¼˜åŒ–ç­–ç•¥ï¼š
// 1. é¿å…åŸŸååˆ†ç‰‡ (Domain Sharding)
// HTTP/1.1 æ—¶ä»£çš„ä¼˜åŒ–åœ¨ HTTP/2 ä¸­åè€Œæœ‰å®³
// é”™è¯¯åšæ³•
const domains = ['cdn1.example.com', 'cdn2.example.com', 'cdn3.example.com'];

// HTTP/2 æ­£ç¡®åšæ³• - ä½¿ç”¨å•ä¸€åŸŸå
const optimizedLoader = {
  loadResources(urls) {
    // HTTP/2 å¯ä»¥é«˜æ•ˆå¤„ç†å¤§é‡å¹¶å‘è¯·æ±‚
    return Promise.all(urls.map(url => fetch(url)));
  },
  
  // 2. åˆç†ä½¿ç”¨æœåŠ¡å™¨æ¨é€
  enableServerPush() {
    // æœåŠ¡å™¨ç«¯é…ç½®ç¤ºä¾‹ (nginx)
    /*
    location / {
      http2_push /css/critical.css;
      http2_push /js/critical.js;
      http2_push /fonts/main.woff2;
    }
    */
  }
};

**HTTP/3 (QUIC) ä¼˜åŠ¿:**
1. **0-RTT**: é›¶å¾€è¿”æ—¶é—´è¿æ¥
2. **æ— é˜Ÿå¤´é˜»å¡**: åŸºäº UDPï¼Œæµçº§åˆ«ç‹¬ç«‹
3. **è¿æ¥è¿ç§»**: ç½‘ç»œåˆ‡æ¢æ—¶ä¿æŒè¿æ¥
4. **å†…ç½®åŠ å¯†**: é»˜è®¤ TLS 1.3

HTTP/3 æ£€æµ‹å’Œä¼˜åŒ–ï¼š
class HTTP3Detector {
  static async checkSupport() {
    try {
      const response = await fetch('/api/test', {
        // é€šè¿‡ Alt-Svc å¤´æ£€æµ‹ HTTP/3 æ”¯æŒ
        headers: {'Alt-Used': 'h3-29'}
      });
      
      return response.headers.get('alt-svc')?.includes('h3');
    } catch {
      return false;
    }
  }

  static optimizeForHTTP3() {
    // HTTP/3 ä¼˜åŒ–å»ºè®®
    return {
      // 1. å‡å°‘è¿æ¥æ•°ï¼Œåˆ©ç”¨å¤šè·¯å¤ç”¨
      maxConcurrentConnections: 1,
      
      // 2. ä¼˜åŒ– TLS é…ç½®
      tlsConfig: {
        earlyData: true, // å¯ç”¨ 0-RTT
        sessionResumption: true
      },
      
      // 3. é¢„è¿æ¥å…³é”®åŸŸå
      preconnectDomains: ['api.example.com', 'cdn.example.com']
    };
  }
}
```

**8. èµ„æºå‹ç¼©ä¸ç¼–ç ä¼˜åŒ–**
```
Q: Gzipã€Brotliã€WebP ç­‰å‹ç¼©æŠ€æœ¯å¦‚ä½•é€‰æ‹©å’Œé…ç½®ï¼Ÿ

A: å‹ç¼©æŠ€æœ¯å¯¹æ¯”ä¸é€‰æ‹©ï¼š

**æ–‡æœ¬å‹ç¼©å¯¹æ¯”:**
å‹ç¼©ç®—æ³• | å‹ç¼©ç‡ | å‹ç¼©é€Ÿåº¦ | è§£å‹é€Ÿåº¦ | æµè§ˆå™¨æ”¯æŒ
--------|--------|----------|----------|----------
Gzip    | 70-80% | å¿«       | å¿«       | 100%
Brotli  | 75-85% | æ…¢       | å¿«       | 95%+
Zstd    | 80-90% | ä¸­ç­‰     | å¾ˆå¿«     | é™åˆ¶

**æ™ºèƒ½å‹ç¼©ç­–ç•¥å®ç°:**
class CompressionOptimizer {
  private static readonly COMPRESSION_CONFIG = {
    brotli: {
      textTypes: ['text/html', 'text/css', 'application/javascript', 'application/json'],
      quality: 6, // å¹³è¡¡å‹ç¼©ç‡å’Œé€Ÿåº¦
      minSize: 1024 // å°äº1KBä¸å‹ç¼©
    },
    
    gzip: {
      level: 6,
      fallback: true // Brotli ä¸æ”¯æŒæ—¶å›é€€
    },
    
    webp: {
      quality: 80,
      supportCheck: true
    }
  };

  // æœåŠ¡ç«¯å‹ç¼©é…ç½® (Express.js ç¤ºä¾‹)
  static setupServerCompression(app) {
    const compression = require('compression');
    const expressStaticGzip = require('express-static-gzip');

    // åŠ¨æ€å†…å®¹å‹ç¼©
    app.use(compression({
      filter: (req, res) => {
        // æ£€æŸ¥å®¢æˆ·ç«¯æ”¯æŒ
        const acceptEncoding = req.headers['accept-encoding'] || '';
        
        if (acceptEncoding.includes('br')) {
          res.setHeader('Content-Encoding', 'br');
          return true;
        } else if (acceptEncoding.includes('gzip')) {
          res.setHeader('Content-Encoding', 'gzip');
          return true;
        }
        
        return false;
      },
      
      level: 6, // Gzip å‹ç¼©çº§åˆ«
      threshold: 1024 // æœ€å°å‹ç¼©æ–‡ä»¶å¤§å°
    }));

    // é™æ€æ–‡ä»¶é¢„å‹ç¼©
    app.use(expressStaticGzip('public', {
      enableBrotli: true,
      orderPreference: ['br', 'gz'],
      setHeaders: (res, path) => {
        // è®¾ç½®ç¼“å­˜ç­–ç•¥
        if (path.endsWith('.js') || path.endsWith('.css')) {
          res.setHeader('Cache-Control', 'public, max-age=31536000'); // 1å¹´
        }
      }
    }));
  }

  // å®¢æˆ·ç«¯å›¾ç‰‡æ ¼å¼æ£€æµ‹
  static detectImageSupport() {
    const canvas = document.createElement('canvas');
    canvas.width = 1;
    canvas.height = 1;
    
    return {
      webp: canvas.toDataURL('image/webp').startsWith('data:image/webp'),
      avif: canvas.toDataURL('image/avif').startsWith('data:image/avif'),
      jxl: 'ImageDecoder' in window // JPEG XL æ£€æµ‹
    };
  }

  // è‡ªé€‚åº”å›¾ç‰‡åŠ è½½
  static createResponsiveImageLoader() {
    const support = this.detectImageSupport();
    
    return {
      getOptimalImageUrl(baseUrl, width) {
        const params = new URLSearchParams({
          w: width.toString(),
          q: '80' // è´¨é‡
        });

        // æŒ‰ä¼˜å…ˆçº§é€‰æ‹©æ ¼å¼
        if (support.avif) {
          params.set('f', 'avif');
        } else if (support.webp) {
          params.set('f', 'webp');
        } else {
          params.set('f', 'jpg');
        }

        return `${baseUrl}?${params}`;
      }
    };
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const imageLoader = CompressionOptimizer.createResponsiveImageLoader();
const optimizedUrl = imageLoader.getOptimalImageUrl('/api/image/hero', 1200);
```

### CDN ä¸ç¼“å­˜ç­–ç•¥

**9. æ™ºèƒ½ç¼“å­˜ç­–ç•¥è®¾è®¡**
```
Q: å¦‚ä½•è®¾è®¡ä¸€å¥—å®Œæ•´çš„å‰ç«¯ç¼“å­˜ç­–ç•¥ï¼Ÿ

A: å¤šå±‚çº§ç¼“å­˜ç­–ç•¥ï¼š

**ç¼“å­˜å±‚çº§æ¶æ„:**
1. **æµè§ˆå™¨ç¼“å­˜** (Browser Cache)
2. **CDN ç¼“å­˜** (Edge Cache)  
3. **æœåŠ¡å™¨ç¼“å­˜** (Origin Cache)
4. **åº”ç”¨ç¼“å­˜** (Application Cache)

**æ™ºèƒ½ç¼“å­˜ç­–ç•¥å®ç°:**
class IntelligentCacheStrategy {
  private static readonly CACHE_RULES = {
    // é™æ€èµ„æº - é•¿æœŸç¼“å­˜ + ç‰ˆæœ¬æ§åˆ¶
    static: {
      'js': { maxAge: 31536000, immutable: true }, // 1å¹´
      'css': { maxAge: 31536000, immutable: true },
      'images': { maxAge: 2592000, staleWhileRevalidate: 86400 }, // 30å¤© + SWR
      'fonts': { maxAge: 31536000, crossOrigin: true }
    },
    
    // åŠ¨æ€å†…å®¹ - çŸ­æœŸç¼“å­˜ + éªŒè¯
    dynamic: {
      'html': { maxAge: 0, mustRevalidate: true },
      'api': { maxAge: 300, staleWhileRevalidate: 60 }, // 5åˆ†é’Ÿ + 1åˆ†é’ŸSWR
      'user-data': { maxAge: 0, noCache: true }
    }
  };

  // ç”Ÿæˆç¼“å­˜å¤´
  static generateCacheHeaders(resourceType: string, subType: string) {
    const rule = this.CACHE_RULES[resourceType]?.[subType];
    if (!rule) return {};

    const headers = {
      'Cache-Control': this.buildCacheControl(rule),
      'Vary': 'Accept-Encoding'
    };

    // æ·»åŠ  ETag ç”¨äºéªŒè¯
    if (rule.mustRevalidate || rule.staleWhileRevalidate) {
      headers['ETag'] = `W/"${Date.now()}"`;
    }

    // é¢„åŠ è½½æç¤º
    if (rule.immutable) {
      headers['Link'] = '</critical.css>; rel=preload; as=style';
    }

    return headers;
  }

  private static buildCacheControl(rule: any): string {
    const directives = [];

    if (rule.noCache) {
      directives.push('no-cache');
    } else if (rule.maxAge) {
      directives.push(`max-age=${rule.maxAge}`);
    }

    if (rule.mustRevalidate) {
      directives.push('must-revalidate');
    }

    if (rule.immutable) {
      directives.push('immutable');
    }

    if (rule.staleWhileRevalidate) {
      directives.push(`stale-while-revalidate=${rule.staleWhileRevalidate}`);
    }

    return directives.join(', ');
  }

  // Service Worker ç¼“å­˜ç­–ç•¥
  static implementSWCaching() {
    return `
    // SW ä¸­çš„æ™ºèƒ½ç¼“å­˜ç­–ç•¥
    const CACHE_NAME = 'app-cache-v1';
    const STATIC_CACHE = 'static-cache-v1';
    const DYNAMIC_CACHE = 'dynamic-cache-v1';

    // ç¼“å­˜ç­–ç•¥æ˜ å°„
    const cacheStrategies = {
      // é™æ€èµ„æº - Cache First
      '/static/': 'cacheFirst',
      
      // API è¯·æ±‚ - Network First with Cache Fallback
      '/api/': 'networkFirst',
      
      // é¡µé¢ - Stale While Revalidate
      '/': 'staleWhileRevalidate'
    };

    self.addEventListener('fetch', event => {
      const url = new URL(event.request.url);
      const strategy = getStrategy(url.pathname);
      
      event.respondWith(
        handleRequest(event.request, strategy)
      );
    });

    async function handleRequest(request, strategy) {
      switch (strategy) {
        case 'cacheFirst':
          return cacheFirst(request);
        case 'networkFirst':
          return networkFirst(request);
        case 'staleWhileRevalidate':
          return staleWhileRevalidate(request);
        default:
          return fetch(request);
      }
    }

    async function cacheFirst(request) {
      const cached = await caches.match(request);
      if (cached) return cached;
      
      const fresh = await fetch(request);
      const cache = await caches.open(STATIC_CACHE);
      cache.put(request, fresh.clone());
      return fresh;
    }
    `;
  }
}
```

---

## å››ã€æ¸²æŸ“æ€§èƒ½ä¼˜åŒ–

### æµè§ˆå™¨æ¸²æŸ“æœºåˆ¶æ·±åº¦è§£æ

**10. å…³é”®æ¸²æŸ“è·¯å¾„ä¼˜åŒ–**
```
Q: è¯¦ç»†åˆ†ææµè§ˆå™¨çš„å…³é”®æ¸²æŸ“è·¯å¾„ï¼Œå¦‚ä½•è¿›è¡Œä¼˜åŒ–ï¼Ÿ

A: å…³é”®æ¸²æŸ“è·¯å¾„åˆ†æï¼š

**æ¸²æŸ“æµæ°´çº¿ (Critical Rendering Path):**
1. **HTML è§£æ** â†’ DOM æ ‘æ„å»º
2. **CSS è§£æ** â†’ CSSOM æ ‘æ„å»º  
3. **JavaScript æ‰§è¡Œ** â†’ DOM/CSSOM ä¿®æ”¹
4. **å¸ƒå±€è®¡ç®—** (Layout/Reflow) â†’ å‡ ä½•ä¿¡æ¯è®¡ç®—
5. **ç»˜åˆ¶** (Paint) â†’ åƒç´ å¡«å……
6. **åˆæˆ** (Composite) â†’ å›¾å±‚åˆå¹¶

**ä¼˜åŒ–ç­–ç•¥å®ç°:**
class CriticalRenderingPathOptimizer {
  // 1. HTML è§£æä¼˜åŒ–
  static optimizeHTMLParsing() {
    return {
      // å†…è”å…³é”® CSS
      inlineCriticalCSS: `
        <style>
        /* Above-the-fold å…³é”®æ ·å¼ */
        .hero { font-size: 2rem; color: #333; }
        .nav { display: flex; justify-content: space-between; }
        </style>
      `,
      
      // é¢„åŠ è½½å…³é”®èµ„æº
      preloadResources: `
        <link rel="preload" href="/fonts/main.woff2" as="font" type="font/woff2" crossorigin>
        <link rel="preload" href="/css/critical.css" as="style">
        <link rel="preload" href="/js/critical.js" as="script">
      `,
      
      // DNS é¢„è§£æ
      dnsPreconnect: `
        <link rel="dns-prefetch" href="//fonts.googleapis.com">
        <link rel="preconnect" href="//api.example.com" crossorigin>
      `
    };
  }

  // 2. CSS æ¸²æŸ“é˜»å¡ä¼˜åŒ–
  static optimizeCSSBlocking() {
    // å…³é”®CSSå†…è”ï¼Œéå…³é”®CSSå¼‚æ­¥åŠ è½½
    const loadNonCriticalCSS = (href: string) => {
      const link = document.createElement('link');
      link.rel = 'stylesheet';
      link.href = href;
      link.media = 'print'; // è®¾ç½®ä¸ºprintåª’ä½“ï¼Œé¿å…é˜»å¡æ¸²æŸ“
      
      link.onload = () => {
        link.media = 'all'; // åŠ è½½å®Œæˆååº”ç”¨åˆ°æ‰€æœ‰åª’ä½“
      };
      
      document.head.appendChild(link);
    };

    // åª’ä½“æŸ¥è¯¢ä¼˜åŒ–
    const loadResponsiveCSS = () => {
      const queries = [
        { media: '(max-width: 768px)', href: '/css/mobile.css' },
        { media: '(min-width: 769px)', href: '/css/desktop.css' },
        { media: 'print', href: '/css/print.css' }
      ];

      queries.forEach(({ media, href }) => {
        const link = document.createElement('link');
        link.rel = 'stylesheet';
        link.href = href;
        link.media = media;
        document.head.appendChild(link);
      });
    };

    return { loadNonCriticalCSS, loadResponsiveCSS };
  }

  // 3. JavaScript è§£æé˜»å¡ä¼˜åŒ–
  static optimizeJavaScriptBlocking() {
    return {
      // è„šæœ¬åŠ è½½ç­–ç•¥
      scriptLoadingStrategies: {
        // å…³é”®è„šæœ¬ - ç«‹å³æ‰§è¡Œ
        critical: '<script src="/js/critical.js"></script>',
        
        // éå…³é”®è„šæœ¬ - å¼‚æ­¥åŠ è½½
        nonCritical: '<script src="/js/analytics.js" async></script>',
        
        // å»¶è¿Ÿè„šæœ¬ - DOMContentLoaded åæ‰§è¡Œ
        deferred: '<script src="/js/enhancements.js" defer></script>',
        
        // æ¨¡å—è„šæœ¬ - ç°ä»£æµè§ˆå™¨ä¼˜åŒ–
        module: '<script type="module" src="/js/main.mjs"></script>'
      },

      // åŠ¨æ€è„šæœ¬åŠ è½½
      loadScriptAsync: (src: string, onLoad?: () => void) => {
        const script = document.createElement('script');
        script.src = src;
        script.async = true;
        
        if (onLoad) {
          script.onload = onLoad;
        }
        
        document.head.appendChild(script);
      },

      // è„šæœ¬ä¼˜å…ˆçº§è°ƒåº¦
      prioritizeScripts: () => {
        // ä½¿ç”¨ Scheduler API (å®éªŒæ€§)
        if ('scheduler' in window && 'postTask' in (window as any).scheduler) {
          (window as any).scheduler.postTask(() => {
            // é«˜ä¼˜å…ˆçº§ä»»åŠ¡
            loadCriticalScripts();
          }, { priority: 'user-blocking' });

          (window as any).scheduler.postTask(() => {
            // ä½ä¼˜å…ˆçº§ä»»åŠ¡
            loadAnalytics();
          }, { priority: 'background' });
        }
      }
    };
  }
}
```

### é‡æ’é‡ç»˜ä¼˜åŒ–

**11. Layout Thrashing é¢„é˜²**
```
Q: ä»€ä¹ˆæ˜¯ Layout Thrashingï¼Ÿå¦‚ä½•é¿å…é¢‘ç¹çš„é‡æ’é‡ç»˜ï¼Ÿ

A: Layout Thrashing ä¼˜åŒ–ç­–ç•¥ï¼š

**è§¦å‘é‡æ’çš„å±æ€§:**
- ç›’æ¨¡å‹: width, height, padding, margin, border
- å®šä½: top, left, right, bottom, position
- æ–‡æœ¬: font-size, font-family, line-height, text-align
- å¸ƒå±€: display, float, clear, overflow

**é«˜æ€§èƒ½ DOM æ“ä½œå®ç°:**
class PerformantDOMManager {
  private rafId: number | null = null;
  private pendingUpdates: (() => void)[] = [];

  // æ‰¹é‡ DOM æ›´æ–°
  batchDOMUpdates(updates: (() => void)[]) {
    // ä½¿ç”¨ DocumentFragment å‡å°‘é‡æ’
    const fragment = document.createDocumentFragment();
    
    updates.forEach(update => {
      update();
    });
    
    // ä¸€æ¬¡æ€§æ’å…¥ DOM
    document.body.appendChild(fragment);
  }

  // è¯»å†™åˆ†ç¦»ä¼˜åŒ–
  optimizedStyleBatch() {
    const elements = document.querySelectorAll('.item');
    
    // âŒ é”™è¯¯åšæ³• - è¯»å†™äº¤æ›¿å¯¼è‡´å¼ºåˆ¶åŒæ­¥å¸ƒå±€
    elements.forEach(el => {
      el.style.left = el.offsetLeft + 10 + 'px'; // è¯»å– offsetLeft è§¦å‘é‡æ’
    });

    // âœ… æ­£ç¡®åšæ³• - å…ˆè¯»å–æ‰€æœ‰ï¼Œå†æ‰¹é‡å†™å…¥
    const positions = Array.from(elements).map(el => el.offsetLeft);
    elements.forEach((el, i) => {
      el.style.left = positions[i] + 10 + 'px';
    });
  }

  // ä½¿ç”¨ CSS Transform ä»£æ›¿ä½ç½®å±æ€§
  animateWithTransform(element: HTMLElement, x: number, y: number) {
    // âŒ è§¦å‘é‡æ’
    // element.style.left = x + 'px';
    // element.style.top = y + 'px';

    // âœ… åªè§¦å‘åˆæˆ
    element.style.transform = `translate3d(${x}px, ${y}px, 0)`;
    element.style.willChange = 'transform'; // æç¤ºæµè§ˆå™¨åˆ›å»ºåˆæˆå±‚
  }

  // è™šæ‹Ÿæ»šåŠ¨å®ç°
  createVirtualScrolling(container: HTMLElement, items: any[], itemHeight: number) {
    const containerHeight = container.clientHeight;
    const visibleCount = Math.ceil(containerHeight / itemHeight) + 2; // é¢„æ¸²æŸ“ç¼“å†²

    let scrollTop = 0;

    const updateVisibleItems = () => {
      const startIndex = Math.floor(scrollTop / itemHeight);
      const endIndex = Math.min(startIndex + visibleCount, items.length);

      // æ¸…ç©ºå®¹å™¨
      container.innerHTML = '';

      // åˆ›å»ºå¯è§é¡¹
      for (let i = startIndex; i < endIndex; i++) {
        const item = document.createElement('div');
        item.style.position = 'absolute';
        item.style.top = i * itemHeight + 'px';
        item.style.height = itemHeight + 'px';
        item.textContent = items[i];
        container.appendChild(item);
      }

      // è®¾ç½®å®¹å™¨æ€»é«˜åº¦
      container.style.height = items.length * itemHeight + 'px';
    };

    container.addEventListener('scroll', () => {
      scrollTop = container.scrollTop;
      
      // èŠ‚æµæ›´æ–°
      if (this.rafId) {
        cancelAnimationFrame(this.rafId);
      }
      
      this.rafId = requestAnimationFrame(updateVisibleItems);
    });

    updateVisibleItems();
  }

  // FastDOM æ¨¡å¼å®ç°
  fastDOMScheduler() {
    const readQueue: (() => void)[] = [];
    const writeQueue: (() => void)[] = [];
    let scheduled = false;

    const flush = () => {
      // å…ˆæ‰§è¡Œæ‰€æœ‰è¯»å–æ“ä½œ
      while (readQueue.length) {
        const task = readQueue.shift()!;
        task();
      }

      // å†æ‰§è¡Œæ‰€æœ‰å†™å…¥æ“ä½œ
      while (writeQueue.length) {
        const task = writeQueue.shift()!;
        task();
      }

      scheduled = false;
    };

    return {
      read: (task: () => void) => {
        readQueue.push(task);
        if (!scheduled) {
          scheduled = true;
          requestAnimationFrame(flush);
        }
      },

      write: (task: () => void) => {
        writeQueue.push(task);
        if (!scheduled) {
          scheduled = true;
          requestAnimationFrame(flush);
        }
      }
    };
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const domManager = new PerformantDOMManager();
const fastDOM = domManager.fastDOMScheduler();

// é«˜æ€§èƒ½ DOM æ“ä½œ
fastDOM.read(() => {
  const width = element.offsetWidth; // è¯»å–æ“ä½œ
});

fastDOM.write(() => {
  element.style.width = '200px'; // å†™å…¥æ“ä½œ
});
```

### CSS æ€§èƒ½ä¼˜åŒ–

**12. CSS æ¸²æŸ“æ€§èƒ½ä¼˜åŒ–**
```
Q: å¦‚ä½•ä» CSS å±‚é¢ä¼˜åŒ–æ¸²æŸ“æ€§èƒ½ï¼Ÿ

A: CSS æ€§èƒ½ä¼˜åŒ–ç­–ç•¥ï¼š

**é€‰æ‹©å™¨æ€§èƒ½ä¼˜åŒ–:**
class CSSPerformanceOptimizer {
  // é€‰æ‹©å™¨æ€§èƒ½æ’åº (ä»å¿«åˆ°æ…¢)
  static readonly SELECTOR_PERFORMANCE = {
    // æœ€å¿« - ç›´æ¥åŒ¹é…
    id: '#header { }',
    class: '.nav-item { }',
    
    // è¾ƒå¿« - ç®€å•ç»„åˆ
    childCombinator: '.nav > .item { }',
    adjacentSibling: '.item + .item { }',
    
    // ä¸­ç­‰ - åä»£é€‰æ‹©å™¨ (é¿å…æ·±å±‚åµŒå¥—)
    descendant: '.nav .item { }', // âœ… 2å±‚å¯æ¥å—
    deepNesting: '.app .nav .menu .item .link { }', // âŒ é¿å…
    
    // æœ€æ…¢ - å¤æ‚å±æ€§é€‰æ‹©å™¨
    complexAttribute: 'input[type="text"][disabled]:not(:focus) { }',
    universalSelector: '* { }' // âŒ é¿å…å…¨å±€é€‰æ‹©å™¨
  };

  // GPU åŠ é€Ÿå±æ€§åˆ©ç”¨
  static optimizeForGPUAcceleration() {
    return {
      // è§¦å‘ç¡¬ä»¶åŠ é€Ÿçš„å±æ€§
      gpuAccelerated: [
        'transform: translateZ(0)', // å¼ºåˆ¶åˆ›å»ºåˆæˆå±‚
        'transform: translate3d(0,0,0)',
        'will-change: transform',
        'opacity',
        'filter',
        'backdrop-filter'
      ],

      // é¿å…ç ´ååˆæˆå±‚çš„å±æ€§
      avoidLayerBreaking: [
        'box-shadow: 0 0 10px rgba(0,0,0,0.1)', // âŒ åœ¨åˆæˆå±‚å…ƒç´ ä¸Šä½¿ç”¨
        'border-radius: 8px', // âŒ åŠ¨ç”»æ—¶é¿å…
        'clip-path: polygon(...)', // âŒ å¤æ‚è·¯å¾„é¿å…åŠ¨ç”»
      ],

      // ä¼˜åŒ–åŠ¨ç”»å®ç°
      optimizedAnimation: `
        /* âŒ è§¦å‘é‡æ’çš„åŠ¨ç”» */
        @keyframes badSlide {
          from { left: 0; }
          to { left: 100px; }
        }

        /* âœ… åªè§¦å‘åˆæˆçš„åŠ¨ç”» */
        @keyframes goodSlide {
          from { transform: translateX(0); }
          to { transform: translateX(100px); }
        }

        .animated-element {
          will-change: transform; /* æå‰å‘ŠçŸ¥æµè§ˆå™¨ */
          transform: translateZ(0); /* åˆ›å»ºåˆæˆå±‚ */
        }

        .animated-element.animate {
          animation: goodSlide 0.3s ease-out;
        }
      `
    };
  }

  // å…³é”®CSSæå–
  static extractCriticalCSS() {
    const criticalCSS = {
      // Above-the-fold æ ·å¼
      aboveTheFold: `
        /* é¡µé¢å¤´éƒ¨å…³é”®æ ·å¼ */
        body { margin: 0; font-family: system-ui, sans-serif; }
        .header { display: flex; height: 60px; background: #fff; }
        .hero { height: 400px; background: linear-gradient(45deg, #blue, #purple); }
        
        /* å…³é”®å­—ä½“ */
        @font-face {
          font-family: 'Primary';
          src: url('/fonts/primary.woff2') format('woff2');
          font-display: swap; /* é¿å…FOIT */
        }
      `,

      // å†…è”å…³é”®CSSçš„ç­–ç•¥
      inlineStrategy: `
        <style>
        /* å†…è”å…³é”®CSSï¼Œå‡å°‘æ¸²æŸ“é˜»å¡ */
        ${this.aboveTheFold}
        </style>
        
        <!-- å¼‚æ­¥åŠ è½½éå…³é”®CSS -->
        <link rel="preload" href="/css/non-critical.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="/css/non-critical.css"></noscript>
      `
    };

    return criticalCSS;
  }

  // å“åº”å¼å›¾ç‰‡ä¼˜åŒ–
  static createResponsiveImageCSS() {
    return `
      /* å“åº”å¼å›¾ç‰‡å®¹å™¨ */
      .responsive-image {
        position: relative;
        overflow: hidden;
        background: #f0f0f0; /* å ä½èƒŒæ™¯ */
      }

      .responsive-image img {
        width: 100%;
        height: auto;
        object-fit: cover;
        transition: opacity 0.3s ease;
        opacity: 0; /* åˆå§‹é€æ˜ï¼ŒåŠ è½½å®Œæˆåæ˜¾ç¤º */
      }

      .responsive-image img.loaded {
        opacity: 1;
      }

      /* ä½¿ç”¨ aspect-ratio ä¿æŒå®½é«˜æ¯” */
      .aspect-16-9 {
        aspect-ratio: 16 / 9;
      }

      .aspect-4-3 {
        aspect-ratio: 4 / 3;
      }

      /* æ¸è¿›å¼å›¾ç‰‡åŠ è½½ */
      .progressive-image {
        background-size: cover;
        background-position: center;
        filter: blur(5px); /* ä½åˆ†è¾¨ç‡å ä½å›¾æ¨¡ç³Šæ•ˆæœ */
        transition: filter 0.3s ease;
      }

      .progressive-image.loaded {
        filter: none;
      }

      /* æ‡’åŠ è½½å ä½ç¬¦ */
      .lazy-placeholder {
        background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
        background-size: 200% 100%;
        animation: loading 1.5s infinite;
      }

      @keyframes loading {
        0% { background-position: 200% 0; }
        100% { background-position: -200% 0; }
      }
    `;
  }
}
```

---

## äº”ã€è¿è¡Œæ—¶æ€§èƒ½ä¼˜åŒ–

### JavaScript æ‰§è¡Œä¼˜åŒ–

**13. JavaScript å¼•æ“ä¼˜åŒ–æŠ€å·§**
```
Q: å¦‚ä½•é’ˆå¯¹ V8 å¼•æ“ç‰¹æ€§ä¼˜åŒ– JavaScript ä»£ç ï¼Ÿ

A: V8 å¼•æ“ä¼˜åŒ–ç­–ç•¥ï¼š

**å¯¹è±¡å½¢çŠ¶ (Hidden Classes) ä¼˜åŒ–:**
class V8Optimizer {
  // âœ… å•æ€ (Monomorphic) - æœ€ä¼˜æ€§èƒ½
  static createOptimizedObjects() {
    class Point {
      constructor(x: number, y: number) {
        this.x = x; // å›ºå®šå±æ€§é¡ºåº
        this.y = y; // V8 å¯ä»¥é¢„æµ‹å¯¹è±¡å½¢çŠ¶
      }
    }

    // æ‰¹é‡åˆ›å»ºç›¸åŒç»“æ„çš„å¯¹è±¡
    const points = Array.from({ length: 1000 }, (_, i) => 
      new Point(i, i * 2)
    );

    return points;
  }

  // âŒ å¤šæ€ (Polymorphic) - æ€§èƒ½è¾ƒå·®
  static avoidPolymorphicObjects() {
    const objects = [
      { x: 1, y: 2 },           // å½¢çŠ¶ 1
      { x: 1, y: 2, z: 3 },     // å½¢çŠ¶ 2 - ä¸åŒå±æ€§
      { y: 2, x: 1 },           // å½¢çŠ¶ 3 - ä¸åŒé¡ºåº
    ];

    // V8 æ— æ³•ä¼˜åŒ–ï¼Œæ¯æ¬¡éƒ½è¦æŸ¥æ‰¾å±æ€§
    objects.forEach(obj => console.log(obj.x + obj.y));
  }

  // æ•°ç»„ä¼˜åŒ–
  static optimizeArrays() {
    // âœ… å•ä¸€ç±»å‹æ•°ç»„ - SMI (Small Integer) ä¼˜åŒ–
    const intArray = new Array(1000).fill(0).map((_, i) => i);
    
    // âœ… é¢„åˆ†é…å¤§å°
    const preallocated = new Array(1000);
    for (let i = 0; i < 1000; i++) {
      preallocated[i] = i * 2;
    }

    // âŒ é¿å…ç¨€ç–æ•°ç»„
    const sparse = [];
    sparse[999] = 'value'; // åˆ›å»ºç¨€ç–æ•°ç»„ï¼Œæ€§èƒ½å·®

    // âœ… ä½¿ç”¨ TypedArray å¤„ç†æ•°å€¼
    const float32Array = new Float32Array(1000);
    for (let i = 0; i < 1000; i++) {
      float32Array[i] = Math.random();
    }

    return { intArray, preallocated, float32Array };
  }

  // å‡½æ•°ä¼˜åŒ–
  static optimizeFunctions() {
    // âœ… å•æ€å‡½æ•° - V8 å¯ä»¥å†…è”ä¼˜åŒ–
    function addNumbers(a: number, b: number): number {
      return a + b; // ç±»å‹ç¨³å®šï¼Œå¯ä»¥ä¼˜åŒ–
    }

    // âŒ å¤šæ€å‡½æ•° - æ€§èƒ½è¾ƒå·®
    function addAny(a: any, b: any): any {
      return a + b; // ç±»å‹ä¸ç¡®å®šï¼Œéš¾ä»¥ä¼˜åŒ–
    }

    // âœ… é¿å… try-catch åŒ…è£¹çƒ­ä»£ç 
    function optimizedLoop(items: number[]) {
      let sum = 0;
      // å°† try-catch ç§»å‡ºå¾ªç¯
      for (let i = 0; i < items.length; i++) {
        sum += items[i];
      }
      return sum;
    }

    // âŒ try-catch é˜»æ­¢ä¼˜åŒ–
    function unoptimizedLoop(items: number[]) {
      let sum = 0;
      for (let i = 0; i < items.length; i++) {
        try {
          sum += items[i]; // try-catch é˜»æ­¢å†…è”ä¼˜åŒ–
        } catch (e) {
          // error handling
        }
      }
      return sum;
    }

    return { addNumbers, optimizedLoop };
  }
}
```

### å¼‚æ­¥ç¼–ç¨‹ä¼˜åŒ–

**14. é«˜æ€§èƒ½å¼‚æ­¥å¤„ç†**
```
Q: å¦‚ä½•ä¼˜åŒ–å¼‚æ­¥æ“ä½œçš„æ€§èƒ½ï¼Œé¿å…é˜»å¡ä¸»çº¿ç¨‹ï¼Ÿ

A: å¼‚æ­¥æ€§èƒ½ä¼˜åŒ–ç­–ç•¥ï¼š

**æ—¶é—´åˆ†ç‰‡ (Time Slicing) å®ç°:**
class AsyncPerformanceOptimizer {
  // æ—¶é—´åˆ†ç‰‡å¤„ç†å¤§é‡æ•°æ®
  static async processLargeDataset<T, R>(
    data: T[],
    processor: (item: T) => R,
    chunkSize = 100,
    delay = 5
  ): Promise<R[]> {
    const results: R[] = [];
    
    for (let i = 0; i < data.length; i += chunkSize) {
      const chunk = data.slice(i, i + chunkSize);
      
      // å¤„ç†å½“å‰å—
      const chunkResults = chunk.map(processor);
      results.push(...chunkResults);
      
      // è®©å‡ºä¸»çº¿ç¨‹ï¼Œé¿å…é˜»å¡ UI
      if (i + chunkSize < data.length) {
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }
    
    return results;
  }

  // ä½¿ç”¨ MessageChannel è¿›è¡Œéé˜»å¡é€šä¿¡
  static createMessageChannelScheduler() {
    const channel = new MessageChannel();
    const taskQueue: (() => void)[] = [];
    let isProcessing = false;

    channel.port2.onmessage = () => {
      if (taskQueue.length > 0 && !isProcessing) {
        isProcessing = true;
        const task = taskQueue.shift()!;
        
        try {
          task();
        } finally {
          isProcessing = false;
          if (taskQueue.length > 0) {
            channel.port1.postMessage(null);
          }
        }
      }
    };

    return {
      schedule: (task: () => void) => {
        taskQueue.push(task);
        if (!isProcessing) {
          channel.port1.postMessage(null);
        }
      }
    };
  }

  // ä¼˜å…ˆçº§ä»»åŠ¡è°ƒåº¦
  static createPriorityScheduler() {
    const queues = {
      immediate: [] as (() => void)[],
      high: [] as (() => void)[],
      normal: [] as (() => void)[],
      low: [] as (() => void)[]
    };

    let isScheduled = false;

    const flushWork = () => {
      const runQueue = (queue: (() => void)[]) => {
        while (queue.length > 0) {
          const task = queue.shift()!;
          const start = performance.now();
          
          task();
          
          // å¦‚æœå•ä¸ªä»»åŠ¡æ‰§è¡Œè¶…è¿‡ 5msï¼Œè®©å‡ºæ§åˆ¶æƒ
          if (performance.now() - start > 5) {
            break;
          }
        }
      };

      // æŒ‰ä¼˜å…ˆçº§æ‰§è¡Œä»»åŠ¡
      runQueue(queues.immediate);
      runQueue(queues.high);
      runQueue(queues.normal);
      runQueue(queues.low);

      // æ£€æŸ¥æ˜¯å¦è¿˜æœ‰å¾…æ‰§è¡Œä»»åŠ¡
      const hasWork = Object.values(queues).some(queue => queue.length > 0);
      if (hasWork) {
        requestIdleCallback(flushWork);
      } else {
        isScheduled = false;
      }
    };

    return {
      schedule: (task: () => void, priority: keyof typeof queues = 'normal') => {
        queues[priority].push(task);
        
        if (!isScheduled) {
          isScheduled = true;
          if (priority === 'immediate') {
            setTimeout(flushWork, 0);
          } else {
            requestIdleCallback(flushWork);
          }
        }
      }
    };
  }

  // æ™ºèƒ½é¢„åŠ è½½
  static createIntelligentPreloader() {
    const cache = new Map<string, Promise<any>>();
    const priorityQueue = new Set<string>();

    return {
      // é¢„åŠ è½½èµ„æº
      preload: async (url: string, priority: 'high' | 'low' = 'low') => {
        if (cache.has(url)) {
          return cache.get(url);
        }

        const promise = fetch(url).then(res => res.json());
        cache.set(url, promise);

        if (priority === 'high') {
          priorityQueue.add(url);
        }

        return promise;
      },

      // æ™ºèƒ½é¢„æµ‹ä¸‹ä¸€ä¸ªè¯·æ±‚
      predictNext: (currentUrl: string, userBehavior: any) => {
        const predictions = this.analyzeUserBehavior(userBehavior);
        
        predictions.forEach(url => {
          // åœ¨ç©ºé—²æ—¶é—´é¢„åŠ è½½
          requestIdleCallback(() => {
            this.preload(url, 'low');
          });
        });
      },

      // ç”¨æˆ·è¡Œä¸ºåˆ†æ (ç®€åŒ–ç‰ˆ)
      analyzeUserBehavior: (behavior: any) => {
        // åŸºäºç”¨æˆ·å†å²è¡Œä¸ºé¢„æµ‹ä¸‹ä¸€ä¸ªå¯èƒ½è®¿é—®çš„èµ„æº
        const patterns = behavior.clickHistory || [];
        return patterns.slice(-3).map((item: any) => item.nextLikelyUrl);
      }
    };
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const scheduler = AsyncPerformanceOptimizer.createPriorityScheduler();

// é«˜ä¼˜å…ˆçº§ä»»åŠ¡ - ç”¨æˆ·äº¤äº’å“åº”
scheduler.schedule(() => {
  updateUI();
}, 'high');

// ä½ä¼˜å…ˆçº§ä»»åŠ¡ - æ•°æ®åˆ†æ
scheduler.schedule(() => {
  analyzeUserBehavior();
}, 'low');
```

### Web Workers æ€§èƒ½ä¼˜åŒ–

**15. Web Workers æœ€ä½³å®è·µ**
```
Q: å¦‚ä½•åˆç†ä½¿ç”¨ Web Workers è¿›è¡Œæ€§èƒ½ä¼˜åŒ–ï¼Ÿ

A: Web Workers ä¼˜åŒ–ç­–ç•¥ï¼š

**Worker æ± ç®¡ç†:**
class WorkerPoolManager {
  private workers: Worker[] = [];
  private availableWorkers: Worker[] = [];
  private taskQueue: Array<{
    data: any;
    resolve: (value: any) => void;
    reject: (error: any) => void;
  }> = [];

  constructor(private workerScript: string, private poolSize = 4) {
    this.initializePool();
  }

  private initializePool() {
    for (let i = 0; i < this.poolSize; i++) {
      const worker = new Worker(this.workerScript);
      
      worker.onmessage = (e) => {
        this.handleWorkerMessage(worker, e.data);
      };
      
      worker.onerror = (error) => {
        console.error('Worker error:', error);
      };

      this.workers.push(worker);
      this.availableWorkers.push(worker);
    }
  }

  private handleWorkerMessage(worker: Worker, result: any) {
    // å½’è¿˜ worker åˆ°å¯ç”¨æ± 
    this.availableWorkers.push(worker);
    
    // å¤„ç†é˜Ÿåˆ—ä¸­çš„ä¸‹ä¸€ä¸ªä»»åŠ¡
    this.processQueue();
    
    return result;
  }

  private processQueue() {
    if (this.taskQueue.length > 0 && this.availableWorkers.length > 0) {
      const task = this.taskQueue.shift()!;
      const worker = this.availableWorkers.shift()!;
      
      this.executeTask(worker, task);
    }
  }

  private executeTask(worker: Worker, task: any) {
    const taskId = Math.random().toString(36);
    
    const messageHandler = (e: MessageEvent) => {
      if (e.data.taskId === taskId) {
        worker.removeEventListener('message', messageHandler);
        
        if (e.data.error) {
          task.reject(new Error(e.data.error));
        } else {
          task.resolve(e.data.result);
        }
        
        this.handleWorkerMessage(worker, e.data);
      }
    };

    worker.addEventListener('message', messageHandler);
    worker.postMessage({ ...task.data, taskId });
  }

  async execute(data: any): Promise<any> {
    return new Promise((resolve, reject) => {
      const task = { data, resolve, reject };
      
      if (this.availableWorkers.length > 0) {
        const worker = this.availableWorkers.shift()!;
        this.executeTask(worker, task);
      } else {
        this.taskQueue.push(task);
      }
    });
  }

  terminate() {
    this.workers.forEach(worker => worker.terminate());
    this.workers = [];
    this.availableWorkers = [];
    this.taskQueue = [];
  }
}

// Worker è„šæœ¬ç¤ºä¾‹ (worker.js)
const workerScript = `
  // é«˜æ€§èƒ½è®¡ç®—ç¤ºä¾‹
  function fibonacci(n) {
    if (n <= 1) return n;
    return fibonacci(n - 1) + fibonacci(n - 2);
  }

  function processImageData(imageData) {
    const data = imageData.data;
    // å›¾åƒå¤„ç†ç®—æ³• (å¦‚é«˜æ–¯æ¨¡ç³Š)
    for (let i = 0; i < data.length; i += 4) {
      const r = data[i];
      const g = data[i + 1];
      const b = data[i + 2];
      
      // ç°åº¦å¤„ç†
      const gray = 0.299 * r + 0.587 * g + 0.114 * b;
      data[i] = data[i + 1] = data[i + 2] = gray;
    }
    
    return imageData;
  }

  self.onmessage = function(e) {
    const { taskId, type, payload } = e.data;
    let result;
    
    try {
      switch (type) {
        case 'fibonacci':
          result = fibonacci(payload.n);
          break;
        case 'imageProcessing':
          result = processImageData(payload.imageData);
          break;
        default:
          throw new Error('Unknown task type');
      }
      
      self.postMessage({ taskId, result });
    } catch (error) {
      self.postMessage({ taskId, error: error.message });
    }
  };
`;

// ä½¿ç”¨ç¤ºä¾‹
const workerPool = new WorkerPoolManager('data:text/javascript,' + encodeURIComponent(workerScript));

// è®¡ç®—å¯†é›†å‹ä»»åŠ¡
async function computeFibonacci(n: number) {
  const result = await workerPool.execute({
    type: 'fibonacci',
    payload: { n }
  });
  return result;
}

// å›¾åƒå¤„ç†ä»»åŠ¡
async function processImage(canvas: HTMLCanvasElement) {
  const ctx = canvas.getContext('2d')!;
  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
  
  const processed = await workerPool.execute({
    type: 'imageProcessing',
    payload: { imageData }
  });
  
  ctx.putImageData(processed, 0, 0);
}
```

---

## å…­ã€æ„å»ºä¸å·¥ç¨‹åŒ–ä¼˜åŒ–

### ä»£ç åˆ†å‰²ä¸æ‡’åŠ è½½

**16. æ™ºèƒ½ä»£ç åˆ†å‰²ç­–ç•¥**
```
Q: å¦‚ä½•è®¾è®¡æœ€ä¼˜çš„ä»£ç åˆ†å‰²ç­–ç•¥ï¼Ÿ

A: ä»£ç åˆ†å‰²æœ€ä½³å®è·µï¼š

**è·¯ç”±çº§åˆ«åˆ†å‰²:**
// React Router + Webpack åŠ¨æ€å¯¼å…¥
const AppRouter = () => {
  // è·¯ç”±çº§åˆ«æ‡’åŠ è½½
  const Home = lazy(() => import('./pages/Home'));
  const Profile = lazy(() => import('./pages/Profile'));
  const Settings = lazy(() => import('./pages/Settings'));
  
  // é¢„åŠ è½½ç­–ç•¥
  const preloadRoute = (routeImport: () => Promise<any>) => {
    // åœ¨ç©ºé—²æ—¶é—´é¢„åŠ è½½
    requestIdleCallback(() => {
      routeImport();
    });
  };

  return (
    <Router>
      <Suspense fallback={<LoadingSpinner />}>
        <Routes>
          <Route path="/" element={<Home />} />
          <Route 
            path="/profile" 
            element={<Profile />}
            onMouseEnter={() => preloadRoute(() => import('./pages/Settings'))}
          />
          <Route path="/settings" element={<Settings />} />
        </Routes>
      </Suspense>
    </Router>
  );
};

**ç»„ä»¶çº§åˆ«åˆ†å‰²:**
class ComponentCodeSplitting {
  // æ¡ä»¶æ€§ç»„ä»¶åŠ è½½
  static createConditionalComponent() {
    const HeavyChart = lazy(() => 
      import('./HeavyChart').then(module => ({
        default: module.HeavyChart
      }))
    );

    return function DataVisualization({ showChart, data }: any) {
      return (
        <div>
          <DataSummary data={data} />
          {showChart && (
            <Suspense fallback={<ChartSkeleton />}>
              <HeavyChart data={data} />
            </Suspense>
          )}
        </div>
      );
    };
  }

  // åŠŸèƒ½æ¨¡å—åˆ†å‰²
  static createFeatureSplitting() {
    const AdvancedEditor = lazy(() =>
      import('./AdvancedEditor').then(module => ({
        default: module.AdvancedEditor
      }))
    );

    return function Editor({ mode }: { mode: 'basic' | 'advanced' }) {
      if (mode === 'basic') {
        return <BasicEditor />;
      }

      return (
        <Suspense fallback={<EditorSkeleton />}>
          <AdvancedEditor />
        </Suspense>
      );
    };
  }
}

**Webpack åˆ†åŒ…ä¼˜åŒ–é…ç½®:**
// webpack.config.js
module.exports = {
  optimization: {
    splitChunks: {
      chunks: 'all',
      cacheGroups: {
        // ç¬¬ä¸‰æ–¹åº“åˆ†åŒ…
        vendor: {
          test: /[\\/]node_modules[\\/]/,
          name: 'vendors',
          priority: 10,
          chunks: 'all',
        },
        
        // å…¬å…±ä»£ç åˆ†åŒ…
        common: {
          name: 'common',
          minChunks: 2,
          priority: 5,
          chunks: 'all',
          enforce: true
        },
        
        // å¤§å‹åº“å•ç‹¬åˆ†åŒ…
        react: {
          test: /[\\/]node_modules[\\/](react|react-dom)[\\/]/,
          name: 'react',
          priority: 20,
          chunks: 'all',
        },
        
        // UI åº“åˆ†åŒ…
        antd: {
          test: /[\\/]node_modules[\\/]antd[\\/]/,
          name: 'antd',
          priority: 15,
          chunks: 'all',
        }
      }
    },
    
    // è¿è¡Œæ—¶ä»£ç åˆ†ç¦»
    runtimeChunk: {
      name: 'runtime'
    }
  }
};
```

### Tree Shaking ä¼˜åŒ–

**17. é«˜æ•ˆ Tree Shaking é…ç½®**
```
Q: å¦‚ä½•ç¡®ä¿ Tree Shaking è¾¾åˆ°æœ€ä½³æ•ˆæœï¼Ÿ

A: Tree Shaking ä¼˜åŒ–æŠ€å·§ï¼š

**ESM æ¨¡å—ä¼˜åŒ–:**
// âœ… æ”¯æŒ Tree Shaking çš„æ¨¡å—å†™æ³•
// utils/math.js
export const add = (a, b) => a + b;
export const subtract = (a, b) => a - b;
export const multiply = (a, b) => a * b;

// é¿å…é»˜è®¤å¯¼å‡ºå¤§å¯¹è±¡
// âŒ ä¸åˆ©äº Tree Shaking
export default {
  add,
  subtract,
  multiply
};

// âœ… åˆ†åˆ«å¯¼å‡º
export { add, subtract, multiply };

**åŒ…ä½“ç§¯åˆ†æä¸ä¼˜åŒ–:**
class BundleAnalyzer {
  // Webpack Bundle Analyzer é…ç½®
  static getAnalyzerConfig() {
    return {
      plugins: [
        new BundleAnalyzerPlugin({
          analyzerMode: process.env.NODE_ENV === 'production' ? 'static' : 'server',
          reportFilename: 'bundle-report.html',
          openAnalyzer: false,
          generateStatsFile: true,
          statsFilename: 'bundle-stats.json'
        })
      ]
    };
  }

  // è‡ªåŠ¨åŒ–åŒ…ä½“ç§¯ç›‘æ§
  static createSizeMonitor() {
    const fs = require('fs');
    const path = require('path');
    
    return {
      checkBundleSize: (buildPath: string, limits: Record<string, number>) => {
        const files = fs.readdirSync(buildPath);
        const violations = [];

        files.forEach(file => {
          const filePath = path.join(buildPath, file);
          const stats = fs.statSync(filePath);
          const sizeKB = stats.size / 1024;

          // æ£€æŸ¥æ˜¯å¦è¶…è¿‡é™åˆ¶
          Object.entries(limits).forEach(([pattern, limit]) => {
            if (file.includes(pattern) && sizeKB > limit) {
              violations.push({
                file,
                size: sizeKB,
                limit,
                excess: sizeKB - limit
              });
            }
          });
        });

        if (violations.length > 0) {
          console.error('Bundle size violations:');
          violations.forEach(v => {
            console.error(`${v.file}: ${v.size.toFixed(1)}KB (limit: ${v.limit}KB, excess: ${v.excess.toFixed(1)}KB)`);
          });
          process.exit(1);
        }
      }
    };
  }

  // ä¾èµ–é¡¹ä¼˜åŒ–å»ºè®®
  static analyzeDependencies() {
    const packageJson = require('./package.json');
    const dependencies = packageJson.dependencies || {};
    
    const recommendations = [];

    // æ£€æŸ¥å¤§å‹ä¾èµ–
    const largeDependencies = {
      'moment': 'day.js (2KB vs 67KB)',
      'lodash': 'lodash-es + tree shaking',
      'antd': 'æŒ‰éœ€å¯¼å…¥',
      'echarts': 'æŒ‰éœ€å¯¼å…¥'
    };

    Object.keys(dependencies).forEach(dep => {
      if (largeDependencies[dep]) {
        recommendations.push({
          package: dep,
          suggestion: largeDependencies[dep],
          priority: 'high'
        });
      }
    });

    return recommendations;
  }
}

**æŒ‰éœ€å¯¼å…¥é…ç½®:**
// babel-plugin-import é…ç½®
// .babelrc
{
  "plugins": [
    [
      "import",
      {
        "libraryName": "antd",
        "libraryDirectory": "es",
        "style": "css"
      },
      "antd"
    ],
    [
      "import",
      {
        "libraryName": "lodash",
        "libraryDirectory": "",
        "camel2DashComponentName": false
      },
      "lodash"
    ]
  ]
}

// æ‰‹åŠ¨æŒ‰éœ€å¯¼å…¥ç¤ºä¾‹
// âŒ å…¨é‡å¯¼å…¥
import * as _ from 'lodash';
import { Button } from 'antd';

// âœ… æŒ‰éœ€å¯¼å…¥
import debounce from 'lodash/debounce';
import throttle from 'lodash/throttle';
import Button from 'antd/es/button';
import 'antd/es/button/style/css';
```

---

## ä¸ƒã€å†…å­˜æ€§èƒ½ä¼˜åŒ–

### å†…å­˜æ³„æ¼æ£€æµ‹ä¸ä¿®å¤

**18. å†…å­˜æ³„æ¼æ¨¡å¼è¯†åˆ«**
```
Q: å‰ç«¯å¸¸è§çš„å†…å­˜æ³„æ¼æ¨¡å¼æœ‰å“ªäº›ï¼Ÿå¦‚ä½•æ£€æµ‹å’Œä¿®å¤ï¼Ÿ

A: å†…å­˜æ³„æ¼æ£€æµ‹ä¸ä¿®å¤ï¼š

**å¸¸è§å†…å­˜æ³„æ¼æ¨¡å¼:**
class MemoryLeakDetector {
  // 1. äº‹ä»¶ç›‘å¬å™¨æ³„æ¼
  static detectEventListenerLeaks() {
    const leakyExample = {
      // âŒ å¿˜è®°ç§»é™¤äº‹ä»¶ç›‘å¬å™¨
      badPattern: () => {
        const element = document.getElementById('button');
        const handler = () => console.log('clicked');
        element?.addEventListener('click', handler);
        // ç»„ä»¶é”€æ¯æ—¶å¿˜è®°ç§»é™¤ç›‘å¬å™¨
      },

      // âœ… æ­£ç¡®çš„æ¸…ç†æ¨¡å¼
      goodPattern: () => {
        const element = document.getElementById('button');
        const handler = () => console.log('clicked');
        element?.addEventListener('click', handler);
        
        // è¿”å›æ¸…ç†å‡½æ•°
        return () => {
          element?.removeEventListener('click', handler);
        };
      }
    };

    // React Hook æ¨¡å¼
    const useEventListener = (event: string, handler: EventListener) => {
      useEffect(() => {
        document.addEventListener(event, handler);
        return () => document.removeEventListener(event, handler);
      }, [event, handler]);
    };

    return { leakyExample, useEventListener };
  }

  // 2. å®šæ—¶å™¨æ³„æ¼
  static detectTimerLeaks() {
    class TimerManager {
      private timers = new Set<number>();

      createInterval(callback: () => void, delay: number) {
        const timerId = window.setInterval(callback, delay);
        this.timers.add(timerId);
        return timerId;
      }

      createTimeout(callback: () => void, delay: number) {
        const timerId = window.setTimeout(() => {
          callback();
          this.timers.delete(timerId); // è‡ªåŠ¨æ¸…ç†
        }, delay);
        this.timers.add(timerId);
        return timerId;
      }

      clearTimer(timerId: number) {
        if (this.timers.has(timerId)) {
          clearInterval(timerId);
          clearTimeout(timerId);
          this.timers.delete(timerId);
        }
      }

      clearAllTimers() {
        this.timers.forEach(timerId => {
          clearInterval(timerId);
          clearTimeout(timerId);
        });
        this.timers.clear();
      }
    }

    return TimerManager;
  }

  // 3. é—­åŒ…å¼•ç”¨æ³„æ¼
  static detectClosureLeaks() {
    return {
      // âŒ é—­åŒ…æŒæœ‰å¤§å¯¹è±¡å¼•ç”¨
      leakyPattern: () => {
        const hugeData = new Array(1000000).fill('data');
        
        return function smallFunction() {
          // å³ä½¿åªç”¨åˆ°ä¸€å°éƒ¨åˆ†ï¼Œæ•´ä¸ª hugeData éƒ½è¢«ä¿æŒåœ¨å†…å­˜ä¸­
          return hugeData[0];
        };
      },

      // âœ… æå–éœ€è¦çš„æ•°æ®
      optimizedPattern: () => {
        const hugeData = new Array(1000000).fill('data');
        const firstItem = hugeData[0]; // åªä¿ç•™éœ€è¦çš„éƒ¨åˆ†
        
        return function smallFunction() {
          return firstItem; // åªå¼•ç”¨å°æ•°æ®
        };
      }
    };
  }

  // 4. DOM å¼•ç”¨æ³„æ¼
  static detectDOMLeaks() {
    class DOMReferenceManager {
      private domRefs = new WeakMap<Element, any>();

      // âœ… ä½¿ç”¨ WeakMap å­˜å‚¨ DOM å¼•ç”¨
      setElementData(element: Element, data: any) {
        this.domRefs.set(element, data);
      }

      getElementData(element: Element) {
        return this.domRefs.get(element);
      }

      // WeakMap ä¼šè‡ªåŠ¨æ¸…ç†å·²åˆ é™¤çš„ DOM å…ƒç´ å¼•ç”¨
    }

    // âŒ å¼ºå¼•ç”¨ DOM å…ƒç´ 
    const badCache = new Map<string, Element>();

    // âœ… å¼±å¼•ç”¨æ¨¡å¼
    const goodCache = new WeakMap<Element, any>();

    return { DOMReferenceManager, badCache, goodCache };
  }
}

**å†…å­˜ç›‘æ§å·¥å…·:**
class MemoryMonitor {
  private measurements: Array<{
    timestamp: number;
    used: number;
    total: number;
  }> = [];

  startMonitoring(interval = 5000) {
    const monitor = () => {
      if (performance.memory) {
        const measurement = {
          timestamp: Date.now(),
          used: performance.memory.usedJSHeapSize,
          total: performance.memory.totalJSHeapSize
        };
        
        this.measurements.push(measurement);
        this.analyzeMemoryTrend();
      }
    };

    setInterval(monitor, interval);
    monitor(); // ç«‹å³æ‰§è¡Œä¸€æ¬¡
  }

  private analyzeMemoryTrend() {
    if (this.measurements.length < 10) return;

    const recent = this.measurements.slice(-10);
    const growth = recent.map((curr, i) => {
      if (i === 0) return 0;
      return curr.used - recent[i - 1].used;
    });

    const averageGrowth = growth.reduce((a, b) => a + b, 0) / growth.length;
    
    // å¦‚æœå¹³å‡å¢é•¿è¶…è¿‡ 1MB/5sï¼Œå‘å‡ºè­¦å‘Š
    if (averageGrowth > 1024 * 1024) {
      console.warn('âš ï¸ Potential memory leak detected:', {
        averageGrowth: `${(averageGrowth / 1024 / 1024).toFixed(2)}MB/5s`,
        currentUsage: `${(recent[recent.length - 1].used / 1024 / 1024).toFixed(2)}MB`
      });
      
      this.generateMemoryReport();
    }
  }

  private generateMemoryReport() {
    const last = this.measurements[this.measurements.length - 1];
    const first = this.measurements[0];
    const totalGrowth = last.used - first.used;
    const duration = last.timestamp - first.timestamp;

    console.log('ğŸ“Š Memory Usage Report:', {
      duration: `${duration / 1000}s`,
      initialUsage: `${(first.used / 1024 / 1024).toFixed(2)}MB`,
      currentUsage: `${(last.used / 1024 / 1024).toFixed(2)}MB`,
      totalGrowth: `${(totalGrowth / 1024 / 1024).toFixed(2)}MB`,
      growthRate: `${(totalGrowth / duration * 1000).toFixed(0)}B/s`
    });
  }

  // æ‰‹åŠ¨è§¦å‘åƒåœ¾å›æ”¶ (å¼€å‘ç¯å¢ƒ)
  forceGC() {
    if (window.gc) {
      window.gc();
      console.log('ğŸ—‘ï¸ Garbage collection triggered');
    } else {
      console.warn('GC not available. Start Chrome with --enable-precise-memory-info --expose-gc');
    }
  }

  // ç”Ÿæˆå†…å­˜å¿«ç…§å¯¹æ¯”
  async captureHeapSnapshot() {
    return new Promise((resolve) => {
      const beforeGC = performance.memory?.usedJSHeapSize || 0;
      
      // å»ºè®®è§¦å‘ GC
      if (window.gc) {
        window.gc();
      }
      
      setTimeout(() => {
        const afterGC = performance.memory?.usedJSHeapSize || 0;
        const freed = beforeGC - afterGC;
        
        resolve({
          before: beforeGC,
          after: afterGC,
          freed,
          freedMB: (freed / 1024 / 1024).toFixed(2)
        });
      }, 100);
    });
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const memoryMonitor = new MemoryMonitor();
memoryMonitor.startMonitoring(3000); // æ¯3ç§’æ£€æŸ¥ä¸€æ¬¡

// åœ¨å¼€å‘ç¯å¢ƒä¸­æ·»åŠ å†…å­˜è°ƒè¯•å·¥å…·
if (process.env.NODE_ENV === 'development') {
  (window as any).memoryMonitor = memoryMonitor;
  (window as any).captureSnapshot = () => memoryMonitor.captureHeapSnapshot();
}
```

---

## å…«ã€æ€§èƒ½ç›‘æ§ä¸é¢„ç®—

### æ€§èƒ½é¢„ç®—åˆ¶å®š

**19. æ€§èƒ½é¢„ç®—ç­–ç•¥è®¾è®¡**
```
Q: å¦‚ä½•åˆ¶å®šå’Œæ‰§è¡Œæ€§èƒ½é¢„ç®—ï¼Ÿ

A: æ€§èƒ½é¢„ç®—å®æ–½æ–¹æ¡ˆï¼š

**æ€§èƒ½é¢„ç®—é…ç½®:**
class PerformanceBudget {
  private static readonly BUDGET_CONFIG = {
    // èµ„æºå¤§å°é¢„ç®—
    resourceSizes: {
      'main.js': { max: 250, warn: 200 }, // KB
      'vendor.js': { max: 500, warn: 400 },
      'main.css': { max: 50, warn: 40 },
      'total': { max: 2000, warn: 1500 } // æ€»ä½“ç§¯
    },
    
    // æ€§èƒ½æŒ‡æ ‡é¢„ç®—
    metrics: {
      lcp: { max: 2500, warn: 2000 }, // ms
      fid: { max: 100, warn: 80 },
      cls: { max: 0.1, warn: 0.05 },
      fcp: { max: 1800, warn: 1500 },
      tti: { max: 3800, warn: 3000 }
    },
    
    // ç½‘ç»œæ¡ä»¶é¢„ç®—
    networkBudgets: {
      '3G': {
        lcp: { max: 4000, warn: 3500 },
        fcp: { max: 3000, warn: 2500 }
      },
      '4G': {
        lcp: { max: 2500, warn: 2000 },
        fcp: { max: 1800, warn: 1500 }
      }
    }
  };

  // Webpack æ€§èƒ½é¢„ç®—æ’ä»¶
  static createWebpackBudgetPlugin() {
    return {
      performance: {
        maxAssetSize: 250 * 1024, // 250KB
        maxEntrypointSize: 500 * 1024, // 500KB
        assetFilter: (assetFilename: string) => {
          // åªæ£€æŸ¥ JS/CSS æ–‡ä»¶
          return assetFilename.endsWith('.js') || assetFilename.endsWith('.css');
        },
        hints: 'error' // è¶…å‡ºé¢„ç®—æ—¶æŠ¥é”™
      },
      
      // è‡ªå®šä¹‰é¢„ç®—æ£€æŸ¥æ’ä»¶
      plugins: [
        {
          apply: (compiler: any) => {
            compiler.hooks.afterEmit.tap('BudgetPlugin', (compilation: any) => {
              const assets = compilation.assets;
              const violations = [];

              Object.keys(assets).forEach(assetName => {
                const asset = assets[assetName];
                const sizeKB = asset.size() / 1024;
                const budget = this.BUDGET_CONFIG.resourceSizes[assetName];

                if (budget && sizeKB > budget.max) {
                  violations.push({
                    asset: assetName,
                    size: sizeKB,
                    budget: budget.max,
                    excess: sizeKB - budget.max
                  });
                }
              });

              if (violations.length > 0) {
                console.error('âŒ Performance Budget Violations:');
                violations.forEach(v => {
                  console.error(`  ${v.asset}: ${v.size.toFixed(1)}KB (budget: ${v.budget}KB, +${v.excess.toFixed(1)}KB)`);
                });
                
                if (process.env.CI) {
                  process.exit(1); // CI ç¯å¢ƒä¸‹å¤±è´¥
                }
              }
            });
          }
        }
      ]
    };
  }

  // Lighthouse é¢„ç®—é…ç½®
  static createLighthouseBudget() {
    return {
      budget: [
        {
          path: '/*',
          timings: [
            { metric: 'first-contentful-paint', budget: 1500 },
            { metric: 'largest-contentful-paint', budget: 2500 },
            { metric: 'speed-index', budget: 3000 },
            { metric: 'cumulative-layout-shift', budget: 0.1 }
          ],
          resourceSizes: [
            { resourceType: 'script', budget: 400 },
            { resourceType: 'stylesheet', budget: 50 },
            { resourceType: 'image', budget: 500 },
            { resourceType: 'total', budget: 2000 }
          ]
        }
      ]
    };
  }

  // è¿è¡Œæ—¶é¢„ç®—ç›‘æ§
  static createRuntimeBudgetMonitor() {
    const violations = new Map<string, number>();
    const alerts = new Set<string>();

    return {
      checkMetric: (metricName: string, value: number) => {
        const budget = this.BUDGET_CONFIG.metrics[metricName];
        if (!budget) return;

        if (value > budget.max) {
          violations.set(metricName, value);
          
          if (!alerts.has(metricName)) {
            alerts.add(metricName);
            console.warn(`âš ï¸ Performance Budget Exceeded: ${metricName}`, {
              value,
              budget: budget.max,
              excess: value - budget.max
            });
            
            // å‘é€ç›‘æ§æ•°æ®
            this.reportViolation(metricName, value, budget.max);
          }
        } else if (value > budget.warn) {
          console.info(`â„¹ï¸ Performance Warning: ${metricName} approaching budget`, {
            value,
            budget: budget.max,
            remaining: budget.max - value
          });
        }
      },

      getViolations: () => Array.from(violations.entries()),
      
      generateReport: () => {
        const violationList = Array.from(violations.entries());
        if (violationList.length === 0) {
          return 'âœ… All performance budgets are within limits';
        }

        return {
          status: 'violations',
          violations: violationList.map(([metric, value]) => ({
            metric,
            value,
            budget: this.BUDGET_CONFIG.metrics[metric]?.max,
            severity: value > this.BUDGET_CONFIG.metrics[metric]?.max ? 'error' : 'warning'
          }))
        };
      }
    };
  }

  private static reportViolation(metric: string, value: number, budget: number) {
    // å‘é€åˆ°ç›‘æ§æœåŠ¡
    if (navigator.sendBeacon) {
      navigator.sendBeacon('/api/performance-violations', JSON.stringify({
        metric,
        value,
        budget,
        timestamp: Date.now(),
        userAgent: navigator.userAgent,
        url: window.location.href
      }));
    }
  }
}
```

### æŒç»­é›†æˆæ€§èƒ½æ£€æŸ¥

**20. CI/CD æ€§èƒ½æµæ°´çº¿**
```
Q: å¦‚ä½•åœ¨ CI/CD æµç¨‹ä¸­é›†æˆæ€§èƒ½æ£€æŸ¥ï¼Ÿ

A: CI/CD æ€§èƒ½é›†æˆæ–¹æ¡ˆï¼š

**GitHub Actions æ€§èƒ½æ£€æŸ¥:**
// .github/workflows/performance.yml
const performanceWorkflow = `
name: Performance Check

on:
  pull_request:
    branches: [ main ]
  push:
    branches: [ main ]

jobs:
  performance-audit:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'
        cache: 'npm'
    
    - name: Install dependencies
      run: npm ci
    
    - name: Build application
      run: npm run build
    
    - name: Check bundle size
      run: npm run check-bundle-size
    
    - name: Run Lighthouse CI
      run: |
        npm install -g @lhci/cli
        lhci autorun
      env:
        LHCI_GITHUB_APP_TOKEN: \${{ secrets.LHCI_GITHUB_APP_TOKEN }}
    
    - name: Performance regression test
      run: npm run performance-test
    
    - name: Upload performance artifacts
      uses: actions/upload-artifact@v3
      with:
        name: performance-report
        path: |
          lighthouse-report.html
          bundle-analyzer-report.html
          performance-metrics.json
`;

**æ€§èƒ½å›å½’æµ‹è¯•å®ç°:**
class PerformanceRegressionTest {
  private baselineMetrics: Map<string, number> = new Map();
  private currentMetrics: Map<string, number> = new Map();

  // è®¾ç½®åŸºå‡†æ•°æ®
  setBaseline(metrics: Record<string, number>) {
    Object.entries(metrics).forEach(([key, value]) => {
      this.baselineMetrics.set(key, value);
    });
  }

  // è®°å½•å½“å‰æ€§èƒ½æ•°æ®
  recordCurrent(metrics: Record<string, number>) {
    Object.entries(metrics).forEach(([key, value]) => {
      this.currentMetrics.set(key, value);
    });
  }

  // æ£€æŸ¥æ€§èƒ½å›å½’
  checkRegression(thresholds: Record<string, number> = {}) {
    const defaultThresholds = {
      lcp: 0.1, // 10% å¢é•¿é˜ˆå€¼
      fcp: 0.1,
      cls: 0.05,
      bundleSize: 0.05 // 5% å¤§å°å¢é•¿é˜ˆå€¼
    };

    const finalThresholds = { ...defaultThresholds, ...thresholds };
    const regressions = [];

    this.currentMetrics.forEach((currentValue, metric) => {
      const baselineValue = this.baselineMetrics.get(metric);
      if (!baselineValue) return;

      const changeRatio = (currentValue - baselineValue) / baselineValue;
      const threshold = finalThresholds[metric] || 0.1;

      if (changeRatio > threshold) {
        regressions.push({
          metric,
          baseline: baselineValue,
          current: currentValue,
          change: changeRatio,
          threshold,
          severity: changeRatio > threshold * 2 ? 'critical' : 'warning'
        });
      }
    });

    return {
      hasRegression: regressions.length > 0,
      regressions,
      summary: this.generateRegressionSummary(regressions)
    };
  }

  private generateRegressionSummary(regressions: any[]) {
    if (regressions.length === 0) {
      return 'âœ… No performance regressions detected';
    }

    const critical = regressions.filter(r => r.severity === 'critical');
    const warnings = regressions.filter(r => r.severity === 'warning');

    let summary = `âŒ Performance regressions detected:\n`;
    
    if (critical.length > 0) {
      summary += `\nğŸš¨ Critical regressions (${critical.length}):\n`;
      critical.forEach(r => {
        summary += `  - ${r.metric}: ${r.baseline} â†’ ${r.current} (+${(r.change * 100).toFixed(1)}%)\n`;
      });
    }

    if (warnings.length > 0) {
      summary += `\nâš ï¸ Warning regressions (${warnings.length}):\n`;
      warnings.forEach(r => {
        summary += `  - ${r.metric}: ${r.baseline} â†’ ${r.current} (+${(r.change * 100).toFixed(1)}%)\n`;
      });
    }

    return summary;
  }

  // ç”Ÿæˆæ€§èƒ½å¯¹æ¯”æŠ¥å‘Š
  generateComparisonReport() {
    const metrics = Array.from(this.currentMetrics.keys());
    const report = {
      timestamp: new Date().toISOString(),
      comparison: metrics.map(metric => {
        const baseline = this.baselineMetrics.get(metric) || 0;
        const current = this.currentMetrics.get(metric) || 0;
        const change = baseline ? (current - baseline) / baseline : 0;

        return {
          metric,
          baseline,
          current,
          change,
          changePercent: (change * 100).toFixed(2) + '%',
          status: this.getMetricStatus(change)
        };
      })
    };

    return report;
  }

  private getMetricStatus(change: number): 'improved' | 'degraded' | 'stable' {
    if (change < -0.05) return 'improved';
    if (change > 0.05) return 'degraded';
    return 'stable';
  }
}

// package.json è„šæœ¬é…ç½®
const packageScripts = {
  "scripts": {
    "check-bundle-size": "bundlesize",
    "performance-test": "node scripts/performance-test.js",
    "lighthouse": "lighthouse --chrome-flags=\"--headless\" --output=html --output-path=./lighthouse-report.html http://localhost:3000",
    "analyze-bundle": "webpack-bundle-analyzer build/static/js/*.js"
  },
  
  "bundlesize": [
    {
      "path": "./build/static/js/main.*.js",
      "maxSize": "250 KB"
    },
    {
      "path": "./build/static/css/main.*.css",
      "maxSize": "50 KB"
    }
  ]
};

// Lighthouse CI é…ç½®æ–‡ä»¶
// .lighthouserc.js
module.exports = {
  ci: {
    collect: {
      startServerCommand: 'npm run serve',
      url: ['http://localhost:3000'],
      numberOfRuns: 3
    },
    assert: {
      assertions: {
        'categories:performance': ['error', { minScore: 0.9 }],
        'categories:accessibility': ['error', { minScore: 0.9 }],
        'categories:best-practices': ['error', { minScore: 0.9 }],
        'categories:seo': ['error', { minScore: 0.9 }]
      }
    },
    upload: {
      target: 'temporary-public-storage'
    }
  }
};
```

---

## ä¹ã€å®æˆ˜æ¡ˆä¾‹åˆ†æ

### ç»¼åˆæ€§èƒ½ä¼˜åŒ–æ¡ˆä¾‹

**21. ç”µå•†ç½‘ç«™é¦–é¡µæ€§èƒ½ä¼˜åŒ–**
```
Q: ä¸€ä¸ªç”µå•†ç½‘ç«™é¦–é¡µ LCP è¾¾åˆ° 4.2sï¼Œå¦‚ä½•ç³»ç»Ÿæ€§åœ°è¿›è¡Œä¼˜åŒ–ï¼Ÿ

A: ç³»ç»Ÿæ€§ä¼˜åŒ–æ–¹æ¡ˆï¼š

**é—®é¢˜è¯Šæ–­:**
class EcommercePerformanceOptimizer {
  // 1. æ€§èƒ½é—®é¢˜è¯Šæ–­
  static async diagnosePerformanceIssues() {
    const diagnostics = {
      networkAnalysis: await this.analyzeNetworkRequests(),
      renderingAnalysis: await this.analyzeRenderingPath(),
      resourceAnalysis: await this.analyzeResourceLoading(),
      codeAnalysis: await this.analyzeCodePerformance()
    };

    return this.generateDiagnosisReport(diagnostics);
  }

  private static async analyzeNetworkRequests() {
    const resources = performance.getEntriesByType('resource') as PerformanceResourceTiming[];
    
    return {
      totalRequests: resources.length,
      slowRequests: resources.filter(r => r.duration > 1000),
      largeResources: resources.filter(r => r.transferSize > 500 * 1024),
      renderBlockingResources: resources.filter(r => 
        r.name.includes('.css') && r.renderBlockingStatus === 'blocking'
      ),
      criticalChain: this.identifyCriticalChain(resources)
    };
  }

  // 2. å…³é”®æ¸²æŸ“è·¯å¾„ä¼˜åŒ–
  static optimizeCriticalRenderingPath() {
    return {
      // å†…è”å…³é”® CSS
      inlineCriticalCSS: `
        <style>
        /* å…³é”®è·¯å¾„æ ·å¼ - Above the fold */
        .header { display: flex; height: 80px; background: #fff; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .hero-banner { height: 400px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); }
        .product-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; }
        .product-card { background: #fff; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
        </style>
      `,

      // é¢„åŠ è½½å…³é”®èµ„æº
      preloadCriticalResources: `
        <!-- å…³é”®å­—ä½“ -->
        <link rel="preload" href="/fonts/brand-font.woff2" as="font" type="font/woff2" crossorigin>
        
        <!-- å…³é”®å›¾ç‰‡ -->
        <link rel="preload" href="/images/hero-banner.webp" as="image">
        
        <!-- å…³é”® JavaScript -->
        <link rel="preload" href="/js/critical.js" as="script">
        
        <!-- é¢„è¿æ¥ç¬¬ä¸‰æ–¹åŸŸå -->
        <link rel="preconnect" href="//cdn.shopify.com">
        <link rel="preconnect" href="//fonts.googleapis.com">
      `,

      // ä¼˜åŒ– CSS åŠ è½½
      optimizedCSSLoading: this.createOptimizedCSSLoader(),
      
      // ä¼˜åŒ– JavaScript åŠ è½½
      optimizedJSLoading: this.createOptimizedJSLoader()
    };
  }

  // 3. å›¾ç‰‡ä¼˜åŒ–ç­–ç•¥
  static createImageOptimizationStrategy() {
    return {
      // å“åº”å¼å›¾ç‰‡ç»„ä»¶
      ResponsiveImage: ({ src, alt, aspectRatio }: any) => {
        const [loaded, setLoaded] = useState(false);
        const [inView, setInView] = useState(false);
        const imgRef = useRef<HTMLImageElement>(null);

        // æ‡’åŠ è½½
        useEffect(() => {
          const observer = new IntersectionObserver(
            ([entry]) => {
              if (entry.isIntersecting) {
                setInView(true);
                observer.disconnect();
              }
            },
            { threshold: 0.1 }
          );

          if (imgRef.current) {
            observer.observe(imgRef.current);
          }

          return () => observer.disconnect();
        }, []);

        // å›¾ç‰‡æ ¼å¼æ£€æµ‹
        const getOptimalFormat = () => {
          const canvas = document.createElement('canvas');
          const supportsWebP = canvas.toDataURL('image/webp').startsWith('data:image/webp');
          const supportsAVIF = canvas.toDataURL('image/avif').startsWith('data:image/avif');
          
          if (supportsAVIF) return 'avif';
          if (supportsWebP) return 'webp';
          return 'jpg';
        };

        const format = getOptimalFormat();
        const optimizedSrc = `${src}?format=${format}&quality=80`;

        return (
          <div 
            ref={imgRef}
            style={{ aspectRatio }}
            className={`responsive-image ${loaded ? 'loaded' : ''}`}
          >
            {inView && (
              <img
                src={optimizedSrc}
                alt={alt}
                loading="lazy"
                onLoad={() => setLoaded(true)}
                style={{
                  width: '100%',
                  height: '100%',
                  objectFit: 'cover',
                  opacity: loaded ? 1 : 0,
                  transition: 'opacity 0.3s ease'
                }}
              />
            )}
            {!loaded && (
              <div className="image-placeholder">
                <div className="skeleton-loader" />
              </div>
            )}
          </div>
        );
      },

      // å›¾ç‰‡é¢„åŠ è½½ç­–ç•¥
      preloadStrategy: {
        // é¢„åŠ è½½å…³é”®å›¾ç‰‡
        preloadCritical: () => {
          const criticalImages = [
            '/images/hero-banner.webp',
            '/images/featured-product-1.webp',
            '/images/featured-product-2.webp'
          ];

          criticalImages.forEach(src => {
            const link = document.createElement('link');
            link.rel = 'preload';
            link.as = 'image';
            link.href = src;
            document.head.appendChild(link);
          });
        },

        // æ™ºèƒ½é¢„åŠ è½½
        intelligentPreload: () => {
          // åŸºäºç”¨æˆ·è¡Œä¸ºé¢„åŠ è½½
          const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
              if (entry.isIntersecting) {
                const productCard = entry.target;
                const nextImage = productCard.nextElementSibling?.querySelector('img');
                if (nextImage && !nextImage.src) {
                  nextImage.src = nextImage.dataset.src;
                }
              }
            });
          }, { rootMargin: '100px' });

          document.querySelectorAll('.product-card').forEach(card => {
            observer.observe(card);
          });
        }
      }
    };
  }

  // 4. å•†å“æ•°æ®ä¼˜åŒ–
  static optimizeProductDataLoading() {
    return {
      // åˆ†é¡µåŠ è½½
      usePaginatedProducts: (pageSize = 20) => {
        const [products, setProducts] = useState([]);
        const [loading, setLoading] = useState(false);
        const [hasMore, setHasMore] = useState(true);
        const [page, setPage] = useState(1);

        const loadMore = useCallback(async () => {
          if (loading || !hasMore) return;

          setLoading(true);
          try {
            const response = await fetch(`/api/products?page=${page}&size=${pageSize}`);
            const newProducts = await response.json();
            
            if (newProducts.length < pageSize) {
              setHasMore(false);
            }
            
            setProducts(prev => [...prev, ...newProducts]);
            setPage(prev => prev + 1);
          } catch (error) {
            console.error('Failed to load products:', error);
          } finally {
            setLoading(false);
          }
        }, [page, pageSize, loading, hasMore]);

        return { products, loadMore, loading, hasMore };
      },

      // æ•°æ®é¢„å–
      useProductPrefetch: () => {
        const cache = new Map();

        const prefetchProduct = (productId: string) => {
          if (cache.has(productId)) return;

          // åœ¨ç©ºé—²æ—¶é—´é¢„å–
          requestIdleCallback(async () => {
            try {
              const response = await fetch(`/api/products/${productId}`);
              const product = await response.json();
              cache.set(productId, product);
            } catch (error) {
              console.error('Prefetch failed:', error);
            }
          });
        };

        const getProduct = async (productId: string) => {
          if (cache.has(productId)) {
            return cache.get(productId);
          }

          const response = await fetch(`/api/products/${productId}`);
          const product = await response.json();
          cache.set(productId, product);
          return product;
        };

        return { prefetchProduct, getProduct };
      }
    };
  }

  // 5. ç¬¬ä¸‰æ–¹è„šæœ¬ä¼˜åŒ–
  static optimizeThirdPartyScripts() {
    return {
      // å»¶è¿ŸåŠ è½½éå…³é”®è„šæœ¬
      deferNonCriticalScripts: () => {
        const scripts = [
          { src: '/js/analytics.js', defer: true },
          { src: '/js/chatbot.js', defer: true },
          { src: '/js/recommendations.js', defer: true }
        ];

        // é¡µé¢åŠ è½½å®Œæˆåå†åŠ è½½
        window.addEventListener('load', () => {
          setTimeout(() => {
            scripts.forEach(({ src, defer }) => {
              const script = document.createElement('script');
              script.src = src;
              script.defer = defer;
              document.head.appendChild(script);
            });
          }, 1000);
        });
      },

      // Facade æ¨¡å¼å»¶è¿Ÿåˆå§‹åŒ–
      createFacadeComponent: (ThirdPartyComponent: any) => {
        return function FacadeWrapper(props: any) {
          const [loaded, setLoaded] = useState(false);

          const loadComponent = () => {
            setLoaded(true);
          };

          if (!loaded) {
            return (
              <div 
                className="third-party-facade"
                onClick={loadComponent}
                style={{
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'center',
                  minHeight: '200px',
                  background: '#f5f5f5',
                  border: '1px solid #ddd',
                  cursor: 'pointer'
                }}
              >
                <div>
                  <p>ç‚¹å‡»åŠ è½½ç¬¬ä¸‰æ–¹ç»„ä»¶</p>
                  <small>å‡å°‘åˆå§‹åŠ è½½æ—¶é—´</small>
                </div>
              </div>
            );
          }

          return <ThirdPartyComponent {...props} />;
        };
      }
    };
  }

  // ä¼˜åŒ–ç»“æœéªŒè¯
  static createOptimizationValidator() {
    return {
      measureImprovements: async () => {
        const before = {
          lcp: 4200, // ä¼˜åŒ–å‰åŸºå‡†
          fcp: 2800,
          cls: 0.15,
          fid: 120
        };

        // ç­‰å¾…é¡µé¢åŠ è½½å®Œæˆåæµ‹é‡
        await new Promise(resolve => {
          if (document.readyState === 'complete') {
            resolve(null);
          } else {
            window.addEventListener('load', resolve);
          }
        });

        const after = await this.getCurrentMetrics();
        
        return {
          improvements: {
            lcp: ((before.lcp - after.lcp) / before.lcp * 100).toFixed(1) + '%',
            fcp: ((before.fcp - after.fcp) / before.fcp * 100).toFixed(1) + '%',
            cls: ((before.cls - after.cls) / before.cls * 100).toFixed(1) + '%',
            fid: ((before.fid - after.fid) / before.fid * 100).toFixed(1) + '%'
          },
          before,
          after
        };
      },

      getCurrentMetrics: async () => {
        return new Promise(resolve => {
          new PerformanceObserver((list) => {
            const metrics: any = {};
            
            for (const entry of list.getEntries()) {
              if (entry.name === 'largest-contentful-paint') {
                metrics.lcp = entry.startTime;
              }
              if (entry.name === 'first-contentful-paint') {
                metrics.fcp = entry.startTime;
              }
            }
            
            resolve(metrics);
          }).observe({ entryTypes: ['paint', 'largest-contentful-paint'] });
        });
      }
    };
  }
}

// é¢„æœŸä¼˜åŒ–æ•ˆæœ
const expectedResults = {
  lcpImprovement: '4.2s â†’ 2.1s (50% æå‡)',
  fcpImprovement: '2.8s â†’ 1.4s (50% æå‡)',
  clsImprovement: '0.15 â†’ 0.05 (67% æå‡)',
  bundleSizeReduction: '1.2MB â†’ 800KB (33% å‡å°‘)',
  requestReduction: '45 â†’ 28 (38% å‡å°‘)'
};
```

---

## ğŸ¯ æ€§èƒ½ä¼˜åŒ–æ€»ç»“

### ä¼˜åŒ–ä¼˜å…ˆçº§çŸ©é˜µ

| ä¼˜åŒ–æ–¹å‘ | å½±å“ç¨‹åº¦ | å®æ–½éš¾åº¦ | æŠ•å…¥äº§å‡ºæ¯” | ä¼˜å…ˆçº§ |
|---------|----------|----------|------------|--------|
| å…³é”®èµ„æºä¼˜åŒ– | é«˜ | ä½ | å¾ˆé«˜ | P0 |
| å›¾ç‰‡ä¼˜åŒ– | é«˜ | ä¸­ | é«˜ | P0 |
| ä»£ç åˆ†å‰² | é«˜ | ä¸­ | é«˜ | P1 |
| ç¼“å­˜ç­–ç•¥ | ä¸­ | ä½ | é«˜ | P1 |
| ç¬¬ä¸‰æ–¹è„šæœ¬ä¼˜åŒ– | ä¸­ | ä¸­ | ä¸­ | P2 |
| Web Workers | ä½ | é«˜ | ä½ | P3 |

### æ€§èƒ½ä¼˜åŒ–æ£€æŸ¥æ¸…å•

**ğŸš€ ç«‹å³å¯åš (Quick Wins):**
- [ ] å¯ç”¨ Gzip/Brotli å‹ç¼©
- [ ] æ·»åŠ  Cache-Control å¤´
- [ ] å‹ç¼©å’Œä¼˜åŒ–å›¾ç‰‡
- [ ] å†…è”å…³é”® CSS
- [ ] æ·»åŠ  preload å…³é”®èµ„æº

**ğŸ“ˆ ä¸­æœŸä¼˜åŒ– (Medium Term):**
- [ ] å®æ–½ä»£ç åˆ†å‰²
- [ ] é…ç½® CDN
- [ ] ä¼˜åŒ–å­—ä½“åŠ è½½
- [ ] å®æ–½æ‡’åŠ è½½
- [ ] è®¾ç½®æ€§èƒ½é¢„ç®—

**ğŸ”¬ é«˜çº§ä¼˜åŒ– (Advanced):**
- [ ] å®æ–½ Service Worker
- [ ] ä¼˜åŒ–å…³é”®æ¸²æŸ“è·¯å¾„
- [ ] å†…å­˜æ³„æ¼æ£€æµ‹
- [ ] Web Workers ä¼˜åŒ–
- [ ] æ€§èƒ½ç›‘æ§ä½“ç³»

---

> **æ›´æ–°æ—¶é—´**: 2024å¹´12æœˆ  
> **è¦†ç›–èŒƒå›´**: å…¨æ ˆå‰ç«¯æ€§èƒ½ä¼˜åŒ–  
> **æŠ€æœ¯æ·±åº¦**: åˆçº§åˆ°é«˜çº§å…¨è¦†ç›–