# 前端性能优化面试题

> **知识体系**: 涵盖性能指标、测量工具、优化策略、实战案例等前端性能优化全方位内容  
> **适用级别**: 中高级前端开发工程师面试

## 📋 目录

- [一、核心性能指标](#一核心性能指标)
- [二、性能测量工具与方法](#二性能测量工具与方法)
- [三、网络层面性能优化](#三网络层面性能优化)
- [四、渲染性能优化](#四渲染性能优化)
- [五、运行时性能优化](#五运行时性能优化)
- [六、构建与工程化优化](#六构建与工程化优化)
- [七、内存性能优化](#七内存性能优化)
- [八、性能监控与预算](#八性能监控与预算)
- [九、实战案例分析](#九实战案例分析)

---

## 一、核心性能指标

### Web Core Vitals 详解

**1. Core Web Vitals 三大核心指标**
```
Q: 详细解释 Core Web Vitals 的三个核心指标及其优化目标？

A: Core Web Vitals 核心指标：

1. **LCP (Largest Contentful Paint) - 最大内容绘制**
   - 定义: 视窗内最大可见元素的渲染时间
   - 优化目标: ≤ 2.5秒
   - 影响因素: 服务器响应时间、资源加载、渲染阻塞
   
2. **FID (First Input Delay) - 首次输入延迟**
   - 定义: 用户首次交互到浏览器响应的时间
   - 优化目标: ≤ 100毫秒
   - 影响因素: JavaScript 执行时间、主线程阻塞
   
3. **CLS (Cumulative Layout Shift) - 累积布局偏移**
   - 定义: 页面加载期间意外布局偏移的累积分数
   - 优化目标: ≤ 0.1
   - 影响因素: 图片尺寸、动态内容、字体加载

测量代码示例：
import { getCLS, getFID, getLCP } from 'web-vitals';

getCLS(console.log); // Cumulative Layout Shift
getFID(console.log); // First Input Delay  
getLCP(console.log); // Largest Contentful Paint
```

**2. 新一代性能指标**
```
Q: INP (Interaction to Next Paint) 如何替代 FID？有什么区别？

A: INP vs FID 对比：

**FID 局限性:**
- 只测量首次交互延迟
- 不能反映页面整体交互性能
- 仅在有用户交互时才有数据

**INP 优势:**
- 测量页面生命周期内所有交互的响应性
- 选择最差的交互延迟作为代表值
- 更全面反映用户体验

INP 测量实现：
function measureINP() {
  let interactions = [];
  
  const observer = new PerformanceObserver((list) => {
    for (const entry of list.getEntries()) {
      if (entry.name === 'click' || entry.name === 'keydown') {
        interactions.push({
          startTime: entry.startTime,
          processingStart: entry.processingStart,
          processingEnd: entry.processingEnd,
          duration: entry.duration
        });
      }
    }
  });
  
  observer.observe({ type: 'event', buffered: true });
  
  // 计算 P75 交互延迟
  function calculateINP() {
    if (interactions.length === 0) return null;
    interactions.sort((a, b) => a.duration - b.duration);
    const p75Index = Math.floor(interactions.length * 0.75);
    return interactions[p75Index].duration;
  }
}
```

**3. 其他关键性能指标**
```
Q: 除了 Core Web Vitals，还有哪些重要的性能指标？

A: 重要补充指标：

1. **TTFB (Time to First Byte)**
   - 定义: 服务器响应第一个字节的时间
   - 优化目标: < 600ms
   - 优化点: 服务器性能、CDN、数据库查询

2. **FCP (First Contentful Paint)**
   - 定义: 首次绘制任何内容的时间
   - 优化目标: < 1.8s
   - 优化点: 关键资源优先级、内联关键CSS

3. **TTI (Time to Interactive)**
   - 定义: 页面变为完全可交互的时间
   - 优化目标: < 3.8s
   - 优化点: JavaScript 代码分割、延迟非关键脚本

4. **Speed Index**
   - 定义: 页面内容视觉填充速度
   - 优化目标: < 3.4s
   - 优化点: 关键渲染路径优化、渐进式加载

性能指标监控实现：
class PerformanceMonitor {
  constructor() {
    this.metrics = new Map();
    this.initializeObservers();
  }

  initializeObservers() {
    // Navigation Timing API
    window.addEventListener('load', () => {
      const navigation = performance.getEntriesByType('navigation')[0];
      this.metrics.set('TTFB', navigation.responseStart - navigation.requestStart);
      this.metrics.set('domLoaded', navigation.domContentLoadedEventEnd - navigation.navigationStart);
      this.metrics.set('pageLoaded', navigation.loadEventEnd - navigation.navigationStart);
    });

    // Paint Timing API
    const paintObserver = new PerformanceObserver((list) => {
      for (const entry of list.getEntries()) {
        this.metrics.set(entry.name, entry.startTime);
      }
    });
    paintObserver.observe({ entryTypes: ['paint'] });

    // Long Task API
    const longTaskObserver = new PerformanceObserver((list) => {
      for (const entry of list.getEntries()) {
        console.warn(`Long task detected: ${entry.duration}ms`);
      }
    });
    longTaskObserver.observe({ entryTypes: ['longtask'] });
  }

  getMetrics() {
    return Object.fromEntries(this.metrics);
  }
}
```

---

## 二、性能测量工具与方法

### Performance API 深度应用

**4. User Timing API 实战应用**
```
Q: 如何使用 User Timing API 进行自定义性能测量？

A: User Timing API 使用方法：

**基础测量:**
// 标记时间点
performance.mark('task-start');

// 执行任务
await expensiveOperation();

// 标记结束
performance.mark('task-end');

// 测量时间间隔
performance.measure('task-duration', 'task-start', 'task-end');

// 获取测量结果
const measures = performance.getEntriesByName('task-duration');
console.log(`Task took: ${measures[0].duration}ms`);

**高级性能测量类:**
class AdvancedPerformanceTimer {
  private marks: Map<string, number> = new Map();
  private measures: Map<string, number[]> = new Map();

  // 开始测量
  start(name: string): void {
    const markName = `${name}-start`;
    performance.mark(markName);
    this.marks.set(name, performance.now());
  }

  // 结束测量
  end(name: string): number {
    const startTime = this.marks.get(name);
    if (!startTime) {
      throw new Error(`No start mark found for ${name}`);
    }

    const endTime = performance.now();
    const duration = endTime - startTime;
    
    // 记录到历史
    if (!this.measures.has(name)) {
      this.measures.set(name, []);
    }
    this.measures.get(name)!.push(duration);

    // 创建 Performance Entry
    performance.mark(`${name}-end`);
    performance.measure(name, `${name}-start`, `${name}-end`);

    return duration;
  }

  // 获取统计信息
  getStats(name: string) {
    const durations = this.measures.get(name) || [];
    if (durations.length === 0) return null;

    const sorted = [...durations].sort((a, b) => a - b);
    return {
      count: durations.length,
      avg: durations.reduce((a, b) => a + b) / durations.length,
      min: sorted[0],
      max: sorted[sorted.length - 1],
      p50: sorted[Math.floor(sorted.length * 0.5)],
      p90: sorted[Math.floor(sorted.length * 0.9)],
      p99: sorted[Math.floor(sorted.length * 0.99)]
    };
  }
}

// 使用示例
const timer = new AdvancedPerformanceTimer();

timer.start('api-call');
const response = await fetch('/api/data');
const data = await response.json();
const duration = timer.end('api-call');

console.log('API调用统计:', timer.getStats('api-call'));
```

**5. Chrome DevTools 性能分析实战**
```
Q: 如何使用 Chrome DevTools 进行深度性能分析？

A: DevTools 性能分析步骤：

**1. Performance 面板分析流程:**
1. 打开 DevTools -> Performance
2. 勾选 Screenshots、Memory、Web Vitals
3. 点击录制，操作页面，停止录制
4. 分析结果：

关键分析点：
- Main Thread: 主线程活动，查找长任务
- Network: 网络请求瀑布图
- Frames: 帧率分析，查找掉帧
- Timings: FCP、LCP等关键时间点

**2. Memory 面板内存分析:**
// 内存快照分析代码
class MemoryAnalyzer {
  takeSnapshot(label: string) {
    console.log(`📸 Memory Snapshot: ${label}`);
    console.log(`Used: ${(performance.memory.usedJSHeapSize / 1024 / 1024).toFixed(2)}MB`);
    console.log(`Total: ${(performance.memory.totalJSHeapSize / 1024 / 1024).toFixed(2)}MB`);
    console.log(`Limit: ${(performance.memory.jsHeapSizeLimit / 1024 / 1024).toFixed(2)}MB`);
  }

  monitorMemoryLeaks() {
    let baseline = performance.memory.usedJSHeapSize;
    
    setInterval(() => {
      const current = performance.memory.usedJSHeapSize;
      const growth = ((current - baseline) / 1024 / 1024).toFixed(2);
      
      if (parseFloat(growth) > 10) { // 增长超过10MB
        console.warn(`⚠️ Potential memory leak detected: +${growth}MB`);
      }
      
      baseline = current;
    }, 30000); // 每30秒检查一次
  }
}

**3. Lighthouse 程序化性能审计:**
// 使用 Lighthouse CI 进行自动化性能测试
const lighthouse = require('lighthouse');
const chromeLauncher = require('chrome-launcher');

async function runLighthouseAudit(url) {
  const chrome = await chromeLauncher.launch({chromeFlags: ['--headless']});
  const options = {
    logLevel: 'info',
    output: 'json',
    onlyCategories: ['performance'],
    port: chrome.port
  };

  const runnerResult = await lighthouse(url, options);
  const reportJson = runnerResult.report;
  const results = JSON.parse(reportJson);

  await chrome.kill();

  // 提取关键性能指标
  const metrics = results.audits;
  return {
    lcp: metrics['largest-contentful-paint'].numericValue,
    fid: metrics['max-potential-fid'].numericValue,
    cls: metrics['cumulative-layout-shift'].numericValue,
    fcp: metrics['first-contentful-paint'].numericValue,
    speed_index: metrics['speed-index'].numericValue,
    performance_score: results.categories.performance.score * 100
  };
}
```

### 性能监控自动化

**6. 真实用户监控 (RUM) 实现**
```
Q: 如何实现一套完整的真实用户性能监控系统？

A: RUM 监控系统实现：

class RealUserMonitoring {
  private endpoint: string;
  private sampleRate: number;
  private sessionId: string;

  constructor(config: {endpoint: string, sampleRate?: number}) {
    this.endpoint = config.endpoint;
    this.sampleRate = config.sampleRate || 0.1; // 10% 采样率
    this.sessionId = this.generateSessionId();
    
    if (Math.random() < this.sampleRate) {
      this.initializeMonitoring();
    }
  }

  private initializeMonitoring() {
    // 监控页面加载性能
    this.monitorPageLoad();
    
    // 监控用户交互性能
    this.monitorInteractions();
    
    // 监控资源加载性能
    this.monitorResources();
    
    // 监控错误和异常
    this.monitorErrors();
  }

  private monitorPageLoad() {
    window.addEventListener('load', () => {
      // 等待 LCP 稳定
      setTimeout(() => {
        const navigation = performance.getEntriesByType('navigation')[0] as PerformanceNavigationTiming;
        const paintEntries = performance.getEntriesByType('paint');
        
        const metrics = {
          type: 'page-load',
          url: window.location.href,
          sessionId: this.sessionId,
          timestamp: Date.now(),
          metrics: {
            // 导航时间
            dns: navigation.domainLookupEnd - navigation.domainLookupStart,
            tcp: navigation.connectEnd - navigation.connectStart,
            ttfb: navigation.responseStart - navigation.requestStart,
            domLoad: navigation.domContentLoadedEventEnd - navigation.navigationStart,
            pageLoad: navigation.loadEventEnd - navigation.navigationStart,
            
            // 绘制时间
            fp: paintEntries.find(entry => entry.name === 'first-paint')?.startTime,
            fcp: paintEntries.find(entry => entry.name === 'first-contentful-paint')?.startTime,
          },
          userAgent: navigator.userAgent,
          connection: this.getConnectionInfo()
        };

        this.sendMetrics(metrics);
      }, 3000);
    });
  }

  private monitorInteractions() {
    let interactionId = 0;
    
    const observer = new PerformanceObserver((list) => {
      for (const entry of list.getEntries()) {
        if (entry.duration > 100) { // 只记录慢交互
          this.sendMetrics({
            type: 'interaction',
            sessionId: this.sessionId,
            interactionId: ++interactionId,
            timestamp: Date.now(),
            metrics: {
              name: entry.name,
              duration: entry.duration,
              startTime: entry.startTime,
              processingStart: entry.processingStart,
              processingEnd: entry.processingEnd
            }
          });
        }
      }
    });

    observer.observe({ type: 'event', buffered: true });
  }

  private getConnectionInfo() {
    const connection = (navigator as any).connection;
    if (!connection) return null;
    
    return {
      effectiveType: connection.effectiveType,
      downlink: connection.downlink,
      rtt: connection.rtt,
      saveData: connection.saveData
    };
  }

  private async sendMetrics(data: any) {
    try {
      // 使用 sendBeacon 确保数据发送
      if (navigator.sendBeacon) {
        navigator.sendBeacon(this.endpoint, JSON.stringify(data));
      } else {
        fetch(this.endpoint, {
          method: 'POST',
          body: JSON.stringify(data),
          headers: {'Content-Type': 'application/json'},
          keepalive: true
        });
      }
    } catch (error) {
      console.error('Failed to send metrics:', error);
    }
  }
}

// 初始化监控
const rum = new RealUserMonitoring({
  endpoint: '/api/metrics',
  sampleRate: 0.1
});
```

---

## 三、网络层面性能优化

### HTTP 协议优化

**7. HTTP/2 和 HTTP/3 性能优势**
```
Q: HTTP/2 和 HTTP/3 相比 HTTP/1.1 有哪些性能优势？如何优化？

A: HTTP 版本性能对比：

**HTTP/1.1 限制:**
- 队头阻塞 (Head-of-Line Blocking)
- 连接数限制 (通常6个并发连接)
- 无头部压缩
- 无服务器推送

**HTTP/2 优势:**
1. **多路复用**: 单连接并发处理多个请求
2. **头部压缩**: HPACK 算法减少头部大小
3. **服务器推送**: 主动推送关键资源
4. **请求优先级**: 关键资源优先加载

HTTP/2 优化策略：
// 1. 避免域名分片 (Domain Sharding)
// HTTP/1.1 时代的优化在 HTTP/2 中反而有害
// 错误做法
const domains = ['cdn1.example.com', 'cdn2.example.com', 'cdn3.example.com'];

// HTTP/2 正确做法 - 使用单一域名
const optimizedLoader = {
  loadResources(urls) {
    // HTTP/2 可以高效处理大量并发请求
    return Promise.all(urls.map(url => fetch(url)));
  },
  
  // 2. 合理使用服务器推送
  enableServerPush() {
    // 服务器端配置示例 (nginx)
    /*
    location / {
      http2_push /css/critical.css;
      http2_push /js/critical.js;
      http2_push /fonts/main.woff2;
    }
    */
  }
};

**HTTP/3 (QUIC) 优势:**
1. **0-RTT**: 零往返时间连接
2. **无队头阻塞**: 基于 UDP，流级别独立
3. **连接迁移**: 网络切换时保持连接
4. **内置加密**: 默认 TLS 1.3

HTTP/3 检测和优化：
class HTTP3Detector {
  static async checkSupport() {
    try {
      const response = await fetch('/api/test', {
        // 通过 Alt-Svc 头检测 HTTP/3 支持
        headers: {'Alt-Used': 'h3-29'}
      });
      
      return response.headers.get('alt-svc')?.includes('h3');
    } catch {
      return false;
    }
  }

  static optimizeForHTTP3() {
    // HTTP/3 优化建议
    return {
      // 1. 减少连接数，利用多路复用
      maxConcurrentConnections: 1,
      
      // 2. 优化 TLS 配置
      tlsConfig: {
        earlyData: true, // 启用 0-RTT
        sessionResumption: true
      },
      
      // 3. 预连接关键域名
      preconnectDomains: ['api.example.com', 'cdn.example.com']
    };
  }
}
```

**8. 资源压缩与编码优化**
```
Q: Gzip、Brotli、WebP 等压缩技术如何选择和配置？

A: 压缩技术对比与选择：

**文本压缩对比:**
压缩算法 | 压缩率 | 压缩速度 | 解压速度 | 浏览器支持
--------|--------|----------|----------|----------
Gzip    | 70-80% | 快       | 快       | 100%
Brotli  | 75-85% | 慢       | 快       | 95%+
Zstd    | 80-90% | 中等     | 很快     | 限制

**智能压缩策略实现:**
class CompressionOptimizer {
  private static readonly COMPRESSION_CONFIG = {
    brotli: {
      textTypes: ['text/html', 'text/css', 'application/javascript', 'application/json'],
      quality: 6, // 平衡压缩率和速度
      minSize: 1024 // 小于1KB不压缩
    },
    
    gzip: {
      level: 6,
      fallback: true // Brotli 不支持时回退
    },
    
    webp: {
      quality: 80,
      supportCheck: true
    }
  };

  // 服务端压缩配置 (Express.js 示例)
  static setupServerCompression(app) {
    const compression = require('compression');
    const expressStaticGzip = require('express-static-gzip');

    // 动态内容压缩
    app.use(compression({
      filter: (req, res) => {
        // 检查客户端支持
        const acceptEncoding = req.headers['accept-encoding'] || '';
        
        if (acceptEncoding.includes('br')) {
          res.setHeader('Content-Encoding', 'br');
          return true;
        } else if (acceptEncoding.includes('gzip')) {
          res.setHeader('Content-Encoding', 'gzip');
          return true;
        }
        
        return false;
      },
      
      level: 6, // Gzip 压缩级别
      threshold: 1024 // 最小压缩文件大小
    }));

    // 静态文件预压缩
    app.use(expressStaticGzip('public', {
      enableBrotli: true,
      orderPreference: ['br', 'gz'],
      setHeaders: (res, path) => {
        // 设置缓存策略
        if (path.endsWith('.js') || path.endsWith('.css')) {
          res.setHeader('Cache-Control', 'public, max-age=31536000'); // 1年
        }
      }
    }));
  }

  // 客户端图片格式检测
  static detectImageSupport() {
    const canvas = document.createElement('canvas');
    canvas.width = 1;
    canvas.height = 1;
    
    return {
      webp: canvas.toDataURL('image/webp').startsWith('data:image/webp'),
      avif: canvas.toDataURL('image/avif').startsWith('data:image/avif'),
      jxl: 'ImageDecoder' in window // JPEG XL 检测
    };
  }

  // 自适应图片加载
  static createResponsiveImageLoader() {
    const support = this.detectImageSupport();
    
    return {
      getOptimalImageUrl(baseUrl, width) {
        const params = new URLSearchParams({
          w: width.toString(),
          q: '80' // 质量
        });

        // 按优先级选择格式
        if (support.avif) {
          params.set('f', 'avif');
        } else if (support.webp) {
          params.set('f', 'webp');
        } else {
          params.set('f', 'jpg');
        }

        return `${baseUrl}?${params}`;
      }
    };
  }
}

// 使用示例
const imageLoader = CompressionOptimizer.createResponsiveImageLoader();
const optimizedUrl = imageLoader.getOptimalImageUrl('/api/image/hero', 1200);
```

### CDN 与缓存策略

**9. 智能缓存策略设计**
```
Q: 如何设计一套完整的前端缓存策略？

A: 多层级缓存策略：

**缓存层级架构:**
1. **浏览器缓存** (Browser Cache)
2. **CDN 缓存** (Edge Cache)  
3. **服务器缓存** (Origin Cache)
4. **应用缓存** (Application Cache)

**智能缓存策略实现:**
class IntelligentCacheStrategy {
  private static readonly CACHE_RULES = {
    // 静态资源 - 长期缓存 + 版本控制
    static: {
      'js': { maxAge: 31536000, immutable: true }, // 1年
      'css': { maxAge: 31536000, immutable: true },
      'images': { maxAge: 2592000, staleWhileRevalidate: 86400 }, // 30天 + SWR
      'fonts': { maxAge: 31536000, crossOrigin: true }
    },
    
    // 动态内容 - 短期缓存 + 验证
    dynamic: {
      'html': { maxAge: 0, mustRevalidate: true },
      'api': { maxAge: 300, staleWhileRevalidate: 60 }, // 5分钟 + 1分钟SWR
      'user-data': { maxAge: 0, noCache: true }
    }
  };

  // 生成缓存头
  static generateCacheHeaders(resourceType: string, subType: string) {
    const rule = this.CACHE_RULES[resourceType]?.[subType];
    if (!rule) return {};

    const headers = {
      'Cache-Control': this.buildCacheControl(rule),
      'Vary': 'Accept-Encoding'
    };

    // 添加 ETag 用于验证
    if (rule.mustRevalidate || rule.staleWhileRevalidate) {
      headers['ETag'] = `W/"${Date.now()}"`;
    }

    // 预加载提示
    if (rule.immutable) {
      headers['Link'] = '</critical.css>; rel=preload; as=style';
    }

    return headers;
  }

  private static buildCacheControl(rule: any): string {
    const directives = [];

    if (rule.noCache) {
      directives.push('no-cache');
    } else if (rule.maxAge) {
      directives.push(`max-age=${rule.maxAge}`);
    }

    if (rule.mustRevalidate) {
      directives.push('must-revalidate');
    }

    if (rule.immutable) {
      directives.push('immutable');
    }

    if (rule.staleWhileRevalidate) {
      directives.push(`stale-while-revalidate=${rule.staleWhileRevalidate}`);
    }

    return directives.join(', ');
  }

  // Service Worker 缓存策略
  static implementSWCaching() {
    return `
    // SW 中的智能缓存策略
    const CACHE_NAME = 'app-cache-v1';
    const STATIC_CACHE = 'static-cache-v1';
    const DYNAMIC_CACHE = 'dynamic-cache-v1';

    // 缓存策略映射
    const cacheStrategies = {
      // 静态资源 - Cache First
      '/static/': 'cacheFirst',
      
      // API 请求 - Network First with Cache Fallback
      '/api/': 'networkFirst',
      
      // 页面 - Stale While Revalidate
      '/': 'staleWhileRevalidate'
    };

    self.addEventListener('fetch', event => {
      const url = new URL(event.request.url);
      const strategy = getStrategy(url.pathname);
      
      event.respondWith(
        handleRequest(event.request, strategy)
      );
    });

    async function handleRequest(request, strategy) {
      switch (strategy) {
        case 'cacheFirst':
          return cacheFirst(request);
        case 'networkFirst':
          return networkFirst(request);
        case 'staleWhileRevalidate':
          return staleWhileRevalidate(request);
        default:
          return fetch(request);
      }
    }

    async function cacheFirst(request) {
      const cached = await caches.match(request);
      if (cached) return cached;
      
      const fresh = await fetch(request);
      const cache = await caches.open(STATIC_CACHE);
      cache.put(request, fresh.clone());
      return fresh;
    }
    `;
  }
}
```

---

## 四、渲染性能优化

### 浏览器渲染机制深度解析

**10. 关键渲染路径优化**
```
Q: 详细分析浏览器的关键渲染路径，如何进行优化？

A: 关键渲染路径分析：

**渲染流水线 (Critical Rendering Path):**
1. **HTML 解析** → DOM 树构建
2. **CSS 解析** → CSSOM 树构建  
3. **JavaScript 执行** → DOM/CSSOM 修改
4. **布局计算** (Layout/Reflow) → 几何信息计算
5. **绘制** (Paint) → 像素填充
6. **合成** (Composite) → 图层合并

**优化策略实现:**
class CriticalRenderingPathOptimizer {
  // 1. HTML 解析优化
  static optimizeHTMLParsing() {
    return {
      // 内联关键 CSS
      inlineCriticalCSS: `
        <style>
        /* Above-the-fold 关键样式 */
        .hero { font-size: 2rem; color: #333; }
        .nav { display: flex; justify-content: space-between; }
        </style>
      `,
      
      // 预加载关键资源
      preloadResources: `
        <link rel="preload" href="/fonts/main.woff2" as="font" type="font/woff2" crossorigin>
        <link rel="preload" href="/css/critical.css" as="style">
        <link rel="preload" href="/js/critical.js" as="script">
      `,
      
      // DNS 预解析
      dnsPreconnect: `
        <link rel="dns-prefetch" href="//fonts.googleapis.com">
        <link rel="preconnect" href="//api.example.com" crossorigin>
      `
    };
  }

  // 2. CSS 渲染阻塞优化
  static optimizeCSSBlocking() {
    // 关键CSS内联，非关键CSS异步加载
    const loadNonCriticalCSS = (href: string) => {
      const link = document.createElement('link');
      link.rel = 'stylesheet';
      link.href = href;
      link.media = 'print'; // 设置为print媒体，避免阻塞渲染
      
      link.onload = () => {
        link.media = 'all'; // 加载完成后应用到所有媒体
      };
      
      document.head.appendChild(link);
    };

    // 媒体查询优化
    const loadResponsiveCSS = () => {
      const queries = [
        { media: '(max-width: 768px)', href: '/css/mobile.css' },
        { media: '(min-width: 769px)', href: '/css/desktop.css' },
        { media: 'print', href: '/css/print.css' }
      ];

      queries.forEach(({ media, href }) => {
        const link = document.createElement('link');
        link.rel = 'stylesheet';
        link.href = href;
        link.media = media;
        document.head.appendChild(link);
      });
    };

    return { loadNonCriticalCSS, loadResponsiveCSS };
  }

  // 3. JavaScript 解析阻塞优化
  static optimizeJavaScriptBlocking() {
    return {
      // 脚本加载策略
      scriptLoadingStrategies: {
        // 关键脚本 - 立即执行
        critical: '<script src="/js/critical.js"></script>',
        
        // 非关键脚本 - 异步加载
        nonCritical: '<script src="/js/analytics.js" async></script>',
        
        // 延迟脚本 - DOMContentLoaded 后执行
        deferred: '<script src="/js/enhancements.js" defer></script>',
        
        // 模块脚本 - 现代浏览器优化
        module: '<script type="module" src="/js/main.mjs"></script>'
      },

      // 动态脚本加载
      loadScriptAsync: (src: string, onLoad?: () => void) => {
        const script = document.createElement('script');
        script.src = src;
        script.async = true;
        
        if (onLoad) {
          script.onload = onLoad;
        }
        
        document.head.appendChild(script);
      },

      // 脚本优先级调度
      prioritizeScripts: () => {
        // 使用 Scheduler API (实验性)
        if ('scheduler' in window && 'postTask' in (window as any).scheduler) {
          (window as any).scheduler.postTask(() => {
            // 高优先级任务
            loadCriticalScripts();
          }, { priority: 'user-blocking' });

          (window as any).scheduler.postTask(() => {
            // 低优先级任务
            loadAnalytics();
          }, { priority: 'background' });
        }
      }
    };
  }
}
```

### 重排重绘优化

**11. Layout Thrashing 预防**
```
Q: 什么是 Layout Thrashing？如何避免频繁的重排重绘？

A: Layout Thrashing 优化策略：

**触发重排的属性:**
- 盒模型: width, height, padding, margin, border
- 定位: top, left, right, bottom, position
- 文本: font-size, font-family, line-height, text-align
- 布局: display, float, clear, overflow

**高性能 DOM 操作实现:**
class PerformantDOMManager {
  private rafId: number | null = null;
  private pendingUpdates: (() => void)[] = [];

  // 批量 DOM 更新
  batchDOMUpdates(updates: (() => void)[]) {
    // 使用 DocumentFragment 减少重排
    const fragment = document.createDocumentFragment();
    
    updates.forEach(update => {
      update();
    });
    
    // 一次性插入 DOM
    document.body.appendChild(fragment);
  }

  // 读写分离优化
  optimizedStyleBatch() {
    const elements = document.querySelectorAll('.item');
    
    // ❌ 错误做法 - 读写交替导致强制同步布局
    elements.forEach(el => {
      el.style.left = el.offsetLeft + 10 + 'px'; // 读取 offsetLeft 触发重排
    });

    // ✅ 正确做法 - 先读取所有，再批量写入
    const positions = Array.from(elements).map(el => el.offsetLeft);
    elements.forEach((el, i) => {
      el.style.left = positions[i] + 10 + 'px';
    });
  }

  // 使用 CSS Transform 代替位置属性
  animateWithTransform(element: HTMLElement, x: number, y: number) {
    // ❌ 触发重排
    // element.style.left = x + 'px';
    // element.style.top = y + 'px';

    // ✅ 只触发合成
    element.style.transform = `translate3d(${x}px, ${y}px, 0)`;
    element.style.willChange = 'transform'; // 提示浏览器创建合成层
  }

  // 虚拟滚动实现
  createVirtualScrolling(container: HTMLElement, items: any[], itemHeight: number) {
    const containerHeight = container.clientHeight;
    const visibleCount = Math.ceil(containerHeight / itemHeight) + 2; // 预渲染缓冲

    let scrollTop = 0;

    const updateVisibleItems = () => {
      const startIndex = Math.floor(scrollTop / itemHeight);
      const endIndex = Math.min(startIndex + visibleCount, items.length);

      // 清空容器
      container.innerHTML = '';

      // 创建可见项
      for (let i = startIndex; i < endIndex; i++) {
        const item = document.createElement('div');
        item.style.position = 'absolute';
        item.style.top = i * itemHeight + 'px';
        item.style.height = itemHeight + 'px';
        item.textContent = items[i];
        container.appendChild(item);
      }

      // 设置容器总高度
      container.style.height = items.length * itemHeight + 'px';
    };

    container.addEventListener('scroll', () => {
      scrollTop = container.scrollTop;
      
      // 节流更新
      if (this.rafId) {
        cancelAnimationFrame(this.rafId);
      }
      
      this.rafId = requestAnimationFrame(updateVisibleItems);
    });

    updateVisibleItems();
  }

  // FastDOM 模式实现
  fastDOMScheduler() {
    const readQueue: (() => void)[] = [];
    const writeQueue: (() => void)[] = [];
    let scheduled = false;

    const flush = () => {
      // 先执行所有读取操作
      while (readQueue.length) {
        const task = readQueue.shift()!;
        task();
      }

      // 再执行所有写入操作
      while (writeQueue.length) {
        const task = writeQueue.shift()!;
        task();
      }

      scheduled = false;
    };

    return {
      read: (task: () => void) => {
        readQueue.push(task);
        if (!scheduled) {
          scheduled = true;
          requestAnimationFrame(flush);
        }
      },

      write: (task: () => void) => {
        writeQueue.push(task);
        if (!scheduled) {
          scheduled = true;
          requestAnimationFrame(flush);
        }
      }
    };
  }
}

// 使用示例
const domManager = new PerformantDOMManager();
const fastDOM = domManager.fastDOMScheduler();

// 高性能 DOM 操作
fastDOM.read(() => {
  const width = element.offsetWidth; // 读取操作
});

fastDOM.write(() => {
  element.style.width = '200px'; // 写入操作
});
```

### CSS 性能优化

**12. CSS 渲染性能优化**
```
Q: 如何从 CSS 层面优化渲染性能？

A: CSS 性能优化策略：

**选择器性能优化:**
class CSSPerformanceOptimizer {
  // 选择器性能排序 (从快到慢)
  static readonly SELECTOR_PERFORMANCE = {
    // 最快 - 直接匹配
    id: '#header { }',
    class: '.nav-item { }',
    
    // 较快 - 简单组合
    childCombinator: '.nav > .item { }',
    adjacentSibling: '.item + .item { }',
    
    // 中等 - 后代选择器 (避免深层嵌套)
    descendant: '.nav .item { }', // ✅ 2层可接受
    deepNesting: '.app .nav .menu .item .link { }', // ❌ 避免
    
    // 最慢 - 复杂属性选择器
    complexAttribute: 'input[type="text"][disabled]:not(:focus) { }',
    universalSelector: '* { }' // ❌ 避免全局选择器
  };

  // GPU 加速属性利用
  static optimizeForGPUAcceleration() {
    return {
      // 触发硬件加速的属性
      gpuAccelerated: [
        'transform: translateZ(0)', // 强制创建合成层
        'transform: translate3d(0,0,0)',
        'will-change: transform',
        'opacity',
        'filter',
        'backdrop-filter'
      ],

      // 避免破坏合成层的属性
      avoidLayerBreaking: [
        'box-shadow: 0 0 10px rgba(0,0,0,0.1)', // ❌ 在合成层元素上使用
        'border-radius: 8px', // ❌ 动画时避免
        'clip-path: polygon(...)', // ❌ 复杂路径避免动画
      ],

      // 优化动画实现
      optimizedAnimation: `
        /* ❌ 触发重排的动画 */
        @keyframes badSlide {
          from { left: 0; }
          to { left: 100px; }
        }

        /* ✅ 只触发合成的动画 */
        @keyframes goodSlide {
          from { transform: translateX(0); }
          to { transform: translateX(100px); }
        }

        .animated-element {
          will-change: transform; /* 提前告知浏览器 */
          transform: translateZ(0); /* 创建合成层 */
        }

        .animated-element.animate {
          animation: goodSlide 0.3s ease-out;
        }
      `
    };
  }

  // 关键CSS提取
  static extractCriticalCSS() {
    const criticalCSS = {
      // Above-the-fold 样式
      aboveTheFold: `
        /* 页面头部关键样式 */
        body { margin: 0; font-family: system-ui, sans-serif; }
        .header { display: flex; height: 60px; background: #fff; }
        .hero { height: 400px; background: linear-gradient(45deg, #blue, #purple); }
        
        /* 关键字体 */
        @font-face {
          font-family: 'Primary';
          src: url('/fonts/primary.woff2') format('woff2');
          font-display: swap; /* 避免FOIT */
        }
      `,

      // 内联关键CSS的策略
      inlineStrategy: `
        <style>
        /* 内联关键CSS，减少渲染阻塞 */
        ${this.aboveTheFold}
        </style>
        
        <!-- 异步加载非关键CSS -->
        <link rel="preload" href="/css/non-critical.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="/css/non-critical.css"></noscript>
      `
    };

    return criticalCSS;
  }

  // 响应式图片优化
  static createResponsiveImageCSS() {
    return `
      /* 响应式图片容器 */
      .responsive-image {
        position: relative;
        overflow: hidden;
        background: #f0f0f0; /* 占位背景 */
      }

      .responsive-image img {
        width: 100%;
        height: auto;
        object-fit: cover;
        transition: opacity 0.3s ease;
        opacity: 0; /* 初始透明，加载完成后显示 */
      }

      .responsive-image img.loaded {
        opacity: 1;
      }

      /* 使用 aspect-ratio 保持宽高比 */
      .aspect-16-9 {
        aspect-ratio: 16 / 9;
      }

      .aspect-4-3 {
        aspect-ratio: 4 / 3;
      }

      /* 渐进式图片加载 */
      .progressive-image {
        background-size: cover;
        background-position: center;
        filter: blur(5px); /* 低分辨率占位图模糊效果 */
        transition: filter 0.3s ease;
      }

      .progressive-image.loaded {
        filter: none;
      }

      /* 懒加载占位符 */
      .lazy-placeholder {
        background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
        background-size: 200% 100%;
        animation: loading 1.5s infinite;
      }

      @keyframes loading {
        0% { background-position: 200% 0; }
        100% { background-position: -200% 0; }
      }
    `;
  }
}
```

---

## 五、运行时性能优化

### JavaScript 执行优化

**13. JavaScript 引擎优化技巧**
```
Q: 如何针对 V8 引擎特性优化 JavaScript 代码？

A: V8 引擎优化策略：

**对象形状 (Hidden Classes) 优化:**
class V8Optimizer {
  // ✅ 单态 (Monomorphic) - 最优性能
  static createOptimizedObjects() {
    class Point {
      constructor(x: number, y: number) {
        this.x = x; // 固定属性顺序
        this.y = y; // V8 可以预测对象形状
      }
    }

    // 批量创建相同结构的对象
    const points = Array.from({ length: 1000 }, (_, i) => 
      new Point(i, i * 2)
    );

    return points;
  }

  // ❌ 多态 (Polymorphic) - 性能较差
  static avoidPolymorphicObjects() {
    const objects = [
      { x: 1, y: 2 },           // 形状 1
      { x: 1, y: 2, z: 3 },     // 形状 2 - 不同属性
      { y: 2, x: 1 },           // 形状 3 - 不同顺序
    ];

    // V8 无法优化，每次都要查找属性
    objects.forEach(obj => console.log(obj.x + obj.y));
  }

  // 数组优化
  static optimizeArrays() {
    // ✅ 单一类型数组 - SMI (Small Integer) 优化
    const intArray = new Array(1000).fill(0).map((_, i) => i);
    
    // ✅ 预分配大小
    const preallocated = new Array(1000);
    for (let i = 0; i < 1000; i++) {
      preallocated[i] = i * 2;
    }

    // ❌ 避免稀疏数组
    const sparse = [];
    sparse[999] = 'value'; // 创建稀疏数组，性能差

    // ✅ 使用 TypedArray 处理数值
    const float32Array = new Float32Array(1000);
    for (let i = 0; i < 1000; i++) {
      float32Array[i] = Math.random();
    }

    return { intArray, preallocated, float32Array };
  }

  // 函数优化
  static optimizeFunctions() {
    // ✅ 单态函数 - V8 可以内联优化
    function addNumbers(a: number, b: number): number {
      return a + b; // 类型稳定，可以优化
    }

    // ❌ 多态函数 - 性能较差
    function addAny(a: any, b: any): any {
      return a + b; // 类型不确定，难以优化
    }

    // ✅ 避免 try-catch 包裹热代码
    function optimizedLoop(items: number[]) {
      let sum = 0;
      // 将 try-catch 移出循环
      for (let i = 0; i < items.length; i++) {
        sum += items[i];
      }
      return sum;
    }

    // ❌ try-catch 阻止优化
    function unoptimizedLoop(items: number[]) {
      let sum = 0;
      for (let i = 0; i < items.length; i++) {
        try {
          sum += items[i]; // try-catch 阻止内联优化
        } catch (e) {
          // error handling
        }
      }
      return sum;
    }

    return { addNumbers, optimizedLoop };
  }
}
```

### 异步编程优化

**14. 高性能异步处理**
```
Q: 如何优化异步操作的性能，避免阻塞主线程？

A: 异步性能优化策略：

**时间分片 (Time Slicing) 实现:**
class AsyncPerformanceOptimizer {
  // 时间分片处理大量数据
  static async processLargeDataset<T, R>(
    data: T[],
    processor: (item: T) => R,
    chunkSize = 100,
    delay = 5
  ): Promise<R[]> {
    const results: R[] = [];
    
    for (let i = 0; i < data.length; i += chunkSize) {
      const chunk = data.slice(i, i + chunkSize);
      
      // 处理当前块
      const chunkResults = chunk.map(processor);
      results.push(...chunkResults);
      
      // 让出主线程，避免阻塞 UI
      if (i + chunkSize < data.length) {
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }
    
    return results;
  }

  // 使用 MessageChannel 进行非阻塞通信
  static createMessageChannelScheduler() {
    const channel = new MessageChannel();
    const taskQueue: (() => void)[] = [];
    let isProcessing = false;

    channel.port2.onmessage = () => {
      if (taskQueue.length > 0 && !isProcessing) {
        isProcessing = true;
        const task = taskQueue.shift()!;
        
        try {
          task();
        } finally {
          isProcessing = false;
          if (taskQueue.length > 0) {
            channel.port1.postMessage(null);
          }
        }
      }
    };

    return {
      schedule: (task: () => void) => {
        taskQueue.push(task);
        if (!isProcessing) {
          channel.port1.postMessage(null);
        }
      }
    };
  }

  // 优先级任务调度
  static createPriorityScheduler() {
    const queues = {
      immediate: [] as (() => void)[],
      high: [] as (() => void)[],
      normal: [] as (() => void)[],
      low: [] as (() => void)[]
    };

    let isScheduled = false;

    const flushWork = () => {
      const runQueue = (queue: (() => void)[]) => {
        while (queue.length > 0) {
          const task = queue.shift()!;
          const start = performance.now();
          
          task();
          
          // 如果单个任务执行超过 5ms，让出控制权
          if (performance.now() - start > 5) {
            break;
          }
        }
      };

      // 按优先级执行任务
      runQueue(queues.immediate);
      runQueue(queues.high);
      runQueue(queues.normal);
      runQueue(queues.low);

      // 检查是否还有待执行任务
      const hasWork = Object.values(queues).some(queue => queue.length > 0);
      if (hasWork) {
        requestIdleCallback(flushWork);
      } else {
        isScheduled = false;
      }
    };

    return {
      schedule: (task: () => void, priority: keyof typeof queues = 'normal') => {
        queues[priority].push(task);
        
        if (!isScheduled) {
          isScheduled = true;
          if (priority === 'immediate') {
            setTimeout(flushWork, 0);
          } else {
            requestIdleCallback(flushWork);
          }
        }
      }
    };
  }

  // 智能预加载
  static createIntelligentPreloader() {
    const cache = new Map<string, Promise<any>>();
    const priorityQueue = new Set<string>();

    return {
      // 预加载资源
      preload: async (url: string, priority: 'high' | 'low' = 'low') => {
        if (cache.has(url)) {
          return cache.get(url);
        }

        const promise = fetch(url).then(res => res.json());
        cache.set(url, promise);

        if (priority === 'high') {
          priorityQueue.add(url);
        }

        return promise;
      },

      // 智能预测下一个请求
      predictNext: (currentUrl: string, userBehavior: any) => {
        const predictions = this.analyzeUserBehavior(userBehavior);
        
        predictions.forEach(url => {
          // 在空闲时间预加载
          requestIdleCallback(() => {
            this.preload(url, 'low');
          });
        });
      },

      // 用户行为分析 (简化版)
      analyzeUserBehavior: (behavior: any) => {
        // 基于用户历史行为预测下一个可能访问的资源
        const patterns = behavior.clickHistory || [];
        return patterns.slice(-3).map((item: any) => item.nextLikelyUrl);
      }
    };
  }
}

// 使用示例
const scheduler = AsyncPerformanceOptimizer.createPriorityScheduler();

// 高优先级任务 - 用户交互响应
scheduler.schedule(() => {
  updateUI();
}, 'high');

// 低优先级任务 - 数据分析
scheduler.schedule(() => {
  analyzeUserBehavior();
}, 'low');
```

### Web Workers 性能优化

**15. Web Workers 最佳实践**
```
Q: 如何合理使用 Web Workers 进行性能优化？

A: Web Workers 优化策略：

**Worker 池管理:**
class WorkerPoolManager {
  private workers: Worker[] = [];
  private availableWorkers: Worker[] = [];
  private taskQueue: Array<{
    data: any;
    resolve: (value: any) => void;
    reject: (error: any) => void;
  }> = [];

  constructor(private workerScript: string, private poolSize = 4) {
    this.initializePool();
  }

  private initializePool() {
    for (let i = 0; i < this.poolSize; i++) {
      const worker = new Worker(this.workerScript);
      
      worker.onmessage = (e) => {
        this.handleWorkerMessage(worker, e.data);
      };
      
      worker.onerror = (error) => {
        console.error('Worker error:', error);
      };

      this.workers.push(worker);
      this.availableWorkers.push(worker);
    }
  }

  private handleWorkerMessage(worker: Worker, result: any) {
    // 归还 worker 到可用池
    this.availableWorkers.push(worker);
    
    // 处理队列中的下一个任务
    this.processQueue();
    
    return result;
  }

  private processQueue() {
    if (this.taskQueue.length > 0 && this.availableWorkers.length > 0) {
      const task = this.taskQueue.shift()!;
      const worker = this.availableWorkers.shift()!;
      
      this.executeTask(worker, task);
    }
  }

  private executeTask(worker: Worker, task: any) {
    const taskId = Math.random().toString(36);
    
    const messageHandler = (e: MessageEvent) => {
      if (e.data.taskId === taskId) {
        worker.removeEventListener('message', messageHandler);
        
        if (e.data.error) {
          task.reject(new Error(e.data.error));
        } else {
          task.resolve(e.data.result);
        }
        
        this.handleWorkerMessage(worker, e.data);
      }
    };

    worker.addEventListener('message', messageHandler);
    worker.postMessage({ ...task.data, taskId });
  }

  async execute(data: any): Promise<any> {
    return new Promise((resolve, reject) => {
      const task = { data, resolve, reject };
      
      if (this.availableWorkers.length > 0) {
        const worker = this.availableWorkers.shift()!;
        this.executeTask(worker, task);
      } else {
        this.taskQueue.push(task);
      }
    });
  }

  terminate() {
    this.workers.forEach(worker => worker.terminate());
    this.workers = [];
    this.availableWorkers = [];
    this.taskQueue = [];
  }
}

// Worker 脚本示例 (worker.js)
const workerScript = `
  // 高性能计算示例
  function fibonacci(n) {
    if (n <= 1) return n;
    return fibonacci(n - 1) + fibonacci(n - 2);
  }

  function processImageData(imageData) {
    const data = imageData.data;
    // 图像处理算法 (如高斯模糊)
    for (let i = 0; i < data.length; i += 4) {
      const r = data[i];
      const g = data[i + 1];
      const b = data[i + 2];
      
      // 灰度处理
      const gray = 0.299 * r + 0.587 * g + 0.114 * b;
      data[i] = data[i + 1] = data[i + 2] = gray;
    }
    
    return imageData;
  }

  self.onmessage = function(e) {
    const { taskId, type, payload } = e.data;
    let result;
    
    try {
      switch (type) {
        case 'fibonacci':
          result = fibonacci(payload.n);
          break;
        case 'imageProcessing':
          result = processImageData(payload.imageData);
          break;
        default:
          throw new Error('Unknown task type');
      }
      
      self.postMessage({ taskId, result });
    } catch (error) {
      self.postMessage({ taskId, error: error.message });
    }
  };
`;

// 使用示例
const workerPool = new WorkerPoolManager('data:text/javascript,' + encodeURIComponent(workerScript));

// 计算密集型任务
async function computeFibonacci(n: number) {
  const result = await workerPool.execute({
    type: 'fibonacci',
    payload: { n }
  });
  return result;
}

// 图像处理任务
async function processImage(canvas: HTMLCanvasElement) {
  const ctx = canvas.getContext('2d')!;
  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
  
  const processed = await workerPool.execute({
    type: 'imageProcessing',
    payload: { imageData }
  });
  
  ctx.putImageData(processed, 0, 0);
}
```

---

## 六、构建与工程化优化

### 代码分割与懒加载

**16. 智能代码分割策略**
```
Q: 如何设计最优的代码分割策略？

A: 代码分割最佳实践：

**路由级别分割:**
// React Router + Webpack 动态导入
const AppRouter = () => {
  // 路由级别懒加载
  const Home = lazy(() => import('./pages/Home'));
  const Profile = lazy(() => import('./pages/Profile'));
  const Settings = lazy(() => import('./pages/Settings'));
  
  // 预加载策略
  const preloadRoute = (routeImport: () => Promise<any>) => {
    // 在空闲时间预加载
    requestIdleCallback(() => {
      routeImport();
    });
  };

  return (
    <Router>
      <Suspense fallback={<LoadingSpinner />}>
        <Routes>
          <Route path="/" element={<Home />} />
          <Route 
            path="/profile" 
            element={<Profile />}
            onMouseEnter={() => preloadRoute(() => import('./pages/Settings'))}
          />
          <Route path="/settings" element={<Settings />} />
        </Routes>
      </Suspense>
    </Router>
  );
};

**组件级别分割:**
class ComponentCodeSplitting {
  // 条件性组件加载
  static createConditionalComponent() {
    const HeavyChart = lazy(() => 
      import('./HeavyChart').then(module => ({
        default: module.HeavyChart
      }))
    );

    return function DataVisualization({ showChart, data }: any) {
      return (
        <div>
          <DataSummary data={data} />
          {showChart && (
            <Suspense fallback={<ChartSkeleton />}>
              <HeavyChart data={data} />
            </Suspense>
          )}
        </div>
      );
    };
  }

  // 功能模块分割
  static createFeatureSplitting() {
    const AdvancedEditor = lazy(() =>
      import('./AdvancedEditor').then(module => ({
        default: module.AdvancedEditor
      }))
    );

    return function Editor({ mode }: { mode: 'basic' | 'advanced' }) {
      if (mode === 'basic') {
        return <BasicEditor />;
      }

      return (
        <Suspense fallback={<EditorSkeleton />}>
          <AdvancedEditor />
        </Suspense>
      );
    };
  }
}

**Webpack 分包优化配置:**
// webpack.config.js
module.exports = {
  optimization: {
    splitChunks: {
      chunks: 'all',
      cacheGroups: {
        // 第三方库分包
        vendor: {
          test: /[\\/]node_modules[\\/]/,
          name: 'vendors',
          priority: 10,
          chunks: 'all',
        },
        
        // 公共代码分包
        common: {
          name: 'common',
          minChunks: 2,
          priority: 5,
          chunks: 'all',
          enforce: true
        },
        
        // 大型库单独分包
        react: {
          test: /[\\/]node_modules[\\/](react|react-dom)[\\/]/,
          name: 'react',
          priority: 20,
          chunks: 'all',
        },
        
        // UI 库分包
        antd: {
          test: /[\\/]node_modules[\\/]antd[\\/]/,
          name: 'antd',
          priority: 15,
          chunks: 'all',
        }
      }
    },
    
    // 运行时代码分离
    runtimeChunk: {
      name: 'runtime'
    }
  }
};
```

### Tree Shaking 优化

**17. 高效 Tree Shaking 配置**
```
Q: 如何确保 Tree Shaking 达到最佳效果？

A: Tree Shaking 优化技巧：

**ESM 模块优化:**
// ✅ 支持 Tree Shaking 的模块写法
// utils/math.js
export const add = (a, b) => a + b;
export const subtract = (a, b) => a - b;
export const multiply = (a, b) => a * b;

// 避免默认导出大对象
// ❌ 不利于 Tree Shaking
export default {
  add,
  subtract,
  multiply
};

// ✅ 分别导出
export { add, subtract, multiply };

**包体积分析与优化:**
class BundleAnalyzer {
  // Webpack Bundle Analyzer 配置
  static getAnalyzerConfig() {
    return {
      plugins: [
        new BundleAnalyzerPlugin({
          analyzerMode: process.env.NODE_ENV === 'production' ? 'static' : 'server',
          reportFilename: 'bundle-report.html',
          openAnalyzer: false,
          generateStatsFile: true,
          statsFilename: 'bundle-stats.json'
        })
      ]
    };
  }

  // 自动化包体积监控
  static createSizeMonitor() {
    const fs = require('fs');
    const path = require('path');
    
    return {
      checkBundleSize: (buildPath: string, limits: Record<string, number>) => {
        const files = fs.readdirSync(buildPath);
        const violations = [];

        files.forEach(file => {
          const filePath = path.join(buildPath, file);
          const stats = fs.statSync(filePath);
          const sizeKB = stats.size / 1024;

          // 检查是否超过限制
          Object.entries(limits).forEach(([pattern, limit]) => {
            if (file.includes(pattern) && sizeKB > limit) {
              violations.push({
                file,
                size: sizeKB,
                limit,
                excess: sizeKB - limit
              });
            }
          });
        });

        if (violations.length > 0) {
          console.error('Bundle size violations:');
          violations.forEach(v => {
            console.error(`${v.file}: ${v.size.toFixed(1)}KB (limit: ${v.limit}KB, excess: ${v.excess.toFixed(1)}KB)`);
          });
          process.exit(1);
        }
      }
    };
  }

  // 依赖项优化建议
  static analyzeDependencies() {
    const packageJson = require('./package.json');
    const dependencies = packageJson.dependencies || {};
    
    const recommendations = [];

    // 检查大型依赖
    const largeDependencies = {
      'moment': 'day.js (2KB vs 67KB)',
      'lodash': 'lodash-es + tree shaking',
      'antd': '按需导入',
      'echarts': '按需导入'
    };

    Object.keys(dependencies).forEach(dep => {
      if (largeDependencies[dep]) {
        recommendations.push({
          package: dep,
          suggestion: largeDependencies[dep],
          priority: 'high'
        });
      }
    });

    return recommendations;
  }
}

**按需导入配置:**
// babel-plugin-import 配置
// .babelrc
{
  "plugins": [
    [
      "import",
      {
        "libraryName": "antd",
        "libraryDirectory": "es",
        "style": "css"
      },
      "antd"
    ],
    [
      "import",
      {
        "libraryName": "lodash",
        "libraryDirectory": "",
        "camel2DashComponentName": false
      },
      "lodash"
    ]
  ]
}

// 手动按需导入示例
// ❌ 全量导入
import * as _ from 'lodash';
import { Button } from 'antd';

// ✅ 按需导入
import debounce from 'lodash/debounce';
import throttle from 'lodash/throttle';
import Button from 'antd/es/button';
import 'antd/es/button/style/css';
```

---

## 七、内存性能优化

### 内存泄漏检测与修复

**18. 内存泄漏模式识别**
```
Q: 前端常见的内存泄漏模式有哪些？如何检测和修复？

A: 内存泄漏检测与修复：

**常见内存泄漏模式:**
class MemoryLeakDetector {
  // 1. 事件监听器泄漏
  static detectEventListenerLeaks() {
    const leakyExample = {
      // ❌ 忘记移除事件监听器
      badPattern: () => {
        const element = document.getElementById('button');
        const handler = () => console.log('clicked');
        element?.addEventListener('click', handler);
        // 组件销毁时忘记移除监听器
      },

      // ✅ 正确的清理模式
      goodPattern: () => {
        const element = document.getElementById('button');
        const handler = () => console.log('clicked');
        element?.addEventListener('click', handler);
        
        // 返回清理函数
        return () => {
          element?.removeEventListener('click', handler);
        };
      }
    };

    // React Hook 模式
    const useEventListener = (event: string, handler: EventListener) => {
      useEffect(() => {
        document.addEventListener(event, handler);
        return () => document.removeEventListener(event, handler);
      }, [event, handler]);
    };

    return { leakyExample, useEventListener };
  }

  // 2. 定时器泄漏
  static detectTimerLeaks() {
    class TimerManager {
      private timers = new Set<number>();

      createInterval(callback: () => void, delay: number) {
        const timerId = window.setInterval(callback, delay);
        this.timers.add(timerId);
        return timerId;
      }

      createTimeout(callback: () => void, delay: number) {
        const timerId = window.setTimeout(() => {
          callback();
          this.timers.delete(timerId); // 自动清理
        }, delay);
        this.timers.add(timerId);
        return timerId;
      }

      clearTimer(timerId: number) {
        if (this.timers.has(timerId)) {
          clearInterval(timerId);
          clearTimeout(timerId);
          this.timers.delete(timerId);
        }
      }

      clearAllTimers() {
        this.timers.forEach(timerId => {
          clearInterval(timerId);
          clearTimeout(timerId);
        });
        this.timers.clear();
      }
    }

    return TimerManager;
  }

  // 3. 闭包引用泄漏
  static detectClosureLeaks() {
    return {
      // ❌ 闭包持有大对象引用
      leakyPattern: () => {
        const hugeData = new Array(1000000).fill('data');
        
        return function smallFunction() {
          // 即使只用到一小部分，整个 hugeData 都被保持在内存中
          return hugeData[0];
        };
      },

      // ✅ 提取需要的数据
      optimizedPattern: () => {
        const hugeData = new Array(1000000).fill('data');
        const firstItem = hugeData[0]; // 只保留需要的部分
        
        return function smallFunction() {
          return firstItem; // 只引用小数据
        };
      }
    };
  }

  // 4. DOM 引用泄漏
  static detectDOMLeaks() {
    class DOMReferenceManager {
      private domRefs = new WeakMap<Element, any>();

      // ✅ 使用 WeakMap 存储 DOM 引用
      setElementData(element: Element, data: any) {
        this.domRefs.set(element, data);
      }

      getElementData(element: Element) {
        return this.domRefs.get(element);
      }

      // WeakMap 会自动清理已删除的 DOM 元素引用
    }

    // ❌ 强引用 DOM 元素
    const badCache = new Map<string, Element>();

    // ✅ 弱引用模式
    const goodCache = new WeakMap<Element, any>();

    return { DOMReferenceManager, badCache, goodCache };
  }
}

**内存监控工具:**
class MemoryMonitor {
  private measurements: Array<{
    timestamp: number;
    used: number;
    total: number;
  }> = [];

  startMonitoring(interval = 5000) {
    const monitor = () => {
      if (performance.memory) {
        const measurement = {
          timestamp: Date.now(),
          used: performance.memory.usedJSHeapSize,
          total: performance.memory.totalJSHeapSize
        };
        
        this.measurements.push(measurement);
        this.analyzeMemoryTrend();
      }
    };

    setInterval(monitor, interval);
    monitor(); // 立即执行一次
  }

  private analyzeMemoryTrend() {
    if (this.measurements.length < 10) return;

    const recent = this.measurements.slice(-10);
    const growth = recent.map((curr, i) => {
      if (i === 0) return 0;
      return curr.used - recent[i - 1].used;
    });

    const averageGrowth = growth.reduce((a, b) => a + b, 0) / growth.length;
    
    // 如果平均增长超过 1MB/5s，发出警告
    if (averageGrowth > 1024 * 1024) {
      console.warn('⚠️ Potential memory leak detected:', {
        averageGrowth: `${(averageGrowth / 1024 / 1024).toFixed(2)}MB/5s`,
        currentUsage: `${(recent[recent.length - 1].used / 1024 / 1024).toFixed(2)}MB`
      });
      
      this.generateMemoryReport();
    }
  }

  private generateMemoryReport() {
    const last = this.measurements[this.measurements.length - 1];
    const first = this.measurements[0];
    const totalGrowth = last.used - first.used;
    const duration = last.timestamp - first.timestamp;

    console.log('📊 Memory Usage Report:', {
      duration: `${duration / 1000}s`,
      initialUsage: `${(first.used / 1024 / 1024).toFixed(2)}MB`,
      currentUsage: `${(last.used / 1024 / 1024).toFixed(2)}MB`,
      totalGrowth: `${(totalGrowth / 1024 / 1024).toFixed(2)}MB`,
      growthRate: `${(totalGrowth / duration * 1000).toFixed(0)}B/s`
    });
  }

  // 手动触发垃圾回收 (开发环境)
  forceGC() {
    if (window.gc) {
      window.gc();
      console.log('🗑️ Garbage collection triggered');
    } else {
      console.warn('GC not available. Start Chrome with --enable-precise-memory-info --expose-gc');
    }
  }

  // 生成内存快照对比
  async captureHeapSnapshot() {
    return new Promise((resolve) => {
      const beforeGC = performance.memory?.usedJSHeapSize || 0;
      
      // 建议触发 GC
      if (window.gc) {
        window.gc();
      }
      
      setTimeout(() => {
        const afterGC = performance.memory?.usedJSHeapSize || 0;
        const freed = beforeGC - afterGC;
        
        resolve({
          before: beforeGC,
          after: afterGC,
          freed,
          freedMB: (freed / 1024 / 1024).toFixed(2)
        });
      }, 100);
    });
  }
}

// 使用示例
const memoryMonitor = new MemoryMonitor();
memoryMonitor.startMonitoring(3000); // 每3秒检查一次

// 在开发环境中添加内存调试工具
if (process.env.NODE_ENV === 'development') {
  (window as any).memoryMonitor = memoryMonitor;
  (window as any).captureSnapshot = () => memoryMonitor.captureHeapSnapshot();
}
```

---

## 八、性能监控与预算

### 性能预算制定

**19. 性能预算策略设计**
```
Q: 如何制定和执行性能预算？

A: 性能预算实施方案：

**性能预算配置:**
class PerformanceBudget {
  private static readonly BUDGET_CONFIG = {
    // 资源大小预算
    resourceSizes: {
      'main.js': { max: 250, warn: 200 }, // KB
      'vendor.js': { max: 500, warn: 400 },
      'main.css': { max: 50, warn: 40 },
      'total': { max: 2000, warn: 1500 } // 总体积
    },
    
    // 性能指标预算
    metrics: {
      lcp: { max: 2500, warn: 2000 }, // ms
      fid: { max: 100, warn: 80 },
      cls: { max: 0.1, warn: 0.05 },
      fcp: { max: 1800, warn: 1500 },
      tti: { max: 3800, warn: 3000 }
    },
    
    // 网络条件预算
    networkBudgets: {
      '3G': {
        lcp: { max: 4000, warn: 3500 },
        fcp: { max: 3000, warn: 2500 }
      },
      '4G': {
        lcp: { max: 2500, warn: 2000 },
        fcp: { max: 1800, warn: 1500 }
      }
    }
  };

  // Webpack 性能预算插件
  static createWebpackBudgetPlugin() {
    return {
      performance: {
        maxAssetSize: 250 * 1024, // 250KB
        maxEntrypointSize: 500 * 1024, // 500KB
        assetFilter: (assetFilename: string) => {
          // 只检查 JS/CSS 文件
          return assetFilename.endsWith('.js') || assetFilename.endsWith('.css');
        },
        hints: 'error' // 超出预算时报错
      },
      
      // 自定义预算检查插件
      plugins: [
        {
          apply: (compiler: any) => {
            compiler.hooks.afterEmit.tap('BudgetPlugin', (compilation: any) => {
              const assets = compilation.assets;
              const violations = [];

              Object.keys(assets).forEach(assetName => {
                const asset = assets[assetName];
                const sizeKB = asset.size() / 1024;
                const budget = this.BUDGET_CONFIG.resourceSizes[assetName];

                if (budget && sizeKB > budget.max) {
                  violations.push({
                    asset: assetName,
                    size: sizeKB,
                    budget: budget.max,
                    excess: sizeKB - budget.max
                  });
                }
              });

              if (violations.length > 0) {
                console.error('❌ Performance Budget Violations:');
                violations.forEach(v => {
                  console.error(`  ${v.asset}: ${v.size.toFixed(1)}KB (budget: ${v.budget}KB, +${v.excess.toFixed(1)}KB)`);
                });
                
                if (process.env.CI) {
                  process.exit(1); // CI 环境下失败
                }
              }
            });
          }
        }
      ]
    };
  }

  // Lighthouse 预算配置
  static createLighthouseBudget() {
    return {
      budget: [
        {
          path: '/*',
          timings: [
            { metric: 'first-contentful-paint', budget: 1500 },
            { metric: 'largest-contentful-paint', budget: 2500 },
            { metric: 'speed-index', budget: 3000 },
            { metric: 'cumulative-layout-shift', budget: 0.1 }
          ],
          resourceSizes: [
            { resourceType: 'script', budget: 400 },
            { resourceType: 'stylesheet', budget: 50 },
            { resourceType: 'image', budget: 500 },
            { resourceType: 'total', budget: 2000 }
          ]
        }
      ]
    };
  }

  // 运行时预算监控
  static createRuntimeBudgetMonitor() {
    const violations = new Map<string, number>();
    const alerts = new Set<string>();

    return {
      checkMetric: (metricName: string, value: number) => {
        const budget = this.BUDGET_CONFIG.metrics[metricName];
        if (!budget) return;

        if (value > budget.max) {
          violations.set(metricName, value);
          
          if (!alerts.has(metricName)) {
            alerts.add(metricName);
            console.warn(`⚠️ Performance Budget Exceeded: ${metricName}`, {
              value,
              budget: budget.max,
              excess: value - budget.max
            });
            
            // 发送监控数据
            this.reportViolation(metricName, value, budget.max);
          }
        } else if (value > budget.warn) {
          console.info(`ℹ️ Performance Warning: ${metricName} approaching budget`, {
            value,
            budget: budget.max,
            remaining: budget.max - value
          });
        }
      },

      getViolations: () => Array.from(violations.entries()),
      
      generateReport: () => {
        const violationList = Array.from(violations.entries());
        if (violationList.length === 0) {
          return '✅ All performance budgets are within limits';
        }

        return {
          status: 'violations',
          violations: violationList.map(([metric, value]) => ({
            metric,
            value,
            budget: this.BUDGET_CONFIG.metrics[metric]?.max,
            severity: value > this.BUDGET_CONFIG.metrics[metric]?.max ? 'error' : 'warning'
          }))
        };
      }
    };
  }

  private static reportViolation(metric: string, value: number, budget: number) {
    // 发送到监控服务
    if (navigator.sendBeacon) {
      navigator.sendBeacon('/api/performance-violations', JSON.stringify({
        metric,
        value,
        budget,
        timestamp: Date.now(),
        userAgent: navigator.userAgent,
        url: window.location.href
      }));
    }
  }
}
```

### 持续集成性能检查

**20. CI/CD 性能流水线**
```
Q: 如何在 CI/CD 流程中集成性能检查？

A: CI/CD 性能集成方案：

**GitHub Actions 性能检查:**
// .github/workflows/performance.yml
const performanceWorkflow = `
name: Performance Check

on:
  pull_request:
    branches: [ main ]
  push:
    branches: [ main ]

jobs:
  performance-audit:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'
        cache: 'npm'
    
    - name: Install dependencies
      run: npm ci
    
    - name: Build application
      run: npm run build
    
    - name: Check bundle size
      run: npm run check-bundle-size
    
    - name: Run Lighthouse CI
      run: |
        npm install -g @lhci/cli
        lhci autorun
      env:
        LHCI_GITHUB_APP_TOKEN: \${{ secrets.LHCI_GITHUB_APP_TOKEN }}
    
    - name: Performance regression test
      run: npm run performance-test
    
    - name: Upload performance artifacts
      uses: actions/upload-artifact@v3
      with:
        name: performance-report
        path: |
          lighthouse-report.html
          bundle-analyzer-report.html
          performance-metrics.json
`;

**性能回归测试实现:**
class PerformanceRegressionTest {
  private baselineMetrics: Map<string, number> = new Map();
  private currentMetrics: Map<string, number> = new Map();

  // 设置基准数据
  setBaseline(metrics: Record<string, number>) {
    Object.entries(metrics).forEach(([key, value]) => {
      this.baselineMetrics.set(key, value);
    });
  }

  // 记录当前性能数据
  recordCurrent(metrics: Record<string, number>) {
    Object.entries(metrics).forEach(([key, value]) => {
      this.currentMetrics.set(key, value);
    });
  }

  // 检查性能回归
  checkRegression(thresholds: Record<string, number> = {}) {
    const defaultThresholds = {
      lcp: 0.1, // 10% 增长阈值
      fcp: 0.1,
      cls: 0.05,
      bundleSize: 0.05 // 5% 大小增长阈值
    };

    const finalThresholds = { ...defaultThresholds, ...thresholds };
    const regressions = [];

    this.currentMetrics.forEach((currentValue, metric) => {
      const baselineValue = this.baselineMetrics.get(metric);
      if (!baselineValue) return;

      const changeRatio = (currentValue - baselineValue) / baselineValue;
      const threshold = finalThresholds[metric] || 0.1;

      if (changeRatio > threshold) {
        regressions.push({
          metric,
          baseline: baselineValue,
          current: currentValue,
          change: changeRatio,
          threshold,
          severity: changeRatio > threshold * 2 ? 'critical' : 'warning'
        });
      }
    });

    return {
      hasRegression: regressions.length > 0,
      regressions,
      summary: this.generateRegressionSummary(regressions)
    };
  }

  private generateRegressionSummary(regressions: any[]) {
    if (regressions.length === 0) {
      return '✅ No performance regressions detected';
    }

    const critical = regressions.filter(r => r.severity === 'critical');
    const warnings = regressions.filter(r => r.severity === 'warning');

    let summary = `❌ Performance regressions detected:\n`;
    
    if (critical.length > 0) {
      summary += `\n🚨 Critical regressions (${critical.length}):\n`;
      critical.forEach(r => {
        summary += `  - ${r.metric}: ${r.baseline} → ${r.current} (+${(r.change * 100).toFixed(1)}%)\n`;
      });
    }

    if (warnings.length > 0) {
      summary += `\n⚠️ Warning regressions (${warnings.length}):\n`;
      warnings.forEach(r => {
        summary += `  - ${r.metric}: ${r.baseline} → ${r.current} (+${(r.change * 100).toFixed(1)}%)\n`;
      });
    }

    return summary;
  }

  // 生成性能对比报告
  generateComparisonReport() {
    const metrics = Array.from(this.currentMetrics.keys());
    const report = {
      timestamp: new Date().toISOString(),
      comparison: metrics.map(metric => {
        const baseline = this.baselineMetrics.get(metric) || 0;
        const current = this.currentMetrics.get(metric) || 0;
        const change = baseline ? (current - baseline) / baseline : 0;

        return {
          metric,
          baseline,
          current,
          change,
          changePercent: (change * 100).toFixed(2) + '%',
          status: this.getMetricStatus(change)
        };
      })
    };

    return report;
  }

  private getMetricStatus(change: number): 'improved' | 'degraded' | 'stable' {
    if (change < -0.05) return 'improved';
    if (change > 0.05) return 'degraded';
    return 'stable';
  }
}

// package.json 脚本配置
const packageScripts = {
  "scripts": {
    "check-bundle-size": "bundlesize",
    "performance-test": "node scripts/performance-test.js",
    "lighthouse": "lighthouse --chrome-flags=\"--headless\" --output=html --output-path=./lighthouse-report.html http://localhost:3000",
    "analyze-bundle": "webpack-bundle-analyzer build/static/js/*.js"
  },
  
  "bundlesize": [
    {
      "path": "./build/static/js/main.*.js",
      "maxSize": "250 KB"
    },
    {
      "path": "./build/static/css/main.*.css",
      "maxSize": "50 KB"
    }
  ]
};

// Lighthouse CI 配置文件
// .lighthouserc.js
module.exports = {
  ci: {
    collect: {
      startServerCommand: 'npm run serve',
      url: ['http://localhost:3000'],
      numberOfRuns: 3
    },
    assert: {
      assertions: {
        'categories:performance': ['error', { minScore: 0.9 }],
        'categories:accessibility': ['error', { minScore: 0.9 }],
        'categories:best-practices': ['error', { minScore: 0.9 }],
        'categories:seo': ['error', { minScore: 0.9 }]
      }
    },
    upload: {
      target: 'temporary-public-storage'
    }
  }
};
```

---

## 九、实战案例分析

### 综合性能优化案例

**21. 电商网站首页性能优化**
```
Q: 一个电商网站首页 LCP 达到 4.2s，如何系统性地进行优化？

A: 系统性优化方案：

**问题诊断:**
class EcommercePerformanceOptimizer {
  // 1. 性能问题诊断
  static async diagnosePerformanceIssues() {
    const diagnostics = {
      networkAnalysis: await this.analyzeNetworkRequests(),
      renderingAnalysis: await this.analyzeRenderingPath(),
      resourceAnalysis: await this.analyzeResourceLoading(),
      codeAnalysis: await this.analyzeCodePerformance()
    };

    return this.generateDiagnosisReport(diagnostics);
  }

  private static async analyzeNetworkRequests() {
    const resources = performance.getEntriesByType('resource') as PerformanceResourceTiming[];
    
    return {
      totalRequests: resources.length,
      slowRequests: resources.filter(r => r.duration > 1000),
      largeResources: resources.filter(r => r.transferSize > 500 * 1024),
      renderBlockingResources: resources.filter(r => 
        r.name.includes('.css') && r.renderBlockingStatus === 'blocking'
      ),
      criticalChain: this.identifyCriticalChain(resources)
    };
  }

  // 2. 关键渲染路径优化
  static optimizeCriticalRenderingPath() {
    return {
      // 内联关键 CSS
      inlineCriticalCSS: `
        <style>
        /* 关键路径样式 - Above the fold */
        .header { display: flex; height: 80px; background: #fff; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .hero-banner { height: 400px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); }
        .product-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; }
        .product-card { background: #fff; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
        </style>
      `,

      // 预加载关键资源
      preloadCriticalResources: `
        <!-- 关键字体 -->
        <link rel="preload" href="/fonts/brand-font.woff2" as="font" type="font/woff2" crossorigin>
        
        <!-- 关键图片 -->
        <link rel="preload" href="/images/hero-banner.webp" as="image">
        
        <!-- 关键 JavaScript -->
        <link rel="preload" href="/js/critical.js" as="script">
        
        <!-- 预连接第三方域名 -->
        <link rel="preconnect" href="//cdn.shopify.com">
        <link rel="preconnect" href="//fonts.googleapis.com">
      `,

      // 优化 CSS 加载
      optimizedCSSLoading: this.createOptimizedCSSLoader(),
      
      // 优化 JavaScript 加载
      optimizedJSLoading: this.createOptimizedJSLoader()
    };
  }

  // 3. 图片优化策略
  static createImageOptimizationStrategy() {
    return {
      // 响应式图片组件
      ResponsiveImage: ({ src, alt, aspectRatio }: any) => {
        const [loaded, setLoaded] = useState(false);
        const [inView, setInView] = useState(false);
        const imgRef = useRef<HTMLImageElement>(null);

        // 懒加载
        useEffect(() => {
          const observer = new IntersectionObserver(
            ([entry]) => {
              if (entry.isIntersecting) {
                setInView(true);
                observer.disconnect();
              }
            },
            { threshold: 0.1 }
          );

          if (imgRef.current) {
            observer.observe(imgRef.current);
          }

          return () => observer.disconnect();
        }, []);

        // 图片格式检测
        const getOptimalFormat = () => {
          const canvas = document.createElement('canvas');
          const supportsWebP = canvas.toDataURL('image/webp').startsWith('data:image/webp');
          const supportsAVIF = canvas.toDataURL('image/avif').startsWith('data:image/avif');
          
          if (supportsAVIF) return 'avif';
          if (supportsWebP) return 'webp';
          return 'jpg';
        };

        const format = getOptimalFormat();
        const optimizedSrc = `${src}?format=${format}&quality=80`;

        return (
          <div 
            ref={imgRef}
            style={{ aspectRatio }}
            className={`responsive-image ${loaded ? 'loaded' : ''}`}
          >
            {inView && (
              <img
                src={optimizedSrc}
                alt={alt}
                loading="lazy"
                onLoad={() => setLoaded(true)}
                style={{
                  width: '100%',
                  height: '100%',
                  objectFit: 'cover',
                  opacity: loaded ? 1 : 0,
                  transition: 'opacity 0.3s ease'
                }}
              />
            )}
            {!loaded && (
              <div className="image-placeholder">
                <div className="skeleton-loader" />
              </div>
            )}
          </div>
        );
      },

      // 图片预加载策略
      preloadStrategy: {
        // 预加载关键图片
        preloadCritical: () => {
          const criticalImages = [
            '/images/hero-banner.webp',
            '/images/featured-product-1.webp',
            '/images/featured-product-2.webp'
          ];

          criticalImages.forEach(src => {
            const link = document.createElement('link');
            link.rel = 'preload';
            link.as = 'image';
            link.href = src;
            document.head.appendChild(link);
          });
        },

        // 智能预加载
        intelligentPreload: () => {
          // 基于用户行为预加载
          const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
              if (entry.isIntersecting) {
                const productCard = entry.target;
                const nextImage = productCard.nextElementSibling?.querySelector('img');
                if (nextImage && !nextImage.src) {
                  nextImage.src = nextImage.dataset.src;
                }
              }
            });
          }, { rootMargin: '100px' });

          document.querySelectorAll('.product-card').forEach(card => {
            observer.observe(card);
          });
        }
      }
    };
  }

  // 4. 商品数据优化
  static optimizeProductDataLoading() {
    return {
      // 分页加载
      usePaginatedProducts: (pageSize = 20) => {
        const [products, setProducts] = useState([]);
        const [loading, setLoading] = useState(false);
        const [hasMore, setHasMore] = useState(true);
        const [page, setPage] = useState(1);

        const loadMore = useCallback(async () => {
          if (loading || !hasMore) return;

          setLoading(true);
          try {
            const response = await fetch(`/api/products?page=${page}&size=${pageSize}`);
            const newProducts = await response.json();
            
            if (newProducts.length < pageSize) {
              setHasMore(false);
            }
            
            setProducts(prev => [...prev, ...newProducts]);
            setPage(prev => prev + 1);
          } catch (error) {
            console.error('Failed to load products:', error);
          } finally {
            setLoading(false);
          }
        }, [page, pageSize, loading, hasMore]);

        return { products, loadMore, loading, hasMore };
      },

      // 数据预取
      useProductPrefetch: () => {
        const cache = new Map();

        const prefetchProduct = (productId: string) => {
          if (cache.has(productId)) return;

          // 在空闲时间预取
          requestIdleCallback(async () => {
            try {
              const response = await fetch(`/api/products/${productId}`);
              const product = await response.json();
              cache.set(productId, product);
            } catch (error) {
              console.error('Prefetch failed:', error);
            }
          });
        };

        const getProduct = async (productId: string) => {
          if (cache.has(productId)) {
            return cache.get(productId);
          }

          const response = await fetch(`/api/products/${productId}`);
          const product = await response.json();
          cache.set(productId, product);
          return product;
        };

        return { prefetchProduct, getProduct };
      }
    };
  }

  // 5. 第三方脚本优化
  static optimizeThirdPartyScripts() {
    return {
      // 延迟加载非关键脚本
      deferNonCriticalScripts: () => {
        const scripts = [
          { src: '/js/analytics.js', defer: true },
          { src: '/js/chatbot.js', defer: true },
          { src: '/js/recommendations.js', defer: true }
        ];

        // 页面加载完成后再加载
        window.addEventListener('load', () => {
          setTimeout(() => {
            scripts.forEach(({ src, defer }) => {
              const script = document.createElement('script');
              script.src = src;
              script.defer = defer;
              document.head.appendChild(script);
            });
          }, 1000);
        });
      },

      // Facade 模式延迟初始化
      createFacadeComponent: (ThirdPartyComponent: any) => {
        return function FacadeWrapper(props: any) {
          const [loaded, setLoaded] = useState(false);

          const loadComponent = () => {
            setLoaded(true);
          };

          if (!loaded) {
            return (
              <div 
                className="third-party-facade"
                onClick={loadComponent}
                style={{
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'center',
                  minHeight: '200px',
                  background: '#f5f5f5',
                  border: '1px solid #ddd',
                  cursor: 'pointer'
                }}
              >
                <div>
                  <p>点击加载第三方组件</p>
                  <small>减少初始加载时间</small>
                </div>
              </div>
            );
          }

          return <ThirdPartyComponent {...props} />;
        };
      }
    };
  }

  // 优化结果验证
  static createOptimizationValidator() {
    return {
      measureImprovements: async () => {
        const before = {
          lcp: 4200, // 优化前基准
          fcp: 2800,
          cls: 0.15,
          fid: 120
        };

        // 等待页面加载完成后测量
        await new Promise(resolve => {
          if (document.readyState === 'complete') {
            resolve(null);
          } else {
            window.addEventListener('load', resolve);
          }
        });

        const after = await this.getCurrentMetrics();
        
        return {
          improvements: {
            lcp: ((before.lcp - after.lcp) / before.lcp * 100).toFixed(1) + '%',
            fcp: ((before.fcp - after.fcp) / before.fcp * 100).toFixed(1) + '%',
            cls: ((before.cls - after.cls) / before.cls * 100).toFixed(1) + '%',
            fid: ((before.fid - after.fid) / before.fid * 100).toFixed(1) + '%'
          },
          before,
          after
        };
      },

      getCurrentMetrics: async () => {
        return new Promise(resolve => {
          new PerformanceObserver((list) => {
            const metrics: any = {};
            
            for (const entry of list.getEntries()) {
              if (entry.name === 'largest-contentful-paint') {
                metrics.lcp = entry.startTime;
              }
              if (entry.name === 'first-contentful-paint') {
                metrics.fcp = entry.startTime;
              }
            }
            
            resolve(metrics);
          }).observe({ entryTypes: ['paint', 'largest-contentful-paint'] });
        });
      }
    };
  }
}

// 预期优化效果
const expectedResults = {
  lcpImprovement: '4.2s → 2.1s (50% 提升)',
  fcpImprovement: '2.8s → 1.4s (50% 提升)',
  clsImprovement: '0.15 → 0.05 (67% 提升)',
  bundleSizeReduction: '1.2MB → 800KB (33% 减少)',
  requestReduction: '45 → 28 (38% 减少)'
};
```

---

## 🎯 性能优化总结

### 优化优先级矩阵

| 优化方向 | 影响程度 | 实施难度 | 投入产出比 | 优先级 |
|---------|----------|----------|------------|--------|
| 关键资源优化 | 高 | 低 | 很高 | P0 |
| 图片优化 | 高 | 中 | 高 | P0 |
| 代码分割 | 高 | 中 | 高 | P1 |
| 缓存策略 | 中 | 低 | 高 | P1 |
| 第三方脚本优化 | 中 | 中 | 中 | P2 |
| Web Workers | 低 | 高 | 低 | P3 |

### 性能优化检查清单

**🚀 立即可做 (Quick Wins):**
- [ ] 启用 Gzip/Brotli 压缩
- [ ] 添加 Cache-Control 头
- [ ] 压缩和优化图片
- [ ] 内联关键 CSS
- [ ] 添加 preload 关键资源

**📈 中期优化 (Medium Term):**
- [ ] 实施代码分割
- [ ] 配置 CDN
- [ ] 优化字体加载
- [ ] 实施懒加载
- [ ] 设置性能预算

**🔬 高级优化 (Advanced):**
- [ ] 实施 Service Worker
- [ ] 优化关键渲染路径
- [ ] 内存泄漏检测
- [ ] Web Workers 优化
- [ ] 性能监控体系

---

> **更新时间**: 2024年12月  
> **覆盖范围**: 全栈前端性能优化  
> **技术深度**: 初级到高级全覆盖